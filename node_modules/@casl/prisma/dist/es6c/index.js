"use strict";Object.defineProperty(exports,"__esModule",{value:true});var t=require("@ucast/core");var e=require("@ucast/js");var r=require("@casl/ability/extra");var n=require("@casl/ability");class s extends Error{static invalidArgument(t,e,r){const n=`${typeof e}(${JSON.stringify(e,null,2)})`;return new this(`"${t}" expects to receive ${r} but instead got "${n}"`)}}const o=t=>t&&(t.constructor===Object||!t.constructor);const a={type:"field",validate(t,e){if(Array.isArray(e)||o(e))throw new s(`"${t.name}" does not supports comparison of arrays and objects`)}};const i={type:"field",parse(e,r,{hasOperators:n,field:a,parse:i}){if(o(r)&&!n(r)||Array.isArray(r))throw new s(`"${e.name}" does not supports comparison of arrays and objects`);if(!o(r))return new t.FieldCondition("notEquals",a,r);return new t.CompoundCondition("NOT",[i(r,{field:a})])}};const c={type:"field",validate(t,e){if(!Array.isArray(e))throw s.invalidArgument(t.name,e,"an array")}};const u={type:"field",validate(t,e){const r=typeof e;const n="string"===r||"number"===r&&Number.isFinite(e)||e instanceof Date;if(!n)throw s.invalidArgument(t.name,e,"comparable value")}};const l=new Set(["insensitive","default"]);const p={type:"field",validate(t,e){if(!l.has(e))throw s.invalidArgument(t.name,e,`one of ${Array.from(l).join(", ")}`)},parse:()=>t.NULL_CONDITION};const f={type:"field",validate(t,e){if("string"!==typeof e)throw s.invalidArgument(t.name,e,"string")},parse(e,r,{query:n,field:s}){const o="insensitive"===n.mode?`i${e.name}`:e.name;return new t.FieldCondition(o,s,r)}};const y={type:"compound",validate(t,e){if(!e||"object"!==typeof e)throw s.invalidArgument(t.name,e,"an array or object")},parse(e,r,{parse:n}){const s=Array.isArray(r)?r:[r];const o=s.map((t=>n(t)));return new t.CompoundCondition(e.name,o)}};const d={type:"field",validate(t,e){if("boolean"!==typeof e)throw s.invalidArgument(t.name,e,"a boolean")}};const h={type:"field"};const w={type:"field",validate(t,e){if(!Array.isArray(e))throw s.invalidArgument(t.name,e,"an array")}};const b={type:"field",parse(e,r,{field:n,parse:a}){if(!o(r))throw s.invalidArgument(e.name,r,"a query for nested relation");return new t.FieldCondition(e.name,n,a(r))}};const g=(e,r)=>{const n=r.parse;if(!n)return Object.assign({},r,{parse(r,n,s){return new t.CompoundCondition("NOT",[new t.FieldCondition(e,s.field,n)])}});return Object.assign({},r,{parse(r,s,o){const a=n(r,s,o);if(a.operator!==r.name)throw new Error(`Cannot invert "${e}" operator parser because it returns a complex Condition`);a.operator=e;return new t.CompoundCondition("NOT",[a])}})};const v={equals:a,not:i,in:c,notIn:g("in",c),lt:u,lte:u,gt:u,gte:u,mode:p,startsWith:f,endsWith:f,contains:f,isEmpty:d,has:h,hasSome:w,hasEvery:w,NOT:y,AND:y,OR:y,every:b,some:b,none:g("some",b),is:b,isNot:g("is",b)};class m extends t.ObjectQueryParser{constructor(){super(v,{defaultOperatorName:"equals"})}parse(e,r){if(r&&r.field)return t.buildAnd(this.parseFieldOperators(r.field,e));return super.parse(e)}}const A=(t,e,{get:r})=>r(e,t.field).startsWith(t.value);const O=(t,e,{get:r})=>r(e,t.field).toLowerCase().startsWith(t.value.toLowerCase());const j=(t,e,{get:r})=>r(e,t.field).endsWith(t.value);const x=(t,e,{get:r})=>r(e,t.field).toLowerCase().endsWith(t.value.toLowerCase());const N=(t,e,{get:r})=>r(e,t.field).includes(t.value);const $=(t,e,{get:r})=>r(e,t.field).toLowerCase().includes(t.value.toLowerCase());const q=(t,e,{get:r})=>{const n=r(e,t.field);const s=Array.isArray(n)&&0===n.length;return s===t.value};const E=(t,e,{get:r})=>{const n=r(e,t.field);return Array.isArray(n)&&n.includes(t.value)};const T=(t,e,{get:r})=>{const n=r(e,t.field);return Array.isArray(n)&&t.value.some((t=>n.includes(t)))};const W=(t,e,{get:r})=>{const n=r(e,t.field);return Array.isArray(n)&&t.value.every((t=>n.includes(t)))};const S=(t,e,{get:r,interpret:n})=>{const s=r(e,t.field);return Array.isArray(s)&&s.length>0&&s.every((e=>n(t.value,e)))};const _=(t,e,{get:r,interpret:n})=>{const s=r(e,t.field);return Array.isArray(s)&&s.some((e=>n(t.value,e)))};const D=(t,e,{get:r,interpret:n})=>{const s=r(e,t.field);return s&&"object"===typeof s&&n(t.value,s)};const M=(t,e,{interpret:r})=>t.value.every((t=>!r(t,e)));function P(t){return t&&"object"===typeof t?t.valueOf():t}const C=(t,r)=>e.compare(P(t),P(r));const I=e.createJsInterpreter({equals:e.eq,notEquals:e.ne,in:e.within,lt:e.lt,lte:e.lte,gt:e.gt,gte:e.gte,startsWith:A,istartsWith:O,endsWith:j,iendsWith:x,contains:N,icontains:$,isEmpty:q,has:E,hasSome:T,hasEvery:W,and:e.and,or:e.or,AND:e.and,OR:e.or,NOT:M,every:S,some:_,is:D},{get:(t,e)=>t[e],compare:C});const R=new m;const J=t.createTranslatorFactory(R.parse,I);function k(t){return t.inverted?{NOT:t.conditions}:t.conditions}const z={get(t,e){const s=r.rulesToQuery(t.t,t.o,e,k);if(null===s){const r=n.ForbiddenError.from(t.t).setMessage(`It's not allowed to run "${t.o}" on "${e}"`);r.action=t.o;r.subjectType=r.subject=e;throw r}const o=Object.create(null);if(s.$or)o.OR=s.$or;if(s.$and)o.AND=s.$and;return o}};function B(t,e){return new Proxy({t:t,o:e},z)}function F(t,e="read"){return B(t,e)}class PrismaAbility extends n.PureAbility{constructor(t,e){super(t,Object.assign({conditionsMatcher:J,fieldMatcher:n.fieldPatternMatcher},e))}}exports.ParsingQueryError=s;exports.PrismaAbility=PrismaAbility;exports.accessibleBy=F;exports.prismaQuery=J;
//# sourceMappingURL=index.js.map
