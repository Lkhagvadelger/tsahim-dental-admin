{"version":3,"file":"index.js","sources":["../../src/errors/ParsingQueryError.ts","../../src/prisma/PrismaQueryParser.ts","../../src/prisma/interpretPrismaQuery.ts","../../src/prisma/PrismaQuery.ts","../../src/accessibleBy.ts","../../src/PrismaAbility.ts"],"sourcesContent":["export class ParsingQueryError extends Error {\n  static invalidArgument(operatorName: string, value: unknown, expectValueType: string) {\n    const valueType = `${typeof value}(${JSON.stringify(value, null, 2)})`;\n    return new this(\n      `\"${operatorName}\" expects to receive ${expectValueType} but instead got \"${valueType}\"`\n    );\n  }\n}\n","import {\n  buildAnd,\n  Comparable,\n  CompoundCondition,\n  CompoundInstruction,\n  Condition,\n  FieldCondition,\n  FieldInstruction,\n  FieldParsingContext,\n  NULL_CONDITION,\n  ObjectQueryFieldParsingContext,\n  ObjectQueryParser\n} from '@ucast/core';\nimport { ParsingQueryError } from '../errors/ParsingQueryError';\n\nconst isPlainObject = (value: any) => {\n  return value && (value.constructor === Object || !value.constructor);\n};\n\nconst equals: FieldInstruction = {\n  type: 'field',\n  validate(instruction, value) {\n    if (Array.isArray(value) || isPlainObject(value)) {\n      throw new ParsingQueryError(`\"${instruction.name}\" does not supports comparison of arrays and objects`);\n    }\n  }\n};\n\nconst not: FieldInstruction<unknown, ObjectQueryFieldParsingContext> = {\n  type: 'field',\n  parse(instruction, value, { hasOperators, field, parse }) {\n    if (isPlainObject(value) && !hasOperators(value) || Array.isArray(value)) {\n      throw new ParsingQueryError(`\"${instruction.name}\" does not supports comparison of arrays and objects`);\n    }\n\n    if (!isPlainObject(value)) {\n      return new FieldCondition('notEquals', field, value);\n    }\n\n    return new CompoundCondition('NOT', [parse(value, { field })]);\n  }\n};\n\nconst within: FieldInstruction<unknown[]> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!Array.isArray(value)) {\n      throw ParsingQueryError.invalidArgument(instruction.name, value, 'an array');\n    }\n  }\n};\n\nconst lt: FieldInstruction<Comparable> = {\n  type: 'field',\n  validate(instruction, value) {\n    const type = typeof value;\n    const isComparable = type === 'string'\n      || type === 'number' && Number.isFinite(value)\n      || value instanceof Date;\n\n    if (!isComparable) {\n      throw ParsingQueryError.invalidArgument(instruction.name, value, 'comparable value');\n    }\n  }\n};\n\nconst POSSIBLE_MODES = new Set(['insensitive', 'default']);\nconst mode: FieldInstruction<string> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!POSSIBLE_MODES.has(value)) {\n      throw ParsingQueryError.invalidArgument(\n        instruction.name,\n        value,\n        `one of ${Array.from(POSSIBLE_MODES).join(', ')}`\n      );\n    }\n  },\n  parse: () => NULL_CONDITION\n};\n\ninterface StringFieldContext extends FieldParsingContext {\n  query: {\n    mode?: 'insensitive'\n  }\n}\n\nconst compareString: FieldInstruction<string, StringFieldContext> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (typeof value !== 'string') {\n      throw ParsingQueryError.invalidArgument(instruction.name, value, 'string');\n    }\n  },\n  parse(instruction, value, { query, field }) {\n    const name = query.mode === 'insensitive' ? `i${instruction.name}` : instruction.name;\n    return new FieldCondition(name, field, value);\n  }\n};\n\nconst compound: CompoundInstruction = {\n  type: 'compound',\n  validate(instruction, value) {\n    if (!value || typeof value !== 'object') {\n      throw ParsingQueryError.invalidArgument(instruction.name, value, 'an array or object');\n    }\n  },\n  parse(instruction, arrayOrObject, { parse }) {\n    const value = Array.isArray(arrayOrObject) ? arrayOrObject : [arrayOrObject];\n    const conditions = value.map(v => parse(v));\n    return new CompoundCondition(instruction.name, conditions);\n  }\n};\n\nconst isEmpty: FieldInstruction<boolean> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (typeof value !== 'boolean') {\n      throw ParsingQueryError.invalidArgument(instruction.name, value, 'a boolean');\n    }\n  }\n};\n\nconst has: FieldInstruction<unknown> = {\n  type: 'field'\n};\n\nconst hasSome: FieldInstruction<unknown[]> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!Array.isArray(value)) {\n      throw ParsingQueryError.invalidArgument(instruction.name, value, 'an array');\n    }\n  }\n};\n\nconst relation: FieldInstruction<Record<string, unknown>, ObjectQueryFieldParsingContext> = {\n  type: 'field',\n  parse(instruction, value, { field, parse }) {\n    if (!isPlainObject(value)) {\n      throw ParsingQueryError.invalidArgument(instruction.name, value, 'a query for nested relation');\n    }\n\n    return new FieldCondition(instruction.name, field, parse(value));\n  }\n};\n\nconst inverted = (name: string, baseInstruction: FieldInstruction): FieldInstruction => {\n  const parse = baseInstruction.parse;\n\n  if (!parse) {\n    return {\n      ...baseInstruction,\n      parse(_, value, ctx) {\n        return new CompoundCondition('NOT', [new FieldCondition(name, ctx.field, value)]);\n      }\n    };\n  }\n\n  return {\n    ...baseInstruction,\n    parse(instruction, value, ctx) {\n      const condition = parse(instruction, value, ctx);\n      if (condition.operator !== instruction.name) {\n        throw new Error(`Cannot invert \"${name}\" operator parser because it returns a complex Condition`);\n      }\n      (condition as Mutable<Condition>).operator = name;\n      return new CompoundCondition('NOT', [condition]);\n    }\n  };\n};\n\nconst instructions = {\n  equals,\n  not,\n  in: within,\n  notIn: inverted('in', within),\n  lt,\n  lte: lt,\n  gt: lt,\n  gte: lt,\n  mode,\n  startsWith: compareString,\n  endsWith: compareString,\n  contains: compareString,\n  isEmpty,\n  has,\n  hasSome,\n  hasEvery: hasSome,\n  NOT: compound,\n  AND: compound,\n  OR: compound,\n  every: relation,\n  some: relation,\n  none: inverted('some', relation),\n  is: relation,\n  isNot: inverted('is', relation),\n};\n\nexport interface ParseOptions {\n  field: string\n}\n\ntype Query = Record<string, any>;\nexport class PrismaQueryParser extends ObjectQueryParser<Query> {\n  constructor() {\n    super(instructions, {\n      defaultOperatorName: 'equals',\n    });\n  }\n\n  parse(query: Query, options?: ParseOptions): Condition {\n    if (options && options.field) {\n      return buildAnd(this.parseFieldOperators(options.field, query));\n    }\n\n    return super.parse(query);\n  }\n}\n\ntype Mutable<T> = { -readonly [K in keyof T]: T[K] };\n","import { CompoundCondition, Condition, FieldCondition } from '@ucast/core';\nimport {\n  JsInterpreter,\n  createJsInterpreter,\n  eq,\n  ne,\n  and,\n  or,\n  within,\n  lt,\n  lte,\n  gt,\n  gte,\n  compare\n} from '@ucast/js';\n\ntype StringInterpreter = JsInterpreter<FieldCondition<string>, Record<string, string>>;\nconst startsWith: StringInterpreter = (condition, object, { get }) => {\n  return get(object, condition.field).startsWith(condition.value);\n};\nconst istartsWith: StringInterpreter = (condition, object, { get }) => {\n  return get(object, condition.field).toLowerCase().startsWith(condition.value.toLowerCase());\n};\n\nconst endsWith: StringInterpreter = (condition, object, { get }) => {\n  return get(object, condition.field).endsWith(condition.value);\n};\nconst iendsWith: StringInterpreter = (condition, object, { get }) => {\n  return get(object, condition.field).toLowerCase().endsWith(condition.value.toLowerCase());\n};\n\nconst contains: StringInterpreter = (condition, object, { get }) => {\n  return get(object, condition.field).includes(condition.value);\n};\nconst icontains: StringInterpreter = (condition, object, { get }) => {\n  return get(object, condition.field).toLowerCase().includes(condition.value.toLowerCase());\n};\n\ntype ArrayInterpreter<\n  TConditionValue,\n  TValue extends Record<string, unknown[]> = Record<string, unknown[]>\n> = JsInterpreter<FieldCondition<TConditionValue>, TValue>;\nconst isEmpty: ArrayInterpreter<boolean> = (condition, object, { get }) => {\n  const value = get(object, condition.field);\n  const empty = Array.isArray(value) && value.length === 0;\n  return empty === condition.value;\n};\nconst has: ArrayInterpreter<unknown> = (condition, object, { get }) => {\n  const value = get(object, condition.field);\n  return Array.isArray(value) && value.includes(condition.value);\n};\nconst hasSome: ArrayInterpreter<unknown[]> = (condition, object, { get }) => {\n  const value = get(object, condition.field);\n  return Array.isArray(value) && condition.value.some(v => value.includes(v));\n};\nconst hasEvery: ArrayInterpreter<unknown[]> = (condition, object, { get }) => {\n  const value = get(object, condition.field);\n  return Array.isArray(value) && condition.value.every(v => value.includes(v));\n};\n\nconst every: JsInterpreter<FieldCondition<Condition>> = (condition, object, { get, interpret }) => {\n  const items = get(object, condition.field) as Record<string, unknown>[];\n  return Array.isArray(items)\n    && items.length > 0\n    && items.every(item => interpret(condition.value, item));\n};\n\nconst some: JsInterpreter<FieldCondition<Condition>> = (condition, object, { get, interpret }) => {\n  const items = get(object, condition.field) as Record<string, unknown>[];\n  return Array.isArray(items) && items.some(item => interpret(condition.value, item));\n};\n\nconst is: JsInterpreter<FieldCondition<Condition>> = (condition, object, { get, interpret }) => {\n  const item = get(object, condition.field) as Record<string, unknown>;\n  return item && typeof item === 'object' && interpret(condition.value, item);\n};\n\nconst not: JsInterpreter<CompoundCondition> = (condition, object, { interpret }) => {\n  return condition.value.every(subCondition => !interpret(subCondition, object));\n};\n\nfunction toComparable(value: unknown) {\n  return value && typeof value === 'object' ? value.valueOf() : value;\n}\n\nconst compareValues: typeof compare = (a, b) => compare(toComparable(a), toComparable(b));\n\nexport const interpretPrismaQuery = createJsInterpreter({\n  // TODO: support arrays and objects comparison\n  equals: eq,\n  notEquals: ne,\n  in: within,\n  lt,\n  lte,\n  gt,\n  gte,\n  startsWith,\n  istartsWith,\n  endsWith,\n  iendsWith,\n  contains,\n  icontains,\n  isEmpty,\n  has,\n  hasSome,\n  hasEvery,\n  and,\n  or,\n  AND: and,\n  OR: or,\n  NOT: not,\n  every,\n  some,\n  is,\n}, {\n  get: (object, field) => object[field],\n  compare: compareValues,\n});\n","import { PrismaClient, Prisma } from '@prisma/client';\nimport { AnyInterpreter, createTranslatorFactory } from '@ucast/core';\nimport { ForcedSubject, hkt } from '@casl/ability';\nimport { PrismaQueryParser } from './PrismaQueryParser';\nimport { interpretPrismaQuery } from './interpretPrismaQuery';\n\ntype ModelDelegates = {\n  [K in Prisma.ModelName]: Uncapitalize<K> extends keyof PrismaClient\n    ? PrismaClient[Uncapitalize<K>]\n    : never\n};\ntype Present<T> = Exclude<T, null | undefined>;\nexport type WhereInput<TModelName extends Prisma.ModelName> =\n  Present<Present<Parameters<ModelDelegates[TModelName]['findFirst']>[0]>['where']>;\ntype ExtractModelName<T> = T extends { kind: Prisma.ModelName }\n  ? T['kind']\n  : T extends ForcedSubject<Prisma.ModelName>\n    ? T['__caslSubjectType__']\n    : T extends { __typename: Prisma.ModelName }\n      ? T['__typename']\n      : never;\n\ninterface PrismaQueryTypeFactory extends hkt.GenericFactory {\n  produce: WhereInput<ExtractModelName<this[0]>>\n}\n\nexport type Model<T, TName extends string> = T & ForcedSubject<TName>;\nexport type Subjects<T extends Record<Prisma.ModelName, Record<string, unknown>>> =\n  | keyof T\n  | { [K in keyof T]: Model<T[K], K & string> }[keyof T];\n\ntype PrismaModel = Model<Record<string, any>, Prisma.ModelName>;\nexport type PrismaQuery<T extends PrismaModel = PrismaModel> =\n  WhereInput<ExtractModelName<T>> & hkt.Container<PrismaQueryTypeFactory>;\n\nconst parser = new PrismaQueryParser();\nexport const prismaQuery = createTranslatorFactory(\n  parser.parse,\n  interpretPrismaQuery as AnyInterpreter\n);\n","import { Prisma } from '@prisma/client';\nimport { rulesToQuery } from '@casl/ability/extra';\nimport { AnyAbility, ForbiddenError } from '@casl/ability';\nimport { PrismaAbility } from './PrismaAbility';\nimport { WhereInput } from './prisma/PrismaQuery';\n\nfunction convertToPrismaQuery(rule: AnyAbility['rules'][number]) {\n  return rule.inverted ? { NOT: rule.conditions } : rule.conditions;\n}\n\nconst proxyHandlers: ProxyHandler<{ _ability: AnyAbility, _action: string }> = {\n  get(target, subjectType) {\n    const query = rulesToQuery(target._ability, target._action, subjectType, convertToPrismaQuery);\n\n    if (query === null) {\n      const error = ForbiddenError.from(target._ability)\n        .setMessage(`It's not allowed to run \"${target._action}\" on \"${subjectType as string}\"`);\n      error.action = target._action;\n      error.subjectType = error.subject = subjectType as string;\n      throw error;\n    }\n\n    const prismaQuery = Object.create(null);\n\n    if (query.$or) {\n      prismaQuery.OR = query.$or;\n    }\n\n    if (query.$and) {\n      prismaQuery.AND = query.$and;\n    }\n\n    return prismaQuery;\n  }\n};\nfunction createQuery(ability: PrismaAbility, action: string) {\n  return new Proxy({\n    _ability: ability,\n    _action: action\n  }, proxyHandlers) as unknown as AccessibleQuery;\n}\n\ntype AccessibleQuery = {\n  [K in Prisma.ModelName]: WhereInput<K>;\n};\n\nexport function accessibleBy(ability: PrismaAbility<any, any>, action = 'read'): AccessibleQuery {\n  return createQuery(ability, action);\n}\n","import { Prisma } from '@prisma/client';\nimport { AbilityOptions, AbilityTuple, fieldPatternMatcher, PureAbility, RawRuleFrom } from '@casl/ability';\nimport { PrismaQuery, prismaQuery } from './prisma/PrismaQuery';\n\nexport class PrismaAbility<\n  A extends AbilityTuple = [string, Prisma.ModelName],\n  C extends PrismaQuery = PrismaQuery\n> extends PureAbility<A, C> {\n  constructor(rules?: RawRuleFrom<A, C>[], options?: AbilityOptions<A, C>) {\n    super(rules, {\n      conditionsMatcher: prismaQuery,\n      fieldMatcher: fieldPatternMatcher,\n      ...options,\n    });\n  }\n}\n"],"names":["ParsingQueryError","Error","operatorName","value","expectValueType","valueType","JSON","stringify","this","isPlainObject","constructor","Object","equals","type","validate","instruction","Array","isArray","name","not","parse","hasOperators","field","FieldCondition","CompoundCondition","within","invalidArgument","lt","isComparable","Number","isFinite","Date","POSSIBLE_MODES","Set","mode","has","from","join","NULL_CONDITION","compareString","query","compound","arrayOrObject","conditions","map","v","isEmpty","hasSome","relation","inverted","baseInstruction","_","ctx","condition","operator","instructions","in","notIn","lte","gt","gte","startsWith","endsWith","contains","hasEvery","NOT","AND","OR","every","some","none","is","isNot","PrismaQueryParser","ObjectQueryParser","defaultOperatorName","options","buildAnd","parseFieldOperators","super","object","get","istartsWith","toLowerCase","iendsWith","includes","icontains","empty","length","interpret","items","item","subCondition","toComparable","valueOf","compareValues","a","b","compare","interpretPrismaQuery","createJsInterpreter","eq","notEquals","ne","and","or","parser","prismaQuery","createTranslatorFactory","convertToPrismaQuery","rule","proxyHandlers","target","subjectType","rulesToQuery","_ability","_action","error","ForbiddenError","setMessage","action","subject","create","$or","$and","createQuery","ability","Proxy","accessibleBy","PrismaAbility","PureAbility","rules","conditionsMatcher","fieldMatcher","fieldPatternMatcher"],"mappings":"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"}