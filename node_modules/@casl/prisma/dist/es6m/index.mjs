import{FieldCondition as t,CompoundCondition as e,NULL_CONDITION as r,ObjectQueryParser as n,buildAnd as o,createTranslatorFactory as s}from"@ucast/core";import{createJsInterpreter as a,eq as i,ne as c,within as l,lt as p,lte as u,gt as f,gte as y,and as d,or as h,compare as w}from"@ucast/js";import{rulesToQuery as m}from"@casl/ability/extra";import{ForbiddenError as g,PureAbility as b,fieldPatternMatcher as v}from"@casl/ability";class A extends Error{static invalidArgument(t,e,r){const n=`${typeof e}(${JSON.stringify(e,null,2)})`;return new this(`"${t}" expects to receive ${r} but instead got "${n}"`)}}const O=t=>t&&(t.constructor===Object||!t.constructor);const j={type:"field",validate(t,e){if(Array.isArray(e)||O(e))throw new A(`"${t.name}" does not supports comparison of arrays and objects`)}};const N={type:"field",parse(r,n,{hasOperators:o,field:s,parse:a}){if(O(n)&&!o(n)||Array.isArray(n))throw new A(`"${r.name}" does not supports comparison of arrays and objects`);if(!O(n))return new t("notEquals",s,n);return new e("NOT",[a(n,{field:s})])}};const $={type:"field",validate(t,e){if(!Array.isArray(e))throw A.invalidArgument(t.name,e,"an array")}};const x={type:"field",validate(t,e){const r=typeof e;const n="string"===r||"number"===r&&Number.isFinite(e)||e instanceof Date;if(!n)throw A.invalidArgument(t.name,e,"comparable value")}};const E=new Set(["insensitive","default"]);const q={type:"field",validate(t,e){if(!E.has(e))throw A.invalidArgument(t.name,e,`one of ${Array.from(E).join(", ")}`)},parse:()=>r};const T={type:"field",validate(t,e){if("string"!==typeof e)throw A.invalidArgument(t.name,e,"string")},parse(e,r,{query:n,field:o}){const s="insensitive"===n.mode?`i${e.name}`:e.name;return new t(s,o,r)}};const W={type:"compound",validate(t,e){if(!e||"object"!==typeof e)throw A.invalidArgument(t.name,e,"an array or object")},parse(t,r,{parse:n}){const o=Array.isArray(r)?r:[r];const s=o.map((t=>n(t)));return new e(t.name,s)}};const S={type:"field",validate(t,e){if("boolean"!==typeof e)throw A.invalidArgument(t.name,e,"a boolean")}};const D={type:"field"};const P={type:"field",validate(t,e){if(!Array.isArray(e))throw A.invalidArgument(t.name,e,"an array")}};const C={type:"field",parse(e,r,{field:n,parse:o}){if(!O(r))throw A.invalidArgument(e.name,r,"a query for nested relation");return new t(e.name,n,o(r))}};const I=(r,n)=>{const o=n.parse;if(!o)return Object.assign({},n,{parse(n,o,s){return new e("NOT",[new t(r,s.field,o)])}});return Object.assign({},n,{parse(t,n,s){const a=o(t,n,s);if(a.operator!==t.name)throw new Error(`Cannot invert "${r}" operator parser because it returns a complex Condition`);a.operator=r;return new e("NOT",[a])}})};const M={equals:j,not:N,in:$,notIn:I("in",$),lt:x,lte:x,gt:x,gte:x,mode:q,startsWith:T,endsWith:T,contains:T,isEmpty:S,has:D,hasSome:P,hasEvery:P,NOT:W,AND:W,OR:W,every:C,some:C,none:I("some",C),is:C,isNot:I("is",C)};class R extends n{constructor(){super(M,{defaultOperatorName:"equals"})}parse(t,e){if(e&&e.field)return o(this.parseFieldOperators(e.field,t));return super.parse(t)}}const _=(t,e,{get:r})=>r(e,t.field).startsWith(t.value);const J=(t,e,{get:r})=>r(e,t.field).toLowerCase().startsWith(t.value.toLowerCase());const k=(t,e,{get:r})=>r(e,t.field).endsWith(t.value);const z=(t,e,{get:r})=>r(e,t.field).toLowerCase().endsWith(t.value.toLowerCase());const B=(t,e,{get:r})=>r(e,t.field).includes(t.value);const F=(t,e,{get:r})=>r(e,t.field).toLowerCase().includes(t.value.toLowerCase());const G=(t,e,{get:r})=>{const n=r(e,t.field);const o=Array.isArray(n)&&0===n.length;return o===t.value};const H=(t,e,{get:r})=>{const n=r(e,t.field);return Array.isArray(n)&&n.includes(t.value)};const K=(t,e,{get:r})=>{const n=r(e,t.field);return Array.isArray(n)&&t.value.some((t=>n.includes(t)))};const L=(t,e,{get:r})=>{const n=r(e,t.field);return Array.isArray(n)&&t.value.every((t=>n.includes(t)))};const Q=(t,e,{get:r,interpret:n})=>{const o=r(e,t.field);return Array.isArray(o)&&o.length>0&&o.every((e=>n(t.value,e)))};const U=(t,e,{get:r,interpret:n})=>{const o=r(e,t.field);return Array.isArray(o)&&o.some((e=>n(t.value,e)))};const V=(t,e,{get:r,interpret:n})=>{const o=r(e,t.field);return o&&"object"===typeof o&&n(t.value,o)};const X=(t,e,{interpret:r})=>t.value.every((t=>!r(t,e)));function Y(t){return t&&"object"===typeof t?t.valueOf():t}const Z=(t,e)=>w(Y(t),Y(e));const tt=a({equals:i,notEquals:c,in:l,lt:p,lte:u,gt:f,gte:y,startsWith:_,istartsWith:J,endsWith:k,iendsWith:z,contains:B,icontains:F,isEmpty:G,has:H,hasSome:K,hasEvery:L,and:d,or:h,AND:d,OR:h,NOT:X,every:Q,some:U,is:V},{get:(t,e)=>t[e],compare:Z});const et=new R;const rt=s(et.parse,tt);function nt(t){return t.inverted?{NOT:t.conditions}:t.conditions}const ot={get(t,e){const r=m(t.t,t.o,e,nt);if(null===r){const r=g.from(t.t).setMessage(`It's not allowed to run "${t.o}" on "${e}"`);r.action=t.o;r.subjectType=r.subject=e;throw r}const n=Object.create(null);if(r.$or)n.OR=r.$or;if(r.$and)n.AND=r.$and;return n}};function st(t,e){return new Proxy({t:t,o:e},ot)}function at(t,e="read"){return st(t,e)}class PrismaAbility extends b{constructor(t,e){super(t,Object.assign({conditionsMatcher:rt,fieldMatcher:v},e))}}export{A as ParsingQueryError,PrismaAbility,at as accessibleBy,rt as prismaQuery};
//# sourceMappingURL=index.mjs.map
