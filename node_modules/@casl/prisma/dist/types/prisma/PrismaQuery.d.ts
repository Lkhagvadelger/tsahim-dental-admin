import { PrismaClient, Prisma } from '@prisma/client';
import { ForcedSubject, hkt } from '@casl/ability';
declare type ModelDelegates = {
    [K in Prisma.ModelName]: Uncapitalize<K> extends keyof PrismaClient ? PrismaClient[Uncapitalize<K>] : never;
};
declare type Present<T> = Exclude<T, null | undefined>;
export declare type WhereInput<TModelName extends Prisma.ModelName> = Present<Present<Parameters<ModelDelegates[TModelName]['findFirst']>[0]>['where']>;
declare type ExtractModelName<T> = T extends {
    kind: Prisma.ModelName;
} ? T['kind'] : T extends ForcedSubject<Prisma.ModelName> ? T['__caslSubjectType__'] : T extends {
    __typename: Prisma.ModelName;
} ? T['__typename'] : never;
interface PrismaQueryTypeFactory extends hkt.GenericFactory {
    produce: WhereInput<ExtractModelName<this[0]>>;
}
export declare type Model<T, TName extends string> = T & ForcedSubject<TName>;
export declare type Subjects<T extends Record<Prisma.ModelName, Record<string, unknown>>> = keyof T | {
    [K in keyof T]: Model<T[K], K & string>;
}[keyof T];
declare type PrismaModel = Model<Record<string, any>, Prisma.ModelName>;
export declare type PrismaQuery<T extends PrismaModel = PrismaModel> = WhereInput<ExtractModelName<T>> & hkt.Container<PrismaQueryTypeFactory>;
export declare const prismaQuery: (query: Record<string, any>, ...args: unknown[]) => {
    (...args: any[]): any;
    ast: import("@ucast/core").Condition<unknown>;
};
export {};
