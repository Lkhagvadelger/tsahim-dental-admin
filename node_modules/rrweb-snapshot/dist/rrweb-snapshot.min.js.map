{"version":3,"file":"rrweb-snapshot.min.js","sources":["../src/types.ts","../src/utils.ts","../src/snapshot.ts","../src/css.ts","../src/rebuild.ts"],"sourcesContent":["export enum NodeType {\n  Document,\n  DocumentType,\n  Element,\n  Text,\n  CDATA,\n  Comment,\n}\n\nexport type documentNode = {\n  type: NodeType.Document;\n  childNodes: serializedNodeWithId[];\n  compatMode?: string;\n};\n\nexport type documentTypeNode = {\n  type: NodeType.DocumentType;\n  name: string;\n  publicId: string;\n  systemId: string;\n};\n\nexport type attributes = {\n  [key: string]: string | number | boolean;\n};\nexport type elementNode = {\n  type: NodeType.Element;\n  tagName: string;\n  attributes: attributes;\n  childNodes: serializedNodeWithId[];\n  isSVG?: true;\n  needBlock?: boolean;\n};\n\nexport type textNode = {\n  type: NodeType.Text;\n  textContent: string;\n  isStyle?: true;\n};\n\nexport type cdataNode = {\n  type: NodeType.CDATA;\n  textContent: '';\n};\n\nexport type commentNode = {\n  type: NodeType.Comment;\n  textContent: string;\n};\n\nexport type serializedNode = (\n  | documentNode\n  | documentTypeNode\n  | elementNode\n  | textNode\n  | cdataNode\n  | commentNode\n) & {\n  rootId?: number;\n  isShadowHost?: boolean;\n  isShadow?: boolean;\n};\n\nexport type serializedNodeWithId = serializedNode & { id: number };\n\nexport type tagMap = {\n  [key: string]: string;\n};\n\nexport interface INode extends Node {\n  __sn: serializedNodeWithId;\n}\n\nexport type idNodeMap = {\n  [key: number]: INode;\n};\n\nexport type MaskInputOptions = Partial<{\n  color: boolean;\n  date: boolean;\n  'datetime-local': boolean;\n  email: boolean;\n  month: boolean;\n  number: boolean;\n  range: boolean;\n  search: boolean;\n  tel: boolean;\n  text: boolean;\n  time: boolean;\n  url: boolean;\n  week: boolean;\n  // unify textarea and select element with text input\n  textarea: boolean;\n  select: boolean;\n  password: boolean;\n}>;\n\nexport type SlimDOMOptions = Partial<{\n  script: boolean;\n  comment: boolean;\n  headFavicon: boolean;\n  headWhitespace: boolean;\n  headMetaDescKeywords: boolean;\n  headMetaSocial: boolean;\n  headMetaRobots: boolean;\n  headMetaHttpEquiv: boolean;\n  headMetaAuthorship: boolean;\n  headMetaVerification: boolean;\n}>;\n\nexport type MaskTextFn = (text: string) => string;\nexport type MaskInputFn = (text: string) => string;\n\nexport type KeepIframeSrcFn = (src: string) => boolean;\n\nexport type BuildCache = {\n  stylesWithHoverClass: Map<string, string>;\n};\n","import { INode, MaskInputFn, MaskInputOptions } from './types';\n\nexport function isElement(n: Node | INode): n is Element {\n  return n.nodeType === n.ELEMENT_NODE;\n}\n\nexport function isShadowRoot(n: Node): n is ShadowRoot {\n  const host: Element | null = (n as ShadowRoot)?.host;\n  return Boolean(host && host.shadowRoot && host.shadowRoot === n);\n}\n\nexport function maskInputValue({\n  maskInputOptions,\n  tagName,\n  type,\n  value,\n  maskInputFn,\n}: {\n  maskInputOptions: MaskInputOptions;\n  tagName: string;\n  type: string | number | boolean | null;\n  value: string | null;\n  maskInputFn?: MaskInputFn;\n}): string {\n  let text = value || '';\n  if (\n    maskInputOptions[tagName.toLowerCase() as keyof MaskInputOptions] ||\n    maskInputOptions[type as keyof MaskInputOptions]\n  ) {\n    if (maskInputFn) {\n      text = maskInputFn(text);\n    } else {\n      text = '*'.repeat(text.length);\n    }\n  }\n  return text;\n}\n","import {\n  serializedNode,\n  serializedNodeWithId,\n  NodeType,\n  attributes,\n  INode,\n  idNodeMap,\n  MaskInputOptions,\n  SlimDOMOptions,\n  MaskTextFn,\n  MaskInputFn,\n  KeepIframeSrcFn,\n  documentNode,\n} from './types';\nimport { isElement, isShadowRoot, maskInputValue } from './utils';\nimport { values } from 'puppeteer/DeviceDescriptors';\n\nlet _id = 1;\nconst tagNameRegex = RegExp('[^a-z0-9-_:]');\n\nexport const IGNORED_NODE = -2;\n\nfunction genId(): number {\n  return _id++;\n}\n\nfunction getValidTagName(element: HTMLElement): string {\n  if (element instanceof HTMLFormElement) {\n    return 'form';\n  }\n\n  const processedTagName = element.tagName.toLowerCase().trim();\n\n  if (tagNameRegex.test(processedTagName)) {\n    // if the tag name is odd and we cannot extract\n    // anything from the string, then we return a\n    // generic div\n    return 'div';\n  }\n\n  return processedTagName;\n}\n\nfunction getCssRulesString(s: CSSStyleSheet): string | null {\n  try {\n    const rules = s.rules || s.cssRules;\n    return rules ? Array.from(rules).map(getCssRuleString).join('') : null;\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction getCssRuleString(rule: CSSRule): string {\n  let cssStringified = rule.cssText;\n  if (isCSSImportRule(rule)) {\n    try {\n      cssStringified = getCssRulesString(rule.styleSheet) || cssStringified;\n    } catch {}\n  }\n  return cssStringified;\n}\n\nfunction isCSSImportRule(rule: CSSRule): rule is CSSImportRule {\n  return 'styleSheet' in rule;\n}\n\nfunction extractOrigin(url: string): string {\n  let origin;\n  if (url.indexOf('//') > -1) {\n    origin = url.split('/').slice(0, 3).join('/');\n  } else {\n    origin = url.split('/')[0];\n  }\n  origin = origin.split('?')[0];\n  return origin;\n}\n\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nconst RELATIVE_PATH = /^(?!www\\.|(?:http|ftp)s?:\\/\\/|[A-Za-z]:\\\\|\\/\\/|#).*/;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nexport function absoluteToStylesheet(\n  cssText: string | null,\n  href: string,\n): string {\n  return (cssText || '').replace(\n    URL_IN_CSS_REF,\n    (origin, quote1, path1, quote2, path2, path3) => {\n      const filePath = path1 || path2 || path3;\n      const maybeQuote = quote1 || quote2 || '';\n      if (!filePath) {\n        return origin;\n      }\n      if (!RELATIVE_PATH.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (DATA_URI.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (filePath[0] === '/') {\n        return `url(${maybeQuote}${\n          extractOrigin(href) + filePath\n        }${maybeQuote})`;\n      }\n      const stack = href.split('/');\n      const parts = filePath.split('/');\n      stack.pop();\n      for (const part of parts) {\n        if (part === '.') {\n          continue;\n        } else if (part === '..') {\n          stack.pop();\n        } else {\n          stack.push(part);\n        }\n      }\n      return `url(${maybeQuote}${stack.join('/')}${maybeQuote})`;\n    },\n  );\n}\n\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/; // Don't use \\s, to avoid matching non-breaking space\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc: Document, attributeValue: string) {\n  /*\n    run absoluteToDoc over every url in the srcset\n\n    this is adapted from https://github.com/albell/parse-srcset/\n    without the parsing of the descriptors (we return these as-is)\n    parce-srcset is in turn based on\n    https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute\n  */\n  if (attributeValue.trim() === '') {\n    return attributeValue;\n  }\n\n  let pos = 0;\n\n  function collectCharacters(regEx: RegExp) {\n    var chars,\n      match = regEx.exec(attributeValue.substring(pos));\n    if (match) {\n      chars = match[0];\n      pos += chars.length;\n      return chars;\n    }\n    return '';\n  }\n\n  let output = [];\n  while (true) {\n    collectCharacters(SRCSET_COMMAS_OR_SPACES);\n    if (pos >= attributeValue.length) {\n      break;\n    }\n    // don't split on commas within urls\n    let url = collectCharacters(SRCSET_NOT_SPACES);\n    if (url.slice(-1) === ',') {\n      // aside: according to spec more than one comma at the end is a parse error, but we ignore that\n      url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n      // the trailing comma splits the srcset, so the interpretion is that\n      // another url will follow, and the descriptor is empty\n      output.push(url);\n    } else {\n      let descriptorsStr = '';\n      url = absoluteToDoc(doc, url);\n      let inParens = false;\n      while (true) {\n        let c = attributeValue.charAt(pos);\n        if (c === '') {\n          output.push((url + descriptorsStr).trim());\n          break;\n        } else if (!inParens) {\n          if (c === ',') {\n            pos += 1;\n            output.push((url + descriptorsStr).trim());\n            break; // parse the next url\n          } else if (c === '(') {\n            inParens = true;\n          }\n        } else {\n          // in parenthesis; ignore commas\n          // (parenthesis may be supported by future additions to spec)\n          if (c === ')') {\n            inParens = false;\n          }\n        }\n        descriptorsStr += c;\n        pos += 1;\n      }\n    }\n  }\n  return output.join(', ');\n}\n\nexport function absoluteToDoc(doc: Document, attributeValue: string): string {\n  if (!attributeValue || attributeValue.trim() === '') {\n    return attributeValue;\n  }\n  const a: HTMLAnchorElement = doc.createElement('a');\n  a.href = attributeValue;\n  return a.href;\n}\n\nfunction isSVGElement(el: Element): boolean {\n  return el.tagName === 'svg' || el instanceof SVGElement;\n}\n\nfunction getHref() {\n  // return a href without hash\n  const a = document.createElement('a');\n  a.href = '';\n  return a.href;\n}\n\nexport function transformAttribute(\n  doc: Document,\n  tagName: string,\n  name: string,\n  value: string,\n): string {\n  // relative path in attribute\n  if (name === 'src' || (name === 'href' && value)) {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'xlink:href' && value && value[0] !== '#') {\n    // xlink:href starts with # is an id pointer\n    return absoluteToDoc(doc, value);\n  } else if (\n    name === 'background' &&\n    value &&\n    (tagName === 'table' || tagName === 'td' || tagName === 'th')\n  ) {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'srcset' && value) {\n    return getAbsoluteSrcsetString(doc, value);\n  } else if (name === 'style' && value) {\n    return absoluteToStylesheet(value, getHref());\n  } else {\n    return value;\n  }\n}\n\nexport function _isBlockedElement(\n  element: HTMLElement,\n  blockClass: string | RegExp,\n  blockSelector: string | null,\n): boolean {\n  if (typeof blockClass === 'string') {\n    if (element.classList.contains(blockClass)) {\n      return true;\n    }\n  } else {\n    // tslint:disable-next-line: prefer-for-of\n    for (let eIndex = 0; eIndex < element.classList.length; eIndex++) {\n      const className = element.classList[eIndex];\n      if (blockClass.test(className)) {\n        return true;\n      }\n    }\n  }\n  if (blockSelector) {\n    return element.matches(blockSelector);\n  }\n\n  return false;\n}\n\nexport function needMaskingText(\n  node: Node | null,\n  maskTextClass: string | RegExp,\n  maskTextSelector: string | null,\n): boolean {\n  if (!node) {\n    return false;\n  }\n  if (node.nodeType === node.ELEMENT_NODE) {\n    if (typeof maskTextClass === 'string') {\n      if ((node as HTMLElement).classList.contains(maskTextClass)) {\n        return true;\n      }\n    } else {\n      (node as HTMLElement).classList.forEach((className) => {\n        if (maskTextClass.test(className)) {\n          return true;\n        }\n      });\n    }\n    if (maskTextSelector) {\n      if ((node as HTMLElement).matches(maskTextSelector)) {\n        return true;\n      }\n    }\n    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n  }\n  if (node.nodeType === node.TEXT_NODE) {\n    // check parent node since text node do not have class name\n    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n  }\n  return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n}\n\n// https://stackoverflow.com/a/36155560\nfunction onceIframeLoaded(\n  iframeEl: HTMLIFrameElement,\n  listener: () => unknown,\n  iframeLoadTimeout: number,\n) {\n  const win = iframeEl.contentWindow;\n  if (!win) {\n    return;\n  }\n  // document is loading\n  let fired = false;\n\n  let readyState: DocumentReadyState;\n  try {\n    readyState = win.document.readyState;\n  } catch (error) {\n    return;\n  }\n  if (readyState !== 'complete') {\n    const timer = setTimeout(() => {\n      if (!fired) {\n        listener();\n        fired = true;\n      }\n    }, iframeLoadTimeout);\n    iframeEl.addEventListener('load', () => {\n      clearTimeout(timer);\n      fired = true;\n      listener();\n    });\n    return;\n  }\n  // check blank frame for Chrome\n  const blankUrl = 'about:blank';\n  if (\n    win.location.href !== blankUrl ||\n    iframeEl.src === blankUrl ||\n    iframeEl.src === ''\n  ) {\n    // iframe was already loaded, make sure we wait to trigger the listener\n    // till _after_ the mutation that found this iframe has had time to process\n    setTimeout(listener, 0);\n    return;\n  }\n  // use default listener\n  iframeEl.addEventListener('load', listener);\n}\n\nfunction stringifyStyleSheet(sheet: CSSStyleSheet): string {\n  return sheet.cssRules\n    ? Array.from(sheet.cssRules)\n        .map((rule) => rule.cssText || '')\n        .join('')\n    : '';\n}\n\nfunction serializeNode(\n  n: Node,\n  options: {\n    doc: Document;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    maskTextClass: string | RegExp;\n    maskTextSelector: string | null;\n    inlineStylesheet: boolean;\n    maskInputOptions: MaskInputOptions;\n    maskTextFn: MaskTextFn | undefined;\n    maskInputFn: MaskInputFn | undefined;\n    recordCanvas: boolean;\n    keepIframeSrcFn: KeepIframeSrcFn;\n  },\n): serializedNode | false {\n  const {\n    doc,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    recordCanvas,\n    keepIframeSrcFn,\n  } = options;\n  // Only record root id when document object is not the base document\n  let rootId: number | undefined;\n  if (((doc as unknown) as INode).__sn) {\n    const docId = ((doc as unknown) as INode).__sn.id;\n    rootId = docId === 1 ? undefined : docId;\n  }\n  switch (n.nodeType) {\n    case n.DOCUMENT_NODE:\n      if ((n as HTMLDocument).compatMode !== 'CSS1Compat') {\n        return {\n          type: NodeType.Document,\n          childNodes: [],\n          compatMode: (n as HTMLDocument).compatMode, // probably \"BackCompat\"\n          rootId,\n        };\n      } else {\n        return {\n          type: NodeType.Document,\n          childNodes: [],\n          rootId,\n        };\n      }\n    case n.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType.DocumentType,\n        name: (n as DocumentType).name,\n        publicId: (n as DocumentType).publicId,\n        systemId: (n as DocumentType).systemId,\n        rootId,\n      };\n    case n.ELEMENT_NODE:\n      const needBlock = _isBlockedElement(\n        n as HTMLElement,\n        blockClass,\n        blockSelector,\n      );\n      const tagName = getValidTagName(n as HTMLElement);\n      let attributes: attributes = {};\n      for (const { name, value } of Array.from((n as HTMLElement).attributes)) {\n        attributes[name] = transformAttribute(doc, tagName, name, value);\n      }\n      // remote css\n      if (tagName === 'link' && inlineStylesheet) {\n        const stylesheet = Array.from(doc.styleSheets).find((s) => {\n          return s.href === (n as HTMLLinkElement).href;\n        });\n        const cssText = getCssRulesString(stylesheet as CSSStyleSheet);\n        if (cssText) {\n          delete attributes.rel;\n          delete attributes.href;\n          attributes._cssText = absoluteToStylesheet(\n            cssText,\n            stylesheet!.href!,\n          );\n        }\n      }\n      // dynamic stylesheet\n      if (\n        tagName === 'style' &&\n        (n as HTMLStyleElement).sheet &&\n        // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n        !(\n          (n as HTMLElement).innerText ||\n          (n as HTMLElement).textContent ||\n          ''\n        ).trim().length\n      ) {\n        const cssText = getCssRulesString(\n          (n as HTMLStyleElement).sheet as CSSStyleSheet,\n        );\n        if (cssText) {\n          attributes._cssText = absoluteToStylesheet(cssText, getHref());\n        }\n      }\n      // form fields\n      if (\n        tagName === 'input' ||\n        tagName === 'textarea' ||\n        tagName === 'select'\n      ) {\n        const value = (n as HTMLInputElement | HTMLTextAreaElement).value;\n        if (\n          attributes.type !== 'radio' &&\n          attributes.type !== 'checkbox' &&\n          attributes.type !== 'submit' &&\n          attributes.type !== 'button' &&\n          value\n        ) {\n          attributes.value = maskInputValue({\n            type: attributes.type,\n            tagName,\n            value,\n            maskInputOptions,\n            maskInputFn,\n          });\n        } else if ((n as HTMLInputElement).checked) {\n          attributes.checked = (n as HTMLInputElement).checked;\n        }\n      }\n      if (tagName === 'option') {\n        if ((n as HTMLOptionElement).selected) {\n          attributes.selected = true;\n        } else {\n          // ignore the html attribute (which corresponds to DOM (n as HTMLOptionElement).defaultSelected)\n          // if it's already been changed\n          delete attributes.selected;\n        }\n      }\n      // canvas image data\n      if (tagName === 'canvas' && recordCanvas) {\n        attributes.rr_dataURL = (n as HTMLCanvasElement).toDataURL();\n      }\n      // media elements\n      if (tagName === 'audio' || tagName === 'video') {\n        attributes.rr_mediaState = (n as HTMLMediaElement).paused\n          ? 'paused'\n          : 'played';\n        attributes.rr_mediaCurrentTime = (n as HTMLMediaElement).currentTime;\n      }\n      // scroll\n      if ((n as HTMLElement).scrollLeft) {\n        attributes.rr_scrollLeft = (n as HTMLElement).scrollLeft;\n      }\n      if ((n as HTMLElement).scrollTop) {\n        attributes.rr_scrollTop = (n as HTMLElement).scrollTop;\n      }\n      // block element\n      if (needBlock) {\n        const { width, height } = (n as HTMLElement).getBoundingClientRect();\n        attributes = {\n          class: attributes.class,\n          rr_width: `${width}px`,\n          rr_height: `${height}px`,\n        };\n      }\n      // iframe\n      if (tagName === 'iframe' && !keepIframeSrcFn(attributes.src as string)) {\n        if (!(n as HTMLIFrameElement).contentDocument) {\n          // we can't record it directly as we can't see into it\n          // preserve the src attribute so a decision can be taken at replay time\n          attributes.rr_src = attributes.src;\n        }\n        delete attributes.src; // prevent auto loading\n      }\n      return {\n        type: NodeType.Element,\n        tagName,\n        attributes,\n        childNodes: [],\n        isSVG: isSVGElement(n as Element) || undefined,\n        needBlock,\n        rootId,\n      };\n    case n.TEXT_NODE:\n      // The parent node may not be a html element which has a tagName attribute.\n      // So just let it be undefined which is ok in this use case.\n      const parentTagName =\n        n.parentNode && (n.parentNode as HTMLElement).tagName;\n      let textContent = (n as Text).textContent;\n      const isStyle = parentTagName === 'STYLE' ? true : undefined;\n      const isScript = parentTagName === 'SCRIPT' ? true : undefined;\n      if (isStyle && textContent) {\n        try {\n          // try to read style sheet\n          if ((n.parentNode as HTMLStyleElement).sheet?.cssRules) {\n            textContent = stringifyStyleSheet(\n              (n.parentNode as HTMLStyleElement).sheet!,\n            );\n          }\n        } catch {\n          // ignore error\n        }\n        textContent = absoluteToStylesheet(textContent, getHref());\n      }\n      if (isScript) {\n        textContent = 'SCRIPT_PLACEHOLDER';\n      }\n      if (\n        !isStyle &&\n        !isScript &&\n        needMaskingText(n, maskTextClass, maskTextSelector) &&\n        textContent\n      ) {\n        textContent = maskTextFn\n          ? maskTextFn(textContent)\n          : textContent.replace(/[\\S]/g, '*');\n      }\n      return {\n        type: NodeType.Text,\n        textContent: textContent || '',\n        isStyle,\n        rootId,\n      };\n    case n.CDATA_SECTION_NODE:\n      return {\n        type: NodeType.CDATA,\n        textContent: '',\n        rootId,\n      };\n    case n.COMMENT_NODE:\n      return {\n        type: NodeType.Comment,\n        textContent: (n as Comment).textContent || '',\n        rootId,\n      };\n    default:\n      return false;\n  }\n}\n\nfunction lowerIfExists(maybeAttr: string | number | boolean): string {\n  if (maybeAttr === undefined) {\n    return '';\n  } else {\n    return (maybeAttr as string).toLowerCase();\n  }\n}\n\nfunction slimDOMExcluded(\n  sn: serializedNode,\n  slimDOMOptions: SlimDOMOptions,\n): boolean {\n  if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\n    // TODO: convert IE conditional comments to real nodes\n    return true;\n  } else if (sn.type === NodeType.Element) {\n    if (\n      slimDOMOptions.script &&\n      // script tag\n      (sn.tagName === 'script' ||\n        // preload link\n        (sn.tagName === 'link' &&\n          sn.attributes.rel === 'preload' &&\n          sn.attributes.as === 'script') ||\n        // prefetch link\n        (sn.tagName === 'link' &&\n          sn.attributes.rel === 'prefetch' &&\n          typeof sn.attributes.href === 'string' &&\n          sn.attributes.href.endsWith('.js')))\n    ) {\n      return true;\n    } else if (\n      slimDOMOptions.headFavicon &&\n      ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\n        (sn.tagName === 'meta' &&\n          (lowerIfExists(sn.attributes.name).match(\n            /^msapplication-tile(image|color)$/,\n          ) ||\n            lowerIfExists(sn.attributes.name) === 'application-name' ||\n            lowerIfExists(sn.attributes.rel) === 'icon' ||\n            lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\n            lowerIfExists(sn.attributes.rel) === 'shortcut icon')))\n    ) {\n      return true;\n    } else if (sn.tagName === 'meta') {\n      if (\n        slimDOMOptions.headMetaDescKeywords &&\n        lowerIfExists(sn.attributes.name).match(/^description|keywords$/)\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaSocial &&\n        (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n          lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\n          lowerIfExists(sn.attributes.name) === 'pinterest')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaRobots &&\n        (lowerIfExists(sn.attributes.name) === 'robots' ||\n          lowerIfExists(sn.attributes.name) === 'googlebot' ||\n          lowerIfExists(sn.attributes.name) === 'bingbot')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaHttpEquiv &&\n        sn.attributes['http-equiv'] !== undefined\n      ) {\n        // e.g. X-UA-Compatible, Content-Type, Content-Language,\n        // cache-control, X-Translated-By\n        return true;\n      } else if (\n        slimDOMOptions.headMetaAuthorship &&\n        (lowerIfExists(sn.attributes.name) === 'author' ||\n          lowerIfExists(sn.attributes.name) === 'generator' ||\n          lowerIfExists(sn.attributes.name) === 'framework' ||\n          lowerIfExists(sn.attributes.name) === 'publisher' ||\n          lowerIfExists(sn.attributes.name) === 'progid' ||\n          lowerIfExists(sn.attributes.property).match(/^article:/) ||\n          lowerIfExists(sn.attributes.property).match(/^product:/))\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaVerification &&\n        (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\n          lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\n          lowerIfExists(sn.attributes.name) === 'csrf-token' ||\n          lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\n          lowerIfExists(sn.attributes.name) === 'verify-v1' ||\n          lowerIfExists(sn.attributes.name) === 'verification' ||\n          lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport function serializeNodeWithId(\n  n: Node | INode,\n  options: {\n    doc: Document;\n    map: idNodeMap;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    maskTextClass: string | RegExp;\n    maskTextSelector: string | null;\n    skipChild: boolean;\n    inlineStylesheet: boolean;\n    maskInputOptions?: MaskInputOptions;\n    maskTextFn: MaskTextFn | undefined;\n    maskInputFn: MaskInputFn | undefined;\n    slimDOMOptions: SlimDOMOptions;\n    keepIframeSrcFn?: KeepIframeSrcFn;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n    onSerialize?: (n: INode) => unknown;\n    onIframeLoad?: (iframeINode: INode, node: serializedNodeWithId) => unknown;\n    iframeLoadTimeout?: number;\n  },\n): serializedNodeWithId | null {\n  const {\n    doc,\n    map,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    skipChild = false,\n    inlineStylesheet = true,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    recordCanvas = false,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout = 5000,\n    keepIframeSrcFn = () => false,\n  } = options;\n  let { preserveWhiteSpace = true } = options;\n  const _serializedNode = serializeNode(n, {\n    doc,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    inlineStylesheet,\n    maskInputOptions,\n    maskTextFn,\n    maskInputFn,\n    recordCanvas,\n    keepIframeSrcFn,\n  });\n  if (!_serializedNode) {\n    // TODO: dev only\n    console.warn(n, 'not serialized');\n    return null;\n  }\n\n  let id;\n  // Try to reuse the previous id\n  if ('__sn' in n) {\n    id = n.__sn.id;\n  } else if (\n    slimDOMExcluded(_serializedNode, slimDOMOptions) ||\n    (!preserveWhiteSpace &&\n      _serializedNode.type === NodeType.Text &&\n      !_serializedNode.isStyle &&\n      !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)\n  ) {\n    id = IGNORED_NODE;\n  } else {\n    id = genId();\n  }\n  const serializedNode = Object.assign(_serializedNode, { id });\n  (n as INode).__sn = serializedNode;\n  if (id === IGNORED_NODE) {\n    return null; // slimDOM\n  }\n  map[id] = n as INode;\n  if (onSerialize) {\n    onSerialize(n as INode);\n  }\n  let recordChild = !skipChild;\n  if (serializedNode.type === NodeType.Element) {\n    recordChild = recordChild && !serializedNode.needBlock;\n    // this property was not needed in replay side\n    delete serializedNode.needBlock;\n  }\n  if (\n    (serializedNode.type === NodeType.Document ||\n      serializedNode.type === NodeType.Element) &&\n    recordChild\n  ) {\n    if (\n      slimDOMOptions.headWhitespace &&\n      _serializedNode.type === NodeType.Element &&\n      _serializedNode.tagName === 'head'\n      // would impede performance: || getComputedStyle(n)['white-space'] === 'normal'\n    ) {\n      preserveWhiteSpace = false;\n    }\n    const bypassOptions = {\n      doc,\n      map,\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      skipChild,\n      inlineStylesheet,\n      maskInputOptions,\n      maskTextFn,\n      maskInputFn,\n      slimDOMOptions,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n      keepIframeSrcFn,\n    };\n    for (const childN of Array.from(n.childNodes)) {\n      const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n      if (serializedChildNode) {\n        serializedNode.childNodes.push(serializedChildNode);\n      }\n    }\n\n    if (isElement(n) && n.shadowRoot) {\n      serializedNode.isShadowHost = true;\n      for (const childN of Array.from(n.shadowRoot.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          serializedChildNode.isShadow = true;\n          serializedNode.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n  }\n\n  if (n.parentNode && isShadowRoot(n.parentNode)) {\n    serializedNode.isShadow = true;\n  }\n\n  if (\n    serializedNode.type === NodeType.Element &&\n    serializedNode.tagName === 'iframe'\n  ) {\n    onceIframeLoaded(\n      n as HTMLIFrameElement,\n      () => {\n        const iframeDoc = (n as HTMLIFrameElement).contentDocument;\n        if (iframeDoc && onIframeLoad) {\n          const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n            doc: iframeDoc,\n            map,\n            blockClass,\n            blockSelector,\n            maskTextClass,\n            maskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            keepIframeSrcFn,\n          });\n\n          if (serializedIframeNode) {\n            onIframeLoad(n as INode, serializedIframeNode);\n          }\n        }\n      },\n      iframeLoadTimeout,\n    );\n  }\n\n  return serializedNode;\n}\n\nfunction snapshot(\n  n: Document,\n  options?: {\n    blockClass?: string | RegExp;\n    blockSelector?: string | null;\n    maskTextClass?: string | RegExp;\n    maskTextSelector?: string | null;\n    inlineStylesheet?: boolean;\n    maskAllInputs?: boolean | MaskInputOptions;\n    maskTextFn?: MaskTextFn;\n    maskInputFn?: MaskTextFn;\n    slimDOM?: boolean | SlimDOMOptions;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n    onSerialize?: (n: INode) => unknown;\n    onIframeLoad?: (iframeINode: INode, node: serializedNodeWithId) => unknown;\n    iframeLoadTimeout?: number;\n    keepIframeSrcFn?: KeepIframeSrcFn;\n  },\n): [serializedNodeWithId | null, idNodeMap] {\n  const {\n    blockClass = 'rr-block',\n    blockSelector = null,\n    maskTextClass = 'rr-mask',\n    maskTextSelector = null,\n    inlineStylesheet = true,\n    recordCanvas = false,\n    maskAllInputs = false,\n    maskTextFn,\n    maskInputFn,\n    slimDOM = false,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    keepIframeSrcFn = () => false,\n  } = options || {};\n  const idNodeMap: idNodeMap = {};\n  const maskInputOptions: MaskInputOptions =\n    maskAllInputs === true\n      ? {\n          color: true,\n          date: true,\n          'datetime-local': true,\n          email: true,\n          month: true,\n          number: true,\n          range: true,\n          search: true,\n          tel: true,\n          text: true,\n          time: true,\n          url: true,\n          week: true,\n          textarea: true,\n          select: true,\n          password: true,\n        }\n      : maskAllInputs === false\n      ? {\n          password: true,\n        }\n      : maskAllInputs;\n  const slimDOMOptions: SlimDOMOptions =\n    slimDOM === true || slimDOM === 'all'\n      ? // if true: set of sensible options that should not throw away any information\n        {\n          script: true,\n          comment: true,\n          headFavicon: true,\n          headWhitespace: true,\n          headMetaDescKeywords: slimDOM === 'all', // destructive\n          headMetaSocial: true,\n          headMetaRobots: true,\n          headMetaHttpEquiv: true,\n          headMetaAuthorship: true,\n          headMetaVerification: true,\n        }\n      : slimDOM === false\n      ? {}\n      : slimDOM;\n  return [\n    serializeNodeWithId(n, {\n      doc: n,\n      map: idNodeMap,\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      skipChild: false,\n      inlineStylesheet,\n      maskInputOptions,\n      maskTextFn,\n      maskInputFn,\n      slimDOMOptions,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n      keepIframeSrcFn,\n    }),\n    idNodeMap,\n  ];\n}\n\nexport function visitSnapshot(\n  node: serializedNodeWithId,\n  onVisit: (node: serializedNodeWithId) => unknown,\n) {\n  function walk(current: serializedNodeWithId) {\n    onVisit(current);\n    if (\n      current.type === NodeType.Document ||\n      current.type === NodeType.Element\n    ) {\n      current.childNodes.forEach(walk);\n    }\n  }\n\n  walk(node);\n}\n\nexport function cleanupSnapshot() {\n  // allow a new recording to start numbering nodes from scratch\n  _id = 1;\n}\n\nexport default snapshot;\n","/**\n * This file is a fork of https://github.com/reworkcss/css/blob/master/lib/parse/index.js\n * I fork it because:\n * 1. The css library was built for node.js which does not have tree-shaking supports.\n * 2. Rewrites into typescript give us a better type interface.\n */\n\n/* tslint:disable no-conditional-assignment interface-name no-shadowed-variable */\n\nexport interface ParserOptions {\n  /** Silently fail on parse errors */\n  silent?: boolean;\n  /**\n   * The path to the file containing css.\n   * Makes errors and source maps more helpful, by letting them know where code comes from.\n   */\n  source?: string;\n}\n\n/**\n * Error thrown during parsing.\n */\nexport interface ParserError {\n  /** The full error message with the source position. */\n  message?: string;\n  /** The error message without position. */\n  reason?: string;\n  /** The value of options.source if passed to css.parse. Otherwise undefined. */\n  filename?: string;\n  line?: number;\n  column?: number;\n  /** The portion of code that couldn't be parsed. */\n  source?: string;\n}\n\nexport interface Loc {\n  line?: number;\n  column?: number;\n}\n\n/**\n * Base AST Tree Node.\n */\nexport interface Node {\n  /** The possible values are the ones listed in the Types section on https://github.com/reworkcss/css page. */\n  type?: string;\n  /** A reference to the parent node, or null if the node has no parent. */\n  parent?: Node;\n  /** Information about the position in the source string that corresponds to the node. */\n  position?: {\n    start?: Loc;\n    end?: Loc;\n    /** The value of options.source if passed to css.parse. Otherwise undefined. */\n    source?: string;\n    /** The full source string passed to css.parse. */\n    content?: string;\n  };\n}\n\nexport interface Rule extends Node {\n  /** The list of selectors of the rule, split on commas. Each selector is trimmed from whitespace and comments. */\n  selectors?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\nexport interface Declaration extends Node {\n  /** The property name, trimmed from whitespace and comments. May not be empty. */\n  property?: string;\n  /** The value of the property, trimmed from whitespace and comments. Empty values are allowed. */\n  value?: string;\n}\n\n/**\n * A rule-level or declaration-level comment. Comments inside selectors, properties and values etc. are lost.\n */\nexport interface Comment extends Node {\n  comment?: string;\n}\n\n/**\n * The @charset at-rule.\n */\nexport interface Charset extends Node {\n  /** The part following @charset. */\n  charset?: string;\n}\n\n/**\n * The @custom-media at-rule\n */\nexport interface CustomMedia extends Node {\n  /** The ---prefixed name. */\n  name?: string;\n  /** The part following the name. */\n  media?: string;\n}\n\n/**\n * The @document at-rule.\n */\nexport interface Document extends Node {\n  /** The part following @document. */\n  document?: string;\n  /** The vendor prefix in @document, or undefined if there is none. */\n  vendor?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/**\n * The @font-face at-rule.\n */\nexport interface FontFace extends Node {\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @host at-rule.\n */\nexport interface Host extends Node {\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/**\n * The @import at-rule.\n */\nexport interface Import extends Node {\n  /** The part following @import. */\n  import?: string;\n}\n\n/**\n * The @keyframes at-rule.\n */\nexport interface KeyFrames extends Node {\n  /** The name of the keyframes rule. */\n  name?: string;\n  /** The vendor prefix in @keyframes, or undefined if there is none. */\n  vendor?: string;\n  /** Array of nodes with the types keyframe and comment. */\n  keyframes?: Array<KeyFrame | Comment>;\n}\n\nexport interface KeyFrame extends Node {\n  /** The list of \"selectors\" of the keyframe rule, split on commas. Each “selector” is trimmed from whitespace. */\n  values?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @media at-rule.\n */\nexport interface Media extends Node {\n  /** The part following @media. */\n  media?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/**\n * The @namespace at-rule.\n */\nexport interface Namespace extends Node {\n  /** The part following @namespace. */\n  namespace?: string;\n}\n\n/**\n * The @page at-rule.\n */\nexport interface Page extends Node {\n  /** The list of selectors of the rule, split on commas. Each selector is trimmed from whitespace and comments. */\n  selectors?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @supports at-rule.\n */\nexport interface Supports extends Node {\n  /** The part following @supports. */\n  supports?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/** All at-rules. */\nexport type AtRule =\n  | Charset\n  | CustomMedia\n  | Document\n  | FontFace\n  | Host\n  | Import\n  | KeyFrames\n  | Media\n  | Namespace\n  | Page\n  | Supports;\n\n/**\n * A collection of rules\n */\nexport interface StyleRules {\n  source?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules: Array<Rule | Comment | AtRule>;\n  /** Array of Errors. Errors collected during parsing when option silent is true. */\n  parsingErrors?: ParserError[];\n}\n\n/**\n * The root node returned by css.parse.\n */\nexport interface Stylesheet extends Node {\n  stylesheet?: StyleRules;\n}\n\n// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nconst commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nexport function parse(css: string, options: ParserOptions = {}) {\n  /**\n   * Positional.\n   */\n\n  let lineno = 1;\n  let column = 1;\n\n  /**\n   * Update lineno and column based on `str`.\n   */\n\n  function updatePosition(str: string) {\n    const lines = str.match(/\\n/g);\n    if (lines) {\n      lineno += lines.length;\n    }\n    let i = str.lastIndexOf('\\n');\n    column = i === -1 ? column + str.length : str.length - i;\n  }\n\n  /**\n   * Mark position and patch `node.position`.\n   */\n\n  function position() {\n    const start = { line: lineno, column };\n    return (\n      node: Rule | Declaration | Comment | AtRule | Stylesheet | KeyFrame,\n    ) => {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  /**\n   * Store position information for a node\n   */\n\n  class Position {\n    public content!: string;\n    public start!: Loc;\n    public end!: Loc;\n    public source?: string;\n\n    constructor(start: Loc) {\n      this.start = start;\n      this.end = { line: lineno, column };\n      this.source = options.source;\n    }\n  }\n\n  /**\n   * Non-enumerable source string\n   */\n\n  Position.prototype.content = css;\n\n  const errorsList: ParserError[] = [];\n\n  function error(msg: string) {\n    const err = new Error(\n      options.source + ':' + lineno + ':' + column + ': ' + msg,\n    ) as ParserError;\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = css;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /**\n   * Parse stylesheet.\n   */\n\n  function stylesheet(): Stylesheet {\n    const rulesList = rules();\n\n    return {\n      type: 'stylesheet',\n      stylesheet: {\n        source: options.source,\n        rules: rulesList,\n        parsingErrors: errorsList,\n      },\n    };\n  }\n\n  /**\n   * Opening brace.\n   */\n\n  function open() {\n    return match(/^{\\s*/);\n  }\n\n  /**\n   * Closing brace.\n   */\n\n  function close() {\n    return match(/^}/);\n  }\n\n  /**\n   * Parse ruleset.\n   */\n\n  function rules() {\n    let node: Rule | void;\n    const rules: Rule[] = [];\n    whitespace();\n    comments(rules);\n    while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {\n      if (node !== false) {\n        rules.push(node);\n        comments(rules);\n      }\n    }\n    return rules;\n  }\n\n  /**\n   * Match `re` and return captures.\n   */\n\n  function match(re: RegExp) {\n    const m = re.exec(css);\n    if (!m) {\n      return;\n    }\n    const str = m[0];\n    updatePosition(str);\n    css = css.slice(str.length);\n    return m;\n  }\n\n  /**\n   * Parse whitespace.\n   */\n\n  function whitespace() {\n    match(/^\\s*/);\n  }\n\n  /**\n   * Parse comments;\n   */\n\n  function comments(rules: Rule[] = []) {\n    let c: Comment | void;\n    while ((c = comment())) {\n      if (c !== false) {\n        rules.push(c);\n      }\n      c = comment();\n    }\n    return rules;\n  }\n\n  /**\n   * Parse comment.\n   */\n\n  function comment() {\n    const pos = position();\n    if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {\n      return;\n    }\n\n    let i = 2;\n    while (\n      '' !== css.charAt(i) &&\n      ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))\n    ) {\n      ++i;\n    }\n    i += 2;\n\n    if ('' === css.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    const str = css.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    css = css.slice(i);\n    column += 2;\n\n    return pos({\n      type: 'comment',\n      comment: str,\n    });\n  }\n\n  /**\n   * Parse selector.\n   */\n\n  function selector() {\n    const m = match(/^([^{]+)/);\n    if (!m) {\n      return;\n    }\n    /* @fix Remove all comments from selectors\n     * http://ostermiller.org/findcomment.html */\n    return trim(m[0])\n      .replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, '')\n      .replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, (m) => {\n        return m.replace(/,/g, '\\u200C');\n      })\n      .split(/\\s*(?![^(]*\\)),\\s*/)\n      .map((s) => {\n        return s.replace(/\\u200C/g, ',');\n      });\n  }\n\n  /**\n   * Parse declaration.\n   */\n\n  function declaration(): Declaration | void | never {\n    const pos = position();\n\n    // prop\n    let propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\n    if (!propMatch) {\n      return;\n    }\n    const prop = trim(propMatch[0]);\n\n    // :\n    if (!match(/^:\\s*/)) {\n      return error(`property missing ':'`);\n    }\n\n    // val\n    const val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\n\n    const ret = pos({\n      type: 'declaration',\n      property: prop.replace(commentre, ''),\n      value: val ? trim(val[0]).replace(commentre, '') : '',\n    });\n\n    // ;\n    match(/^[;\\s]*/);\n\n    return ret;\n  }\n\n  /**\n   * Parse declarations.\n   */\n\n  function declarations() {\n    const decls: Array<object> = [];\n\n    if (!open()) {\n      return error(`missing '{'`);\n    }\n    comments(decls);\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      if ((decl as unknown) !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n      decl = declaration();\n    }\n\n    if (!close()) {\n      return error(`missing '}'`);\n    }\n    return decls;\n  }\n\n  /**\n   * Parse keyframe.\n   */\n\n  function keyframe() {\n    let m;\n    const vals = [];\n    const pos = position();\n\n    while ((m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/))) {\n      vals.push(m[1]);\n      match(/^,\\s*/);\n    }\n\n    if (!vals.length) {\n      return;\n    }\n\n    return pos({\n      type: 'keyframe',\n      values: vals,\n      declarations: declarations() as Declaration[],\n    });\n  }\n\n  /**\n   * Parse keyframes.\n   */\n\n  function atkeyframes() {\n    const pos = position();\n    let m = match(/^@([-\\w]+)?keyframes\\s*/);\n\n    if (!m) {\n      return;\n    }\n    const vendor = m[1];\n\n    // identifier\n    m = match(/^([-\\w]+)\\s*/);\n    if (!m) {\n      return error('@keyframes missing name');\n    }\n    const name = m[1];\n\n    if (!open()) {\n      return error(`@keyframes missing '{'`);\n    }\n\n    let frame;\n    let frames = comments();\n    while ((frame = keyframe())) {\n      frames.push(frame);\n      frames = frames.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@keyframes missing '}'`);\n    }\n\n    return pos({\n      type: 'keyframes',\n      name,\n      vendor,\n      keyframes: frames,\n    });\n  }\n\n  /**\n   * Parse supports.\n   */\n\n  function atsupports() {\n    const pos = position();\n    const m = match(/^@supports *([^{]+)/);\n\n    if (!m) {\n      return;\n    }\n    const supports = trim(m[1]);\n\n    if (!open()) {\n      return error(`@supports missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@supports missing '}'`);\n    }\n\n    return pos({\n      type: 'supports',\n      supports,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse host.\n   */\n\n  function athost() {\n    const pos = position();\n    const m = match(/^@host\\s*/);\n\n    if (!m) {\n      return;\n    }\n\n    if (!open()) {\n      return error(`@host missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@host missing '}'`);\n    }\n\n    return pos({\n      type: 'host',\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse media.\n   */\n\n  function atmedia() {\n    const pos = position();\n    const m = match(/^@media *([^{]+)/);\n\n    if (!m) {\n      return;\n    }\n    const media = trim(m[1]);\n\n    if (!open()) {\n      return error(`@media missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@media missing '}'`);\n    }\n\n    return pos({\n      type: 'media',\n      media,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse custom-media.\n   */\n\n  function atcustommedia() {\n    const pos = position();\n    const m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\n    if (!m) {\n      return;\n    }\n\n    return pos({\n      type: 'custom-media',\n      name: trim(m[1]),\n      media: trim(m[2]),\n    });\n  }\n\n  /**\n   * Parse paged media.\n   */\n\n  function atpage() {\n    const pos = position();\n    const m = match(/^@page */);\n    if (!m) {\n      return;\n    }\n\n    const sel = selector() || [];\n\n    if (!open()) {\n      return error(`@page missing '{'`);\n    }\n    let decls = comments();\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@page missing '}'`);\n    }\n\n    return pos({\n      type: 'page',\n      selectors: sel,\n      declarations: decls,\n    });\n  }\n\n  /**\n   * Parse document.\n   */\n\n  function atdocument() {\n    const pos = position();\n    const m = match(/^@([-\\w]+)?document *([^{]+)/);\n    if (!m) {\n      return;\n    }\n\n    const vendor = trim(m[1]);\n    const doc = trim(m[2]);\n\n    if (!open()) {\n      return error(`@document missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@document missing '}'`);\n    }\n\n    return pos({\n      type: 'document',\n      document: doc,\n      vendor,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse font-face.\n   */\n\n  function atfontface() {\n    const pos = position();\n    const m = match(/^@font-face\\s*/);\n    if (!m) {\n      return;\n    }\n\n    if (!open()) {\n      return error(`@font-face missing '{'`);\n    }\n    let decls = comments();\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@font-face missing '}'`);\n    }\n\n    return pos({\n      type: 'font-face',\n      declarations: decls,\n    });\n  }\n\n  /**\n   * Parse import\n   */\n\n  const atimport = _compileAtrule('import');\n\n  /**\n   * Parse charset\n   */\n\n  const atcharset = _compileAtrule('charset');\n\n  /**\n   * Parse namespace\n   */\n\n  const atnamespace = _compileAtrule('namespace');\n\n  /**\n   * Parse non-block at-rules\n   */\n\n  function _compileAtrule(name: string) {\n    const re = new RegExp('^@' + name + '\\\\s*([^;]+);');\n    return () => {\n      const pos = position();\n      const m = match(re);\n      if (!m) {\n        return;\n      }\n      const ret: Record<string, string> = { type: name };\n      ret[name] = m[1].trim();\n      return pos(ret);\n    };\n  }\n\n  /**\n   * Parse at rule.\n   */\n\n  function atrule() {\n    if (css[0] !== '@') {\n      return;\n    }\n\n    return (\n      atkeyframes() ||\n      atmedia() ||\n      atcustommedia() ||\n      atsupports() ||\n      atimport() ||\n      atcharset() ||\n      atnamespace() ||\n      atdocument() ||\n      atpage() ||\n      athost() ||\n      atfontface()\n    );\n  }\n\n  /**\n   * Parse rule.\n   */\n\n  function rule() {\n    const pos = position();\n    const sel = selector();\n\n    if (!sel) {\n      return error('selector missing');\n    }\n    comments();\n\n    return pos({\n      type: 'rule',\n      selectors: sel,\n      declarations: declarations() as Declaration[],\n    });\n  }\n\n  return addParent(stylesheet());\n}\n\n/**\n * Trim `str`.\n */\n\nfunction trim(str: string) {\n  return str ? str.replace(/^\\s+|\\s+$/g, '') : '';\n}\n\n/**\n * Adds non-enumerable parent node reference to each node.\n */\n\nfunction addParent(obj: Stylesheet, parent?: Stylesheet) {\n  const isNode = obj && typeof obj.type === 'string';\n  const childParent = isNode ? obj : parent;\n\n  for (const k of Object.keys(obj)) {\n    const value = obj[k as keyof Stylesheet];\n    if (Array.isArray(value)) {\n      value.forEach((v) => {\n        addParent(v, childParent);\n      });\n    } else if (value && typeof value === 'object') {\n      addParent((value as unknown) as Stylesheet, childParent);\n    }\n  }\n\n  if (isNode) {\n    Object.defineProperty(obj, 'parent', {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: parent || null,\n    });\n  }\n\n  return obj;\n}\n","import { parse } from './css';\nimport {\n  serializedNodeWithId,\n  NodeType,\n  tagMap,\n  elementNode,\n  idNodeMap,\n  INode,\n  BuildCache,\n} from './types';\nimport { isElement } from './utils';\n\nconst tagMap: tagMap = {\n  script: 'noscript',\n  // camel case svg element tag names\n  altglyph: 'altGlyph',\n  altglyphdef: 'altGlyphDef',\n  altglyphitem: 'altGlyphItem',\n  animatecolor: 'animateColor',\n  animatemotion: 'animateMotion',\n  animatetransform: 'animateTransform',\n  clippath: 'clipPath',\n  feblend: 'feBlend',\n  fecolormatrix: 'feColorMatrix',\n  fecomponenttransfer: 'feComponentTransfer',\n  fecomposite: 'feComposite',\n  feconvolvematrix: 'feConvolveMatrix',\n  fediffuselighting: 'feDiffuseLighting',\n  fedisplacementmap: 'feDisplacementMap',\n  fedistantlight: 'feDistantLight',\n  fedropshadow: 'feDropShadow',\n  feflood: 'feFlood',\n  fefunca: 'feFuncA',\n  fefuncb: 'feFuncB',\n  fefuncg: 'feFuncG',\n  fefuncr: 'feFuncR',\n  fegaussianblur: 'feGaussianBlur',\n  feimage: 'feImage',\n  femerge: 'feMerge',\n  femergenode: 'feMergeNode',\n  femorphology: 'feMorphology',\n  feoffset: 'feOffset',\n  fepointlight: 'fePointLight',\n  fespecularlighting: 'feSpecularLighting',\n  fespotlight: 'feSpotLight',\n  fetile: 'feTile',\n  feturbulence: 'feTurbulence',\n  foreignobject: 'foreignObject',\n  glyphref: 'glyphRef',\n  lineargradient: 'linearGradient',\n  radialgradient: 'radialGradient',\n};\nfunction getTagName(n: elementNode): string {\n  let tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\n  if (tagName === 'link' && n.attributes._cssText) {\n    tagName = 'style';\n  }\n  return tagName;\n}\n\n// based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping\nfunction escapeRegExp(str: string) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nconst HOVER_SELECTOR = /([^\\\\]):hover/;\nconst HOVER_SELECTOR_GLOBAL = new RegExp(HOVER_SELECTOR, 'g');\nexport function addHoverClass(cssText: string, cache: BuildCache): string {\n  const cachedStyle = cache?.stylesWithHoverClass.get(cssText);\n  if (cachedStyle) return cachedStyle;\n\n  const ast = parse(cssText, {\n    silent: true,\n  });\n\n  if (!ast.stylesheet) {\n    return cssText;\n  }\n\n  const selectors: string[] = [];\n  ast.stylesheet.rules.forEach((rule) => {\n    if ('selectors' in rule) {\n      (rule.selectors || []).forEach((selector: string) => {\n        if (HOVER_SELECTOR.test(selector)) {\n          selectors.push(selector);\n        }\n      });\n    }\n  });\n\n  if (selectors.length === 0) {\n    return cssText;\n  }\n\n  const selectorMatcher = new RegExp(\n    selectors\n      .filter((selector, index) => selectors.indexOf(selector) === index)\n      .sort((a, b) => b.length - a.length)\n      .map((selector) => {\n        return escapeRegExp(selector);\n      })\n      .join('|'),\n    'g',\n  );\n\n  const result = cssText.replace(selectorMatcher, (selector) => {\n    const newSelector = selector.replace(HOVER_SELECTOR_GLOBAL, '$1.\\\\:hover');\n    return `${selector}, ${newSelector}`;\n  });\n  cache?.stylesWithHoverClass.set(cssText, result);\n  return result;\n}\n\nexport function createCache(): BuildCache {\n  const stylesWithHoverClass: Map<string, string> = new Map();\n  return {\n    stylesWithHoverClass,\n  };\n}\n\nfunction buildNode(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    hackCss: boolean;\n    cache: BuildCache;\n  },\n): Node | null {\n  const { doc, hackCss, cache } = options;\n  switch (n.type) {\n    case NodeType.Document:\n      return doc.implementation.createDocument(null, '', null);\n    case NodeType.DocumentType:\n      return doc.implementation.createDocumentType(\n        n.name || 'html',\n        n.publicId,\n        n.systemId,\n      );\n    case NodeType.Element:\n      const tagName = getTagName(n);\n      let node: Element;\n      if (n.isSVG) {\n        node = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\n      } else {\n        node = doc.createElement(tagName);\n      }\n      for (const name in n.attributes) {\n        if (!n.attributes.hasOwnProperty(name)) {\n          continue;\n        }\n        let value = n.attributes[name];\n        if (tagName === 'option' && name === 'selected' && value === false) {\n          // legacy fix (TODO: if `value === false` can be generated for other attrs, should we also omit those other attrs from build?)\n          continue;\n        }\n        value =\n          typeof value === 'boolean' || typeof value === 'number' ? '' : value;\n        // attribute names start with rr_ are internal attributes added by rrweb\n        if (!name.startsWith('rr_')) {\n          const isTextarea = tagName === 'textarea' && name === 'value';\n          const isRemoteOrDynamicCss =\n            tagName === 'style' && name === '_cssText';\n          if (isRemoteOrDynamicCss && hackCss) {\n            value = addHoverClass(value, cache);\n          }\n          if (isTextarea || isRemoteOrDynamicCss) {\n            const child = doc.createTextNode(value);\n            // https://github.com/rrweb-io/rrweb/issues/112\n            for (const c of Array.from(node.childNodes)) {\n              if (c.nodeType === node.TEXT_NODE) {\n                node.removeChild(c);\n              }\n            }\n            node.appendChild(child);\n            continue;\n          }\n\n          try {\n            if (n.isSVG && name === 'xlink:href') {\n              node.setAttributeNS('http://www.w3.org/1999/xlink', name, value);\n            } else if (\n              name === 'onload' ||\n              name === 'onclick' ||\n              name.substring(0, 7) === 'onmouse'\n            ) {\n              // Rename some of the more common atttributes from https://www.w3schools.com/tags/ref_eventattributes.asp\n              // as setting them triggers a console.error (which shows up despite the try/catch)\n              // Assumption: these attributes are not used to css\n              node.setAttribute('_' + name, value);\n            } else if (\n              tagName === 'meta' &&\n              n.attributes['http-equiv'] === 'Content-Security-Policy' &&\n              name === 'content'\n            ) {\n              // If CSP contains style-src and inline-style is disabled, there will be an error \"Refused to apply inline style because it violates the following Content Security Policy directive: style-src '*'\".\n              // And the function insertStyleRules in rrweb replayer will throw an error \"Uncaught TypeError: Cannot read property 'insertRule' of null\".\n              node.setAttribute('csp-content', value);\n              continue;\n            } else if (\n              tagName === 'link' &&\n              n.attributes.rel === 'preload' &&\n              n.attributes.as === 'script'\n            ) {\n              // ignore\n            } else if (\n              tagName === 'link' &&\n              n.attributes.rel === 'prefetch' &&\n              typeof n.attributes.href === 'string' &&\n              n.attributes.href.endsWith('.js')\n            ) {\n              // ignore\n            } else {\n              node.setAttribute(name, value);\n            }\n          } catch (error) {\n            // skip invalid attribute\n          }\n        } else {\n          // handle internal attributes\n          if (tagName === 'canvas' && name === 'rr_dataURL') {\n            const image = document.createElement('img');\n            image.src = value;\n            image.onload = () => {\n              const ctx = (node as HTMLCanvasElement).getContext('2d');\n              if (ctx) {\n                ctx.drawImage(image, 0, 0, image.width, image.height);\n              }\n            };\n          }\n          if (name === 'rr_width') {\n            (node as HTMLElement).style.width = value;\n          }\n          if (name === 'rr_height') {\n            (node as HTMLElement).style.height = value;\n          }\n          if (name === 'rr_mediaCurrentTime') {\n            (node as HTMLMediaElement).currentTime = n.attributes\n              .rr_mediaCurrentTime as number;\n          }\n          if (name === 'rr_mediaState') {\n            switch (value) {\n              case 'played':\n                (node as HTMLMediaElement)\n                  .play()\n                  .catch((e) => console.warn('media playback error', e));\n                break;\n              case 'paused':\n                (node as HTMLMediaElement).pause();\n                break;\n              default:\n            }\n          }\n        }\n      }\n      if (n.isShadowHost) {\n        /**\n         * Since node is newly rebuilt, it should be a normal element\n         * without shadowRoot.\n         * But if there are some weird situations that has defined\n         * custom element in the scope before we rebuild node, it may\n         * register the shadowRoot earlier.\n         * The logic in the 'else' block is just a try-my-best solution\n         * for the corner case, please let we know if it is wrong and\n         * we can remove it.\n         */\n        if (!node.shadowRoot) {\n          node.attachShadow({ mode: 'open' });\n        } else {\n          while (node.shadowRoot.firstChild) {\n            node.shadowRoot.removeChild(node.shadowRoot.firstChild);\n          }\n        }\n      }\n      return node;\n    case NodeType.Text:\n      return doc.createTextNode(\n        n.isStyle && hackCss\n          ? addHoverClass(n.textContent, cache)\n          : n.textContent,\n      );\n    case NodeType.CDATA:\n      return doc.createCDATASection(n.textContent);\n    case NodeType.Comment:\n      return doc.createComment(n.textContent);\n    default:\n      return null;\n  }\n}\n\nexport function buildNodeWithSN(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    map: idNodeMap;\n    skipChild?: boolean;\n    hackCss: boolean;\n    afterAppend?: (n: INode) => unknown;\n    cache: BuildCache;\n  },\n): INode | null {\n  const {\n    doc,\n    map,\n    skipChild = false,\n    hackCss = true,\n    afterAppend,\n    cache,\n  } = options;\n  let node = buildNode(n, { doc, hackCss, cache });\n  if (!node) {\n    return null;\n  }\n  if (n.rootId) {\n    console.assert(\n      ((map[n.rootId] as unknown) as Document) === doc,\n      'Target document should has the same root id.',\n    );\n  }\n  // use target document as root document\n  if (n.type === NodeType.Document) {\n    // close before open to make sure document was closed\n    doc.close();\n    doc.open();\n    if (\n      n.compatMode === 'BackCompat' &&\n      n.childNodes &&\n      n.childNodes[0].type !== NodeType.DocumentType // there isn't one already defined\n    ) {\n      // Trigger compatMode in the iframe\n      // this is needed as document.createElement('iframe') otherwise inherits a CSS1Compat mode from the parent replayer environment\n      if (\n        n.childNodes[0].type === NodeType.Element &&\n        'xmlns' in n.childNodes[0].attributes &&\n        n.childNodes[0].attributes.xmlns === 'http://www.w3.org/1999/xhtml'\n      ) {\n        // might as well use an xhtml doctype if we've got an xhtml namespace\n        doc.write(\n          '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">',\n        );\n      } else {\n        doc.write(\n          '<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">',\n        );\n      }\n    }\n    node = doc;\n  }\n\n  (node as INode).__sn = n;\n  map[n.id] = node as INode;\n\n  if (\n    (n.type === NodeType.Document || n.type === NodeType.Element) &&\n    !skipChild\n  ) {\n    for (const childN of n.childNodes) {\n      const childNode = buildNodeWithSN(childN, {\n        doc,\n        map,\n        skipChild: false,\n        hackCss,\n        afterAppend,\n        cache,\n      });\n      if (!childNode) {\n        console.warn('Failed to rebuild', childN);\n        continue;\n      }\n\n      if (childN.isShadow && isElement(node) && node.shadowRoot) {\n        node.shadowRoot.appendChild(childNode);\n      } else {\n        node.appendChild(childNode);\n      }\n      if (afterAppend) {\n        afterAppend(childNode);\n      }\n    }\n  }\n\n  return node as INode;\n}\n\nfunction visit(idNodeMap: idNodeMap, onVisit: (node: INode) => void) {\n  function walk(node: INode) {\n    onVisit(node);\n  }\n\n  for (const key in idNodeMap) {\n    if (idNodeMap[key]) {\n      walk(idNodeMap[key]);\n    }\n  }\n}\n\nfunction handleScroll(node: INode) {\n  const n = node.__sn;\n  if (n.type !== NodeType.Element) {\n    return;\n  }\n  const el = (node as Node) as HTMLElement;\n  for (const name in n.attributes) {\n    if (!(n.attributes.hasOwnProperty(name) && name.startsWith('rr_'))) {\n      continue;\n    }\n    const value = n.attributes[name];\n    if (name === 'rr_scrollLeft') {\n      el.scrollLeft = value as number;\n    }\n    if (name === 'rr_scrollTop') {\n      el.scrollTop = value as number;\n    }\n  }\n}\n\nfunction rebuild(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    onVisit?: (node: INode) => unknown;\n    hackCss?: boolean;\n    afterAppend?: (n: INode) => unknown;\n    cache: BuildCache;\n  },\n): [Node | null, idNodeMap] {\n  const { doc, onVisit, hackCss = true, afterAppend, cache } = options;\n  const idNodeMap: idNodeMap = {};\n  const node = buildNodeWithSN(n, {\n    doc,\n    map: idNodeMap,\n    skipChild: false,\n    hackCss,\n    afterAppend,\n    cache,\n  });\n  visit(idNodeMap, (visitedNode) => {\n    if (onVisit) {\n      onVisit(visitedNode);\n    }\n    handleScroll(visitedNode);\n  });\n  return [node, idNodeMap];\n}\n\nexport default rebuild;\n"],"names":["NodeType","isElement","n","nodeType","ELEMENT_NODE","isShadowRoot","host","Boolean","shadowRoot","maskInputValue","_a","maskInputOptions","tagName","type","value","maskInputFn","text","toLowerCase","repeat","length","_id","tagNameRegex","RegExp","getCssRulesString","s","rules","cssRules","Array","from","map","getCssRuleString","join","error","rule","cssStringified","cssText","isCSSImportRule","styleSheet","URL_IN_CSS_REF","RELATIVE_PATH","DATA_URI","absoluteToStylesheet","href","replace","origin","quote1","path1","quote2","path2","path3","url","filePath","maybeQuote","test","indexOf","split","slice","stack","parts","pop","parts_1","_i","part","push","SRCSET_NOT_SPACES","SRCSET_COMMAS_OR_SPACES","absoluteToDoc","doc","attributeValue","trim","a","createElement","getHref","document","transformAttribute","name","pos","collectCharacters","regEx","chars","match","exec","substring","output","descriptorsStr","inParens","c","charAt","getAbsoluteSrcsetString","needMaskingText","node","maskTextClass","maskTextSelector","classList","contains","forEach","className","matches","parentNode","TEXT_NODE","serializeNode","options","rootId","sheet","el","blockClass","blockSelector","inlineStylesheet","_b","maskTextFn","recordCanvas","keepIframeSrcFn","__sn","docId","id","undefined","DOCUMENT_NODE","compatMode","Document","childNodes","DOCUMENT_TYPE_NODE","DocumentType","publicId","systemId","needBlock","element","eIndex","_isBlockedElement","HTMLFormElement","processedTagName","getValidTagName","attributes","_c","_d","name_1","stylesheet","styleSheets","find","rel","_cssText","innerText","textContent","checked","selected","rr_dataURL","toDataURL","rr_mediaState","paused","rr_mediaCurrentTime","currentTime","scrollLeft","rr_scrollLeft","scrollTop","rr_scrollTop","_e","getBoundingClientRect","width","height","class","rr_width","rr_height","src","contentDocument","rr_src","Element","isSVG","SVGElement","parentTagName","isStyle","isScript","Text","CDATA_SECTION_NODE","CDATA","COMMENT_NODE","Comment","lowerIfExists","maybeAttr","serializeNodeWithId","skipChild","slimDOMOptions","onSerialize","onIframeLoad","iframeLoadTimeout","_f","_g","preserveWhiteSpace","_serializedNode","console","warn","sn","comment","script","as","endsWith","headFavicon","headMetaDescKeywords","headMetaSocial","property","headMetaRobots","headMetaHttpEquiv","headMetaAuthorship","headMetaVerification","slimDOMExcluded","serializedNode","Object","assign","recordChild","headWhitespace","bypassOptions","_h","serializedChildNode","isShadowHost","_k","_j","isShadow","iframeEl","listener","win","contentWindow","readyState","fired","blankUrl","location","addEventListener","setTimeout","timer_1","clearTimeout","onceIframeLoaded","iframeDoc","serializedIframeNode","commentre","parse","css","lineno","column","updatePosition","str","lines","i","lastIndexOf","position","start","line","Position","whitespace","this","end","source","prototype","content","errorsList","msg","err","Error","reason","filename","silent","open","close","comments","atrule","re","m","selector","declaration","propMatch","prop","val","ret","declarations","decl","decls","keyframe","vals","values","rulesList","atimport","_compileAtrule","atcharset","atnamespace","vendor","frame","frames","concat","keyframes","atkeyframes","media","style","atmedia","atcustommedia","supports","atsupports","atdocument","sel","selectors","atpage","athost","atfontface","addParent","parsingErrors","obj","parent","isNode","childParent","keys","isArray","v","defineProperty","configurable","writable","enumerable","tagMap","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","clippath","feblend","fecolormatrix","fecomponenttransfer","fecomposite","feconvolvematrix","fediffuselighting","fedisplacementmap","fedistantlight","fedropshadow","feflood","fefunca","fefuncb","fefuncg","fefuncr","fegaussianblur","feimage","femerge","femergenode","femorphology","feoffset","fepointlight","fespecularlighting","fespotlight","fetile","feturbulence","foreignobject","glyphref","lineargradient","radialgradient","HOVER_SELECTOR","HOVER_SELECTOR_GLOBAL","addHoverClass","cache","cachedStyle","stylesWithHoverClass","get","ast","selectorMatcher","filter","index","sort","b","result","newSelector","set","buildNode","hackCss","implementation","createDocument","createDocumentType","node_1","getTagName","createElementNS","hasOwnProperty","startsWith","image_1","onload","ctx","getContext","drawImage","play","e","pause","isTextarea","isRemoteOrDynamicCss","child","createTextNode","removeChild","appendChild","setAttributeNS","setAttribute","firstChild","attachShadow","mode","createCDATASection","createComment","buildNodeWithSN","afterAppend","assert","xmlns","write","childN","childNode","Map","onVisit","idNodeMap","key","visit","visitedNode","name_2","handleScroll","maskAllInputs","slimDOM","color","date","email","month","number","range","search","tel","time","week","textarea","select","password","walk","current"],"mappings":"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"}