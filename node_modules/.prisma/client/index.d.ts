
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  id: string
  email: string
  emailVerified: Date | null
  passwordDigest: string | null
  phoneNumber: string
  phoneNumberVerified: Date | null
  timeZone: string | null
  role: UserRole
  bubbleId: string | null
  bubbleRole: string | null
  slackPostId: string | null
  autoReply: boolean | null
  isActive: boolean | null
  disabledReason: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Account
 * 
 */
export type Account = {
  id: string
  userId: string
  type: string
  provider: string
  providerAccountId: string
  refreshToken: string | null
  accessToken: string | null
  tokenType: string | null
  expiresAt: number | null
  scope: string | null
  idToken: string | null
  sessionState: string | null
  oauthTokenSecret: string | null
  oauthToken: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Profile
 * 
 */
export type Profile = {
  id: string
  userId: string
  firstName: string
  lastName: string | null
  birthDate: Date | null
  profileData: Prisma.JsonValue | null
  picture: string
  notifyEmail: boolean
  notifyPush: boolean
  notifyBadge: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Session
 * 
 */
export type Session = {
  id: string
  sid: string
  data: string
  expiresAt: Date
}

/**
 * Model Conversation
 * 
 */
export type Conversation = {
  id: string
  name: string
  botId: string | null
  userData: Prisma.JsonValue | null
  prompt: string
  userId: string
  isFlagged: boolean | null
  isFinished: boolean | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Message
 * 
 */
export type Message = {
  id: string
  conversationId: string
  input: string | null
  prompt: string
  gptResponse: string | null
  isGptFlagged: boolean | null
  gptModeration: string | null
  isManualResonse: boolean | null
  userResponse: string | null
  userModeration: string | null
  userAllowedByDefense: boolean | null
  isUserFlagged: boolean | null
  userData: Prisma.JsonValue | null
  isDeliveredToUser: Date | null
  smsSid: string | null
  shouldFinish: boolean | null
  tokenUsage: Prisma.JsonValue | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Bot
 * 
 */
export type Bot = {
  id: string
  name: string
  model: string
  initialPrompt: string
  summarizePrompt: string | null
  finisherPrompt: string | null
  temperature: Prisma.Decimal
  max_tokens: Prisma.Decimal
  top_p: Prisma.Decimal
  frequency_penalty: Prisma.Decimal
  presence_penalty: Prisma.Decimal
  best_of: Prisma.Decimal | null
  stopSequences: string[]
  createdAt: Date
  updatedAt: Date
}

/**
 * Model UserBots
 * 
 */
export type UserBots = {
  id: string
  userId: string
  botId: string
  botSeedData: string | null
  nextMessageHour: string | null
  isFinished: Date | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Tag
 * 
 */
export type Tag = {
  id: string
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Payer
 * 
 */
export type Payer = {
  id: string
  stripeCustomerId: string
  stripeSubscriptionId: string
  stripePriceId: string
  stripeCurrentPeriodEnd: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Product
 * 
 */
export type Product = {
  id: string
  active: boolean
  name: string
  description: string | null
  image: string | null
  metadata: Prisma.JsonValue | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Price
 * 
 */
export type Price = {
  id: string
  productId: string
  active: boolean
  currency: string
  interval: PriceInterval | null
  unitAmount: Prisma.Decimal | null
  intervalCount: number | null
  trialPeriodDays: number | null
  type: PriceType | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Subscription
 * 
 */
export type Subscription = {
  id: string
  userId: string
  priceId: string | null
  status: SubscriptionStatus
  startDate: Date | null
  endedAt: Date | null
  trialEnd: Date | null
  trialStart: Date | null
  cancelAt: Date | null
  cancelAtPeriodEnd: boolean | null
  canceledAt: Date | null
  metadata: Prisma.JsonValue | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model AppIntegration
 * 
 */
export type AppIntegration = {
  id: string
  name: string
  clientId: string
  clientKey: string
  isEnable: boolean
  expiresAt: Date
  createdAt: Date
  updatedAt: Date
}

/**
 * Model AppConfiguration
 * 
 */
export type AppConfiguration = {
  id: string
  name: string
  value: string
  isActive: boolean
  createdAt: Date
  updatedAt: Date
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const UserRole: {
  USER: 'USER',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const PriceInterval: {
  day: 'day',
  month: 'month',
  week: 'week',
  year: 'year'
};

export type PriceInterval = (typeof PriceInterval)[keyof typeof PriceInterval]


export const PriceType: {
  recurring: 'recurring',
  one_time: 'one_time'
};

export type PriceType = (typeof PriceType)[keyof typeof PriceType]


export const SubscriptionStatus: {
  active: 'active',
  canceled: 'canceled',
  incomplete: 'incomplete',
  incomplete_expired: 'incomplete_expired',
  past_due: 'past_due',
  trialing: 'trialing',
  unpaid: 'unpaid'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;


      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<GlobalReject>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<GlobalReject>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<GlobalReject>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<GlobalReject>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<GlobalReject>;

  /**
   * `prisma.bot`: Exposes CRUD operations for the **Bot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bots
    * const bots = await prisma.bot.findMany()
    * ```
    */
  get bot(): Prisma.BotDelegate<GlobalReject>;

  /**
   * `prisma.userBots`: Exposes CRUD operations for the **UserBots** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBots
    * const userBots = await prisma.userBots.findMany()
    * ```
    */
  get userBots(): Prisma.UserBotsDelegate<GlobalReject>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<GlobalReject>;

  /**
   * `prisma.payer`: Exposes CRUD operations for the **Payer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payers
    * const payers = await prisma.payer.findMany()
    * ```
    */
  get payer(): Prisma.PayerDelegate<GlobalReject>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<GlobalReject>;

  /**
   * `prisma.price`: Exposes CRUD operations for the **Price** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prices
    * const prices = await prisma.price.findMany()
    * ```
    */
  get price(): Prisma.PriceDelegate<GlobalReject>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<GlobalReject>;

  /**
   * `prisma.appIntegration`: Exposes CRUD operations for the **AppIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppIntegrations
    * const appIntegrations = await prisma.appIntegration.findMany()
    * ```
    */
  get appIntegration(): Prisma.AppIntegrationDelegate<GlobalReject>;

  /**
   * `prisma.appConfiguration`: Exposes CRUD operations for the **AppConfiguration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppConfigurations
    * const appConfigurations = await prisma.appConfiguration.findMany()
    * ```
    */
  get appConfiguration(): Prisma.AppConfigurationDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.6.0
   * Query Engine version: dc520b92b1ebb2d28dc3161f9f82e875bd35d727
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Profile: 'Profile',
    Session: 'Session',
    Conversation: 'Conversation',
    Message: 'Message',
    Bot: 'Bot',
    UserBots: 'UserBots',
    Tag: 'Tag',
    Payer: 'Payer',
    Product: 'Product',
    Price: 'Price',
    Subscription: 'Subscription',
    AppIntegration: 'AppIntegration',
    AppConfiguration: 'AppConfiguration'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    accounts: number
    subscriptions: number
    payer: number
    userBots: number
    conversation: number
  }

  export type UserCountOutputTypeSelect = {
    accounts?: boolean
    subscriptions?: boolean
    payer?: boolean
    userBots?: boolean
    conversation?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserCountOutputType ?UserCountOutputType [P]
  : 
     never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type ConversationCountOutputType
   */


  export type ConversationCountOutputType = {
    messages: number
  }

  export type ConversationCountOutputTypeSelect = {
    messages?: boolean
  }

  export type ConversationCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ConversationCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ConversationCountOutputType
    : S extends undefined
    ? never
    : S extends ConversationCountOutputTypeArgs
    ?'include' extends U
    ? ConversationCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ConversationCountOutputType ?ConversationCountOutputType [P]
  : 
     never
  } 
    : ConversationCountOutputType
  : ConversationCountOutputType




  // Custom InputTypes

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     * 
    **/
    select?: ConversationCountOutputTypeSelect | null
  }



  /**
   * Count Type BotCountOutputType
   */


  export type BotCountOutputType = {
    conversations: number
    userBots: number
  }

  export type BotCountOutputTypeSelect = {
    conversations?: boolean
    userBots?: boolean
  }

  export type BotCountOutputTypeGetPayload<
    S extends boolean | null | undefined | BotCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? BotCountOutputType
    : S extends undefined
    ? never
    : S extends BotCountOutputTypeArgs
    ?'include' extends U
    ? BotCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof BotCountOutputType ?BotCountOutputType [P]
  : 
     never
  } 
    : BotCountOutputType
  : BotCountOutputType




  // Custom InputTypes

  /**
   * BotCountOutputType without action
   */
  export type BotCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BotCountOutputType
     * 
    **/
    select?: BotCountOutputTypeSelect | null
  }



  /**
   * Count Type PayerCountOutputType
   */


  export type PayerCountOutputType = {
    users: number
  }

  export type PayerCountOutputTypeSelect = {
    users?: boolean
  }

  export type PayerCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PayerCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PayerCountOutputType
    : S extends undefined
    ? never
    : S extends PayerCountOutputTypeArgs
    ?'include' extends U
    ? PayerCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PayerCountOutputType ?PayerCountOutputType [P]
  : 
     never
  } 
    : PayerCountOutputType
  : PayerCountOutputType




  // Custom InputTypes

  /**
   * PayerCountOutputType without action
   */
  export type PayerCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PayerCountOutputType
     * 
    **/
    select?: PayerCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductCountOutputType
   */


  export type ProductCountOutputType = {
    prices: number
  }

  export type ProductCountOutputTypeSelect = {
    prices?: boolean
  }

  export type ProductCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductCountOutputType
    : S extends undefined
    ? never
    : S extends ProductCountOutputTypeArgs
    ?'include' extends U
    ? ProductCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductCountOutputType ?ProductCountOutputType [P]
  : 
     never
  } 
    : ProductCountOutputType
  : ProductCountOutputType




  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     * 
    **/
    select?: ProductCountOutputTypeSelect | null
  }



  /**
   * Count Type PriceCountOutputType
   */


  export type PriceCountOutputType = {
    subscriptions: number
  }

  export type PriceCountOutputTypeSelect = {
    subscriptions?: boolean
  }

  export type PriceCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PriceCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PriceCountOutputType
    : S extends undefined
    ? never
    : S extends PriceCountOutputTypeArgs
    ?'include' extends U
    ? PriceCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PriceCountOutputType ?PriceCountOutputType [P]
  : 
     never
  } 
    : PriceCountOutputType
  : PriceCountOutputType




  // Custom InputTypes

  /**
   * PriceCountOutputType without action
   */
  export type PriceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PriceCountOutputType
     * 
    **/
    select?: PriceCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: Date | null
    passwordDigest: string | null
    phoneNumber: string | null
    phoneNumberVerified: Date | null
    timeZone: string | null
    role: UserRole | null
    bubbleId: string | null
    bubbleRole: string | null
    slackPostId: string | null
    autoReply: boolean | null
    isActive: boolean | null
    disabledReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: Date | null
    passwordDigest: string | null
    phoneNumber: string | null
    phoneNumberVerified: Date | null
    timeZone: string | null
    role: UserRole | null
    bubbleId: string | null
    bubbleRole: string | null
    slackPostId: string | null
    autoReply: boolean | null
    isActive: boolean | null
    disabledReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    emailVerified: number
    passwordDigest: number
    phoneNumber: number
    phoneNumberVerified: number
    timeZone: number
    role: number
    bubbleId: number
    bubbleRole: number
    slackPostId: number
    autoReply: number
    isActive: number
    disabledReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    passwordDigest?: true
    phoneNumber?: true
    phoneNumberVerified?: true
    timeZone?: true
    role?: true
    bubbleId?: true
    bubbleRole?: true
    slackPostId?: true
    autoReply?: true
    isActive?: true
    disabledReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    passwordDigest?: true
    phoneNumber?: true
    phoneNumberVerified?: true
    timeZone?: true
    role?: true
    bubbleId?: true
    bubbleRole?: true
    slackPostId?: true
    autoReply?: true
    isActive?: true
    disabledReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    passwordDigest?: true
    phoneNumber?: true
    phoneNumberVerified?: true
    timeZone?: true
    role?: true
    bubbleId?: true
    bubbleRole?: true
    slackPostId?: true
    autoReply?: true
    isActive?: true
    disabledReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    email: string
    emailVerified: Date | null
    passwordDigest: string | null
    phoneNumber: string
    phoneNumberVerified: Date | null
    timeZone: string | null
    role: UserRole
    bubbleId: string | null
    bubbleRole: string | null
    slackPostId: string | null
    autoReply: boolean | null
    isActive: boolean | null
    disabledReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Promise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    passwordDigest?: boolean
    phoneNumber?: boolean
    phoneNumberVerified?: boolean
    timeZone?: boolean
    accounts?: boolean | AccountFindManyArgs
    subscriptions?: boolean | SubscriptionFindManyArgs
    role?: boolean
    profile?: boolean | ProfileArgs
    payer?: boolean | PayerFindManyArgs
    userBots?: boolean | UserBotsFindManyArgs
    bubbleId?: boolean
    bubbleRole?: boolean
    slackPostId?: boolean
    autoReply?: boolean
    isActive?: boolean
    disabledReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversation?: boolean | ConversationFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    accounts?: boolean | AccountFindManyArgs
    subscriptions?: boolean | SubscriptionFindManyArgs
    profile?: boolean | ProfileArgs
    payer?: boolean | PayerFindManyArgs
    userBots?: boolean | UserBotsFindManyArgs
    conversation?: boolean | ConversationFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'accounts'
        ? Array < AccountGetPayload<S['include'][P]>>  :
        P extends 'subscriptions'
        ? Array < SubscriptionGetPayload<S['include'][P]>>  :
        P extends 'profile'
        ? ProfileGetPayload<S['include'][P]> | null :
        P extends 'payer'
        ? Array < PayerGetPayload<S['include'][P]>>  :
        P extends 'userBots'
        ? Array < UserBotsGetPayload<S['include'][P]>>  :
        P extends 'conversation'
        ? Array < ConversationGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? UserCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User ?User [P]
  : 
          P extends 'accounts'
        ? Array < AccountGetPayload<S['select'][P]>>  :
        P extends 'subscriptions'
        ? Array < SubscriptionGetPayload<S['select'][P]>>  :
        P extends 'profile'
        ? ProfileGetPayload<S['select'][P]> | null :
        P extends 'payer'
        ? Array < PayerGetPayload<S['select'][P]>>  :
        P extends 'userBots'
        ? Array < UserBotsGetPayload<S['select'][P]>>  :
        P extends 'conversation'
        ? Array < ConversationGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? UserCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    accounts<T extends AccountFindManyArgs = {}>(args?: Subset<T, AccountFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Account>>, PrismaPromise<Array<AccountGetPayload<T>>>>;

    subscriptions<T extends SubscriptionFindManyArgs = {}>(args?: Subset<T, SubscriptionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Subscription>>, PrismaPromise<Array<SubscriptionGetPayload<T>>>>;

    profile<T extends ProfileArgs = {}>(args?: Subset<T, ProfileArgs>): CheckSelect<T, Prisma__ProfileClient<Profile | null >, Prisma__ProfileClient<ProfileGetPayload<T> | null >>;

    payer<T extends PayerFindManyArgs = {}>(args?: Subset<T, PayerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Payer>>, PrismaPromise<Array<PayerGetPayload<T>>>>;

    userBots<T extends UserBotsFindManyArgs = {}>(args?: Subset<T, UserBotsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserBots>>, PrismaPromise<Array<UserBotsGetPayload<T>>>>;

    conversation<T extends ConversationFindManyArgs = {}>(args?: Subset<T, ConversationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Conversation>>, PrismaPromise<Array<ConversationGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model Account
   */


  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expiresAt: number | null
  }

  export type AccountSumAggregateOutputType = {
    expiresAt: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refreshToken: string | null
    accessToken: string | null
    tokenType: string | null
    expiresAt: number | null
    scope: string | null
    idToken: string | null
    sessionState: string | null
    oauthTokenSecret: string | null
    oauthToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refreshToken: string | null
    accessToken: string | null
    tokenType: string | null
    expiresAt: number | null
    scope: string | null
    idToken: string | null
    sessionState: string | null
    oauthTokenSecret: string | null
    oauthToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refreshToken: number
    accessToken: number
    tokenType: number
    expiresAt: number
    scope: number
    idToken: number
    sessionState: number
    oauthTokenSecret: number
    oauthToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expiresAt?: true
  }

  export type AccountSumAggregateInputType = {
    expiresAt?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    tokenType?: true
    expiresAt?: true
    scope?: true
    idToken?: true
    sessionState?: true
    oauthTokenSecret?: true
    oauthToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    tokenType?: true
    expiresAt?: true
    scope?: true
    idToken?: true
    sessionState?: true
    oauthTokenSecret?: true
    oauthToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    tokenType?: true
    expiresAt?: true
    scope?: true
    idToken?: true
    sessionState?: true
    oauthTokenSecret?: true
    oauthToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs = {
    /**
     * Filter which Account to aggregate.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs = {
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithAggregationInput>
    by: Array<AccountScalarFieldEnum>
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }


  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refreshToken: string | null
    accessToken: string | null
    tokenType: string | null
    expiresAt: number | null
    scope: string | null
    idToken: string | null
    sessionState: string | null
    oauthTokenSecret: string | null
    oauthToken: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Promise<
    Array<
      PickArray<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    tokenType?: boolean
    expiresAt?: boolean
    scope?: boolean
    idToken?: boolean
    sessionState?: boolean
    oauthTokenSecret?: boolean
    oauthToken?: boolean
    user?: boolean | UserArgs
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountInclude = {
    user?: boolean | UserArgs
  }

  export type AccountGetPayload<
    S extends boolean | null | undefined | AccountArgs,
    U = keyof S
      > = S extends true
        ? Account
    : S extends undefined
    ? never
    : S extends AccountArgs | AccountFindManyArgs
    ?'include' extends U
    ? Account  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Account ?Account [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Account
  : Account


  type AccountCountArgs = Merge<
    Omit<AccountFindManyArgs, 'select' | 'include'> & {
      select?: AccountCountAggregateInputType | true
    }
  >

  export interface AccountDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Account'> extends True ? CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>> : CheckSelect<T, Prisma__AccountClient<Account | null >, Prisma__AccountClient<AccountGetPayload<T> | null >>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Account'> extends True ? CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>> : CheckSelect<T, Prisma__AccountClient<Account | null >, Prisma__AccountClient<AccountGetPayload<T> | null >>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs>(
      args?: SelectSubset<T, AccountFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Account>>, PrismaPromise<Array<AccountGetPayload<T>>>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs>(
      args: SelectSubset<T, AccountCreateArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs>(
      args?: SelectSubset<T, AccountCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs>(
      args: SelectSubset<T, AccountDeleteArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs>(
      args: SelectSubset<T, AccountUpdateArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs>(
      args?: SelectSubset<T, AccountDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs>(
      args: SelectSubset<T, AccountUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs>(
      args: SelectSubset<T, AccountUpsertArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Throw an Error if a Account can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Account to fetch.
     * 
    **/
    where: AccountWhereUniqueInput
  }


  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Throw an Error if a Account can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Account to fetch.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     * 
    **/
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account findMany
   */
  export type AccountFindManyArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter, which Accounts to fetch.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account create
   */
  export type AccountCreateArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The data needed to create a Account.
     * 
    **/
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs = {
    data: Enumerable<AccountCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The data needed to update a Account.
     * 
    **/
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     * 
    **/
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs = {
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The filter to search for the Account to update in case it exists.
     * 
    **/
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     * 
    **/
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter which Account to delete.
     * 
    **/
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs = {
    where?: AccountWhereInput
  }


  /**
   * Account without action
   */
  export type AccountArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
  }



  /**
   * Model Profile
   */


  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    birthDate: Date | null
    picture: string | null
    notifyEmail: boolean | null
    notifyPush: boolean | null
    notifyBadge: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    birthDate: Date | null
    picture: string | null
    notifyEmail: boolean | null
    notifyPush: boolean | null
    notifyBadge: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    birthDate: number
    profileData: number
    picture: number
    notifyEmail: number
    notifyPush: number
    notifyBadge: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    birthDate?: true
    picture?: true
    notifyEmail?: true
    notifyPush?: true
    notifyBadge?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    birthDate?: true
    picture?: true
    notifyEmail?: true
    notifyPush?: true
    notifyBadge?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    birthDate?: true
    profileData?: true
    picture?: true
    notifyEmail?: true
    notifyPush?: true
    notifyBadge?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileAggregateArgs = {
    /**
     * Filter which Profile to aggregate.
     * 
    **/
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<ProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs = {
    where?: ProfileWhereInput
    orderBy?: Enumerable<ProfileOrderByWithAggregationInput>
    by: Array<ProfileScalarFieldEnum>
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }


  export type ProfileGroupByOutputType = {
    id: string
    userId: string
    firstName: string
    lastName: string | null
    birthDate: Date | null
    profileData: JsonValue | null
    picture: string
    notifyEmail: boolean
    notifyPush: boolean
    notifyBadge: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Promise<
    Array<
      PickArray<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect = {
    id?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    birthDate?: boolean
    profileData?: boolean
    picture?: boolean
    notifyEmail?: boolean
    notifyPush?: boolean
    notifyBadge?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileInclude = {
    user?: boolean | UserArgs
  }

  export type ProfileGetPayload<
    S extends boolean | null | undefined | ProfileArgs,
    U = keyof S
      > = S extends true
        ? Profile
    : S extends undefined
    ? never
    : S extends ProfileArgs | ProfileFindManyArgs
    ?'include' extends U
    ? Profile  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Profile ?Profile [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Profile
  : Profile


  type ProfileCountArgs = Merge<
    Omit<ProfileFindManyArgs, 'select' | 'include'> & {
      select?: ProfileCountAggregateInputType | true
    }
  >

  export interface ProfileDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProfileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProfileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Profile'> extends True ? CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>> : CheckSelect<T, Prisma__ProfileClient<Profile | null >, Prisma__ProfileClient<ProfileGetPayload<T> | null >>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProfileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProfileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Profile'> extends True ? CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>> : CheckSelect<T, Prisma__ProfileClient<Profile | null >, Prisma__ProfileClient<ProfileGetPayload<T> | null >>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProfileFindManyArgs>(
      args?: SelectSubset<T, ProfileFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Profile>>, PrismaPromise<Array<ProfileGetPayload<T>>>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
    **/
    create<T extends ProfileCreateArgs>(
      args: SelectSubset<T, ProfileCreateArgs>
    ): CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>>

    /**
     * Create many Profiles.
     *     @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     *     @example
     *     // Create many Profiles
     *     const profile = await prisma.profile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProfileCreateManyArgs>(
      args?: SelectSubset<T, ProfileCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
    **/
    delete<T extends ProfileDeleteArgs>(
      args: SelectSubset<T, ProfileDeleteArgs>
    ): CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProfileUpdateArgs>(
      args: SelectSubset<T, ProfileUpdateArgs>
    ): CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProfileDeleteManyArgs>(
      args?: SelectSubset<T, ProfileDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProfileUpdateManyArgs>(
      args: SelectSubset<T, ProfileUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
    **/
    upsert<T extends ProfileUpsertArgs>(
      args: SelectSubset<T, ProfileUpsertArgs>
    ): CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>>

    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProfileClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * Throw an Error if a Profile can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Profile to fetch.
     * 
    **/
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * Throw an Error if a Profile can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Profile to fetch.
     * 
    **/
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<ProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     * 
    **/
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     * 
    **/
    distinct?: Enumerable<ProfileScalarFieldEnum>
  }


  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * Filter, which Profiles to fetch.
     * 
    **/
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<ProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     * 
    **/
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProfileScalarFieldEnum>
  }


  /**
   * Profile create
   */
  export type ProfileCreateArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * The data needed to create a Profile.
     * 
    **/
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }


  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs = {
    data: Enumerable<ProfileCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Profile update
   */
  export type ProfileUpdateArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * The data needed to update a Profile.
     * 
    **/
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     * 
    **/
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs = {
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    where?: ProfileWhereInput
  }


  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * The filter to search for the Profile to update in case it exists.
     * 
    **/
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     * 
    **/
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }


  /**
   * Profile delete
   */
  export type ProfileDeleteArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * Filter which Profile to delete.
     * 
    **/
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs = {
    where?: ProfileWhereInput
  }


  /**
   * Profile without action
   */
  export type ProfileArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
  }



  /**
   * Model Session
   */


  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sid: string | null
    data: string | null
    expiresAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sid: string | null
    data: string | null
    expiresAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sid: number
    data: number
    expiresAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sid?: true
    data?: true
    expiresAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sid?: true
    data?: true
    expiresAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sid?: true
    data?: true
    expiresAt?: true
    _all?: true
  }

  export type SessionAggregateArgs = {
    /**
     * Filter which Session to aggregate.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs = {
    where?: SessionWhereInput
    orderBy?: Enumerable<SessionOrderByWithAggregationInput>
    by: Array<SessionScalarFieldEnum>
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }


  export type SessionGroupByOutputType = {
    id: string
    sid: string
    data: string
    expiresAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Promise<
    Array<
      PickArray<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect = {
    id?: boolean
    sid?: boolean
    data?: boolean
    expiresAt?: boolean
  }

  export type SessionGetPayload<
    S extends boolean | null | undefined | SessionArgs,
    U = keyof S
      > = S extends true
        ? Session
    : S extends undefined
    ? never
    : S extends SessionArgs | SessionFindManyArgs
    ?'include' extends U
    ? Session 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Session ?Session [P]
  : 
     never
  } 
    : Session
  : Session


  type SessionCountArgs = Merge<
    Omit<SessionFindManyArgs, 'select' | 'include'> & {
      select?: SessionCountAggregateInputType | true
    }
  >

  export interface SessionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SessionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SessionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Session'> extends True ? CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>> : CheckSelect<T, Prisma__SessionClient<Session | null >, Prisma__SessionClient<SessionGetPayload<T> | null >>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SessionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SessionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Session'> extends True ? CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>> : CheckSelect<T, Prisma__SessionClient<Session | null >, Prisma__SessionClient<SessionGetPayload<T> | null >>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SessionFindManyArgs>(
      args?: SelectSubset<T, SessionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Session>>, PrismaPromise<Array<SessionGetPayload<T>>>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
    **/
    create<T extends SessionCreateArgs>(
      args: SelectSubset<T, SessionCreateArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Create many Sessions.
     *     @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const session = await prisma.session.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SessionCreateManyArgs>(
      args?: SelectSubset<T, SessionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
    **/
    delete<T extends SessionDeleteArgs>(
      args: SelectSubset<T, SessionDeleteArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SessionUpdateArgs>(
      args: SelectSubset<T, SessionUpdateArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SessionDeleteManyArgs>(
      args?: SelectSubset<T, SessionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SessionUpdateManyArgs>(
      args: SelectSubset<T, SessionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
    **/
    upsert<T extends SessionUpsertArgs>(
      args: SelectSubset<T, SessionUpsertArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SessionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Throw an Error if a Session can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Session to fetch.
     * 
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Throw an Error if a Session can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Session to fetch.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     * 
    **/
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session findMany
   */
  export type SessionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Filter, which Sessions to fetch.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session create
   */
  export type SessionCreateArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * The data needed to create a Session.
     * 
    **/
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }


  /**
   * Session createMany
   */
  export type SessionCreateManyArgs = {
    data: Enumerable<SessionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Session update
   */
  export type SessionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * The data needed to update a Session.
     * 
    **/
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     * 
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs = {
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    where?: SessionWhereInput
  }


  /**
   * Session upsert
   */
  export type SessionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * The filter to search for the Session to update in case it exists.
     * 
    **/
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     * 
    **/
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }


  /**
   * Session delete
   */
  export type SessionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Filter which Session to delete.
     * 
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs = {
    where?: SessionWhereInput
  }


  /**
   * Session without action
   */
  export type SessionArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
  }



  /**
   * Model Conversation
   */


  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    name: string | null
    botId: string | null
    prompt: string | null
    userId: string | null
    isFlagged: boolean | null
    isFinished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    botId: string | null
    prompt: string | null
    userId: string | null
    isFlagged: boolean | null
    isFinished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    name: number
    botId: number
    userData: number
    prompt: number
    userId: number
    isFlagged: number
    isFinished: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    name?: true
    botId?: true
    prompt?: true
    userId?: true
    isFlagged?: true
    isFinished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    name?: true
    botId?: true
    prompt?: true
    userId?: true
    isFlagged?: true
    isFinished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    name?: true
    botId?: true
    userData?: true
    prompt?: true
    userId?: true
    isFlagged?: true
    isFinished?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs = {
    /**
     * Filter which Conversation to aggregate.
     * 
    **/
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     * 
    **/
    orderBy?: Enumerable<ConversationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs = {
    where?: ConversationWhereInput
    orderBy?: Enumerable<ConversationOrderByWithAggregationInput>
    by: Array<ConversationScalarFieldEnum>
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }


  export type ConversationGroupByOutputType = {
    id: string
    name: string
    botId: string | null
    userData: JsonValue | null
    prompt: string
    userId: string
    isFlagged: boolean | null
    isFinished: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Promise<
    Array<
      PickArray<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect = {
    id?: boolean
    name?: boolean
    bot?: boolean | BotArgs
    botId?: boolean
    messages?: boolean | MessageFindManyArgs
    userData?: boolean
    prompt?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    isFlagged?: boolean
    isFinished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | ConversationCountOutputTypeArgs
  }

  export type ConversationInclude = {
    bot?: boolean | BotArgs
    messages?: boolean | MessageFindManyArgs
    user?: boolean | UserArgs
    _count?: boolean | ConversationCountOutputTypeArgs
  }

  export type ConversationGetPayload<
    S extends boolean | null | undefined | ConversationArgs,
    U = keyof S
      > = S extends true
        ? Conversation
    : S extends undefined
    ? never
    : S extends ConversationArgs | ConversationFindManyArgs
    ?'include' extends U
    ? Conversation  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'bot'
        ? BotGetPayload<S['include'][P]> | null :
        P extends 'messages'
        ? Array < MessageGetPayload<S['include'][P]>>  :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends '_count'
        ? ConversationCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Conversation ?Conversation [P]
  : 
          P extends 'bot'
        ? BotGetPayload<S['select'][P]> | null :
        P extends 'messages'
        ? Array < MessageGetPayload<S['select'][P]>>  :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends '_count'
        ? ConversationCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Conversation
  : Conversation


  type ConversationCountArgs = Merge<
    Omit<ConversationFindManyArgs, 'select' | 'include'> & {
      select?: ConversationCountAggregateInputType | true
    }
  >

  export interface ConversationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConversationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ConversationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Conversation'> extends True ? CheckSelect<T, Prisma__ConversationClient<Conversation>, Prisma__ConversationClient<ConversationGetPayload<T>>> : CheckSelect<T, Prisma__ConversationClient<Conversation | null >, Prisma__ConversationClient<ConversationGetPayload<T> | null >>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConversationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ConversationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Conversation'> extends True ? CheckSelect<T, Prisma__ConversationClient<Conversation>, Prisma__ConversationClient<ConversationGetPayload<T>>> : CheckSelect<T, Prisma__ConversationClient<Conversation | null >, Prisma__ConversationClient<ConversationGetPayload<T> | null >>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConversationFindManyArgs>(
      args?: SelectSubset<T, ConversationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Conversation>>, PrismaPromise<Array<ConversationGetPayload<T>>>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
    **/
    create<T extends ConversationCreateArgs>(
      args: SelectSubset<T, ConversationCreateArgs>
    ): CheckSelect<T, Prisma__ConversationClient<Conversation>, Prisma__ConversationClient<ConversationGetPayload<T>>>

    /**
     * Create many Conversations.
     *     @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     *     @example
     *     // Create many Conversations
     *     const conversation = await prisma.conversation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConversationCreateManyArgs>(
      args?: SelectSubset<T, ConversationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
    **/
    delete<T extends ConversationDeleteArgs>(
      args: SelectSubset<T, ConversationDeleteArgs>
    ): CheckSelect<T, Prisma__ConversationClient<Conversation>, Prisma__ConversationClient<ConversationGetPayload<T>>>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConversationUpdateArgs>(
      args: SelectSubset<T, ConversationUpdateArgs>
    ): CheckSelect<T, Prisma__ConversationClient<Conversation>, Prisma__ConversationClient<ConversationGetPayload<T>>>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConversationDeleteManyArgs>(
      args?: SelectSubset<T, ConversationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConversationUpdateManyArgs>(
      args: SelectSubset<T, ConversationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
    **/
    upsert<T extends ConversationUpsertArgs>(
      args: SelectSubset<T, ConversationUpsertArgs>
    ): CheckSelect<T, Prisma__ConversationClient<Conversation>, Prisma__ConversationClient<ConversationGetPayload<T>>>

    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ConversationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    bot<T extends BotArgs = {}>(args?: Subset<T, BotArgs>): CheckSelect<T, Prisma__BotClient<Bot | null >, Prisma__BotClient<BotGetPayload<T> | null >>;

    messages<T extends MessageFindManyArgs = {}>(args?: Subset<T, MessageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Message>>, PrismaPromise<Array<MessageGetPayload<T>>>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Conversation
     * 
    **/
    select?: ConversationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationInclude | null
    /**
     * Throw an Error if a Conversation can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Conversation to fetch.
     * 
    **/
    where: ConversationWhereUniqueInput
  }


  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Conversation
     * 
    **/
    select?: ConversationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationInclude | null
    /**
     * Throw an Error if a Conversation can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Conversation to fetch.
     * 
    **/
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     * 
    **/
    orderBy?: Enumerable<ConversationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     * 
    **/
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     * 
    **/
    distinct?: Enumerable<ConversationScalarFieldEnum>
  }


  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Conversation
     * 
    **/
    select?: ConversationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationInclude | null
    /**
     * Filter, which Conversations to fetch.
     * 
    **/
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     * 
    **/
    orderBy?: Enumerable<ConversationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     * 
    **/
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ConversationScalarFieldEnum>
  }


  /**
   * Conversation create
   */
  export type ConversationCreateArgs = {
    /**
     * Select specific fields to fetch from the Conversation
     * 
    **/
    select?: ConversationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationInclude | null
    /**
     * The data needed to create a Conversation.
     * 
    **/
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }


  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs = {
    data: Enumerable<ConversationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Conversation update
   */
  export type ConversationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Conversation
     * 
    **/
    select?: ConversationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationInclude | null
    /**
     * The data needed to update a Conversation.
     * 
    **/
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     * 
    **/
    where: ConversationWhereUniqueInput
  }


  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs = {
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    where?: ConversationWhereInput
  }


  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Conversation
     * 
    **/
    select?: ConversationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationInclude | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     * 
    **/
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     * 
    **/
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }


  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Conversation
     * 
    **/
    select?: ConversationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationInclude | null
    /**
     * Filter which Conversation to delete.
     * 
    **/
    where: ConversationWhereUniqueInput
  }


  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs = {
    where?: ConversationWhereInput
  }


  /**
   * Conversation without action
   */
  export type ConversationArgs = {
    /**
     * Select specific fields to fetch from the Conversation
     * 
    **/
    select?: ConversationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationInclude | null
  }



  /**
   * Model Message
   */


  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    input: string | null
    prompt: string | null
    gptResponse: string | null
    isGptFlagged: boolean | null
    gptModeration: string | null
    isManualResonse: boolean | null
    userResponse: string | null
    userModeration: string | null
    userAllowedByDefense: boolean | null
    isUserFlagged: boolean | null
    isDeliveredToUser: Date | null
    smsSid: string | null
    shouldFinish: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    input: string | null
    prompt: string | null
    gptResponse: string | null
    isGptFlagged: boolean | null
    gptModeration: string | null
    isManualResonse: boolean | null
    userResponse: string | null
    userModeration: string | null
    userAllowedByDefense: boolean | null
    isUserFlagged: boolean | null
    isDeliveredToUser: Date | null
    smsSid: string | null
    shouldFinish: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    input: number
    prompt: number
    gptResponse: number
    isGptFlagged: number
    gptModeration: number
    isManualResonse: number
    userResponse: number
    userModeration: number
    userAllowedByDefense: number
    isUserFlagged: number
    userData: number
    isDeliveredToUser: number
    smsSid: number
    shouldFinish: number
    tokenUsage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    input?: true
    prompt?: true
    gptResponse?: true
    isGptFlagged?: true
    gptModeration?: true
    isManualResonse?: true
    userResponse?: true
    userModeration?: true
    userAllowedByDefense?: true
    isUserFlagged?: true
    isDeliveredToUser?: true
    smsSid?: true
    shouldFinish?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    input?: true
    prompt?: true
    gptResponse?: true
    isGptFlagged?: true
    gptModeration?: true
    isManualResonse?: true
    userResponse?: true
    userModeration?: true
    userAllowedByDefense?: true
    isUserFlagged?: true
    isDeliveredToUser?: true
    smsSid?: true
    shouldFinish?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    input?: true
    prompt?: true
    gptResponse?: true
    isGptFlagged?: true
    gptModeration?: true
    isManualResonse?: true
    userResponse?: true
    userModeration?: true
    userAllowedByDefense?: true
    isUserFlagged?: true
    userData?: true
    isDeliveredToUser?: true
    smsSid?: true
    shouldFinish?: true
    tokenUsage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs = {
    /**
     * Filter which Message to aggregate.
     * 
    **/
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     * 
    **/
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs = {
    where?: MessageWhereInput
    orderBy?: Enumerable<MessageOrderByWithAggregationInput>
    by: Array<MessageScalarFieldEnum>
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }


  export type MessageGroupByOutputType = {
    id: string
    conversationId: string
    input: string | null
    prompt: string
    gptResponse: string | null
    isGptFlagged: boolean | null
    gptModeration: string | null
    isManualResonse: boolean | null
    userResponse: string | null
    userModeration: string | null
    userAllowedByDefense: boolean | null
    isUserFlagged: boolean | null
    userData: JsonValue | null
    isDeliveredToUser: Date | null
    smsSid: string | null
    shouldFinish: boolean | null
    tokenUsage: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Promise<
    Array<
      PickArray<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect = {
    id?: boolean
    conversation?: boolean | ConversationArgs
    conversationId?: boolean
    input?: boolean
    prompt?: boolean
    gptResponse?: boolean
    isGptFlagged?: boolean
    gptModeration?: boolean
    isManualResonse?: boolean
    userResponse?: boolean
    userModeration?: boolean
    userAllowedByDefense?: boolean
    isUserFlagged?: boolean
    userData?: boolean
    isDeliveredToUser?: boolean
    smsSid?: boolean
    shouldFinish?: boolean
    tokenUsage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageInclude = {
    conversation?: boolean | ConversationArgs
  }

  export type MessageGetPayload<
    S extends boolean | null | undefined | MessageArgs,
    U = keyof S
      > = S extends true
        ? Message
    : S extends undefined
    ? never
    : S extends MessageArgs | MessageFindManyArgs
    ?'include' extends U
    ? Message  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'conversation'
        ? ConversationGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Message ?Message [P]
  : 
          P extends 'conversation'
        ? ConversationGetPayload<S['select'][P]> : never
  } 
    : Message
  : Message


  type MessageCountArgs = Merge<
    Omit<MessageFindManyArgs, 'select' | 'include'> & {
      select?: MessageCountAggregateInputType | true
    }
  >

  export interface MessageDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Message'> extends True ? CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>> : CheckSelect<T, Prisma__MessageClient<Message | null >, Prisma__MessageClient<MessageGetPayload<T> | null >>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Message'> extends True ? CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>> : CheckSelect<T, Prisma__MessageClient<Message | null >, Prisma__MessageClient<MessageGetPayload<T> | null >>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessageFindManyArgs>(
      args?: SelectSubset<T, MessageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Message>>, PrismaPromise<Array<MessageGetPayload<T>>>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
    **/
    create<T extends MessageCreateArgs>(
      args: SelectSubset<T, MessageCreateArgs>
    ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>

    /**
     * Create many Messages.
     *     @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     *     @example
     *     // Create many Messages
     *     const message = await prisma.message.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessageCreateManyArgs>(
      args?: SelectSubset<T, MessageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
    **/
    delete<T extends MessageDeleteArgs>(
      args: SelectSubset<T, MessageDeleteArgs>
    ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageUpdateArgs>(
      args: SelectSubset<T, MessageUpdateArgs>
    ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageDeleteManyArgs>(
      args?: SelectSubset<T, MessageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageUpdateManyArgs>(
      args: SelectSubset<T, MessageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
    **/
    upsert<T extends MessageUpsertArgs>(
      args: SelectSubset<T, MessageUpsertArgs>
    ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MessageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    conversation<T extends ConversationArgs = {}>(args?: Subset<T, ConversationArgs>): CheckSelect<T, Prisma__ConversationClient<Conversation | null >, Prisma__ConversationClient<ConversationGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * Throw an Error if a Message can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Message to fetch.
     * 
    **/
    where: MessageWhereUniqueInput
  }


  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * Throw an Error if a Message can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Message to fetch.
     * 
    **/
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     * 
    **/
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     * 
    **/
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     * 
    **/
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * Message findMany
   */
  export type MessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * Filter, which Messages to fetch.
     * 
    **/
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     * 
    **/
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     * 
    **/
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * Message create
   */
  export type MessageCreateArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * The data needed to create a Message.
     * 
    **/
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }


  /**
   * Message createMany
   */
  export type MessageCreateManyArgs = {
    data: Enumerable<MessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Message update
   */
  export type MessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * The data needed to update a Message.
     * 
    **/
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     * 
    **/
    where: MessageWhereUniqueInput
  }


  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs = {
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    where?: MessageWhereInput
  }


  /**
   * Message upsert
   */
  export type MessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * The filter to search for the Message to update in case it exists.
     * 
    **/
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     * 
    **/
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }


  /**
   * Message delete
   */
  export type MessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * Filter which Message to delete.
     * 
    **/
    where: MessageWhereUniqueInput
  }


  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs = {
    where?: MessageWhereInput
  }


  /**
   * Message without action
   */
  export type MessageArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
  }



  /**
   * Model Bot
   */


  export type AggregateBot = {
    _count: BotCountAggregateOutputType | null
    _avg: BotAvgAggregateOutputType | null
    _sum: BotSumAggregateOutputType | null
    _min: BotMinAggregateOutputType | null
    _max: BotMaxAggregateOutputType | null
  }

  export type BotAvgAggregateOutputType = {
    temperature: Decimal | null
    max_tokens: Decimal | null
    top_p: Decimal | null
    frequency_penalty: Decimal | null
    presence_penalty: Decimal | null
    best_of: Decimal | null
  }

  export type BotSumAggregateOutputType = {
    temperature: Decimal | null
    max_tokens: Decimal | null
    top_p: Decimal | null
    frequency_penalty: Decimal | null
    presence_penalty: Decimal | null
    best_of: Decimal | null
  }

  export type BotMinAggregateOutputType = {
    id: string | null
    name: string | null
    model: string | null
    initialPrompt: string | null
    summarizePrompt: string | null
    finisherPrompt: string | null
    temperature: Decimal | null
    max_tokens: Decimal | null
    top_p: Decimal | null
    frequency_penalty: Decimal | null
    presence_penalty: Decimal | null
    best_of: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BotMaxAggregateOutputType = {
    id: string | null
    name: string | null
    model: string | null
    initialPrompt: string | null
    summarizePrompt: string | null
    finisherPrompt: string | null
    temperature: Decimal | null
    max_tokens: Decimal | null
    top_p: Decimal | null
    frequency_penalty: Decimal | null
    presence_penalty: Decimal | null
    best_of: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BotCountAggregateOutputType = {
    id: number
    name: number
    model: number
    initialPrompt: number
    summarizePrompt: number
    finisherPrompt: number
    temperature: number
    max_tokens: number
    top_p: number
    frequency_penalty: number
    presence_penalty: number
    best_of: number
    stopSequences: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BotAvgAggregateInputType = {
    temperature?: true
    max_tokens?: true
    top_p?: true
    frequency_penalty?: true
    presence_penalty?: true
    best_of?: true
  }

  export type BotSumAggregateInputType = {
    temperature?: true
    max_tokens?: true
    top_p?: true
    frequency_penalty?: true
    presence_penalty?: true
    best_of?: true
  }

  export type BotMinAggregateInputType = {
    id?: true
    name?: true
    model?: true
    initialPrompt?: true
    summarizePrompt?: true
    finisherPrompt?: true
    temperature?: true
    max_tokens?: true
    top_p?: true
    frequency_penalty?: true
    presence_penalty?: true
    best_of?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BotMaxAggregateInputType = {
    id?: true
    name?: true
    model?: true
    initialPrompt?: true
    summarizePrompt?: true
    finisherPrompt?: true
    temperature?: true
    max_tokens?: true
    top_p?: true
    frequency_penalty?: true
    presence_penalty?: true
    best_of?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BotCountAggregateInputType = {
    id?: true
    name?: true
    model?: true
    initialPrompt?: true
    summarizePrompt?: true
    finisherPrompt?: true
    temperature?: true
    max_tokens?: true
    top_p?: true
    frequency_penalty?: true
    presence_penalty?: true
    best_of?: true
    stopSequences?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BotAggregateArgs = {
    /**
     * Filter which Bot to aggregate.
     * 
    **/
    where?: BotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bots to fetch.
     * 
    **/
    orderBy?: Enumerable<BotOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: BotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bots from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bots.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bots
    **/
    _count?: true | BotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BotMaxAggregateInputType
  }

  export type GetBotAggregateType<T extends BotAggregateArgs> = {
        [P in keyof T & keyof AggregateBot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBot[P]>
      : GetScalarType<T[P], AggregateBot[P]>
  }




  export type BotGroupByArgs = {
    where?: BotWhereInput
    orderBy?: Enumerable<BotOrderByWithAggregationInput>
    by: Array<BotScalarFieldEnum>
    having?: BotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BotCountAggregateInputType | true
    _avg?: BotAvgAggregateInputType
    _sum?: BotSumAggregateInputType
    _min?: BotMinAggregateInputType
    _max?: BotMaxAggregateInputType
  }


  export type BotGroupByOutputType = {
    id: string
    name: string
    model: string
    initialPrompt: string
    summarizePrompt: string | null
    finisherPrompt: string | null
    temperature: Decimal
    max_tokens: Decimal
    top_p: Decimal
    frequency_penalty: Decimal
    presence_penalty: Decimal
    best_of: Decimal | null
    stopSequences: string[]
    createdAt: Date
    updatedAt: Date
    _count: BotCountAggregateOutputType | null
    _avg: BotAvgAggregateOutputType | null
    _sum: BotSumAggregateOutputType | null
    _min: BotMinAggregateOutputType | null
    _max: BotMaxAggregateOutputType | null
  }

  type GetBotGroupByPayload<T extends BotGroupByArgs> = Promise<
    Array<
      PickArray<BotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BotGroupByOutputType[P]>
            : GetScalarType<T[P], BotGroupByOutputType[P]>
        }
      >
    >


  export type BotSelect = {
    id?: boolean
    name?: boolean
    model?: boolean
    initialPrompt?: boolean
    summarizePrompt?: boolean
    finisherPrompt?: boolean
    temperature?: boolean
    max_tokens?: boolean
    top_p?: boolean
    frequency_penalty?: boolean
    presence_penalty?: boolean
    best_of?: boolean
    stopSequences?: boolean
    conversations?: boolean | ConversationFindManyArgs
    userBots?: boolean | UserBotsFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | BotCountOutputTypeArgs
  }

  export type BotInclude = {
    conversations?: boolean | ConversationFindManyArgs
    userBots?: boolean | UserBotsFindManyArgs
    _count?: boolean | BotCountOutputTypeArgs
  }

  export type BotGetPayload<
    S extends boolean | null | undefined | BotArgs,
    U = keyof S
      > = S extends true
        ? Bot
    : S extends undefined
    ? never
    : S extends BotArgs | BotFindManyArgs
    ?'include' extends U
    ? Bot  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'conversations'
        ? Array < ConversationGetPayload<S['include'][P]>>  :
        P extends 'userBots'
        ? Array < UserBotsGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? BotCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Bot ?Bot [P]
  : 
          P extends 'conversations'
        ? Array < ConversationGetPayload<S['select'][P]>>  :
        P extends 'userBots'
        ? Array < UserBotsGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? BotCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Bot
  : Bot


  type BotCountArgs = Merge<
    Omit<BotFindManyArgs, 'select' | 'include'> & {
      select?: BotCountAggregateInputType | true
    }
  >

  export interface BotDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Bot that matches the filter.
     * @param {BotFindUniqueArgs} args - Arguments to find a Bot
     * @example
     * // Get one Bot
     * const bot = await prisma.bot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BotFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BotFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Bot'> extends True ? CheckSelect<T, Prisma__BotClient<Bot>, Prisma__BotClient<BotGetPayload<T>>> : CheckSelect<T, Prisma__BotClient<Bot | null >, Prisma__BotClient<BotGetPayload<T> | null >>

    /**
     * Find the first Bot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotFindFirstArgs} args - Arguments to find a Bot
     * @example
     * // Get one Bot
     * const bot = await prisma.bot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BotFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BotFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Bot'> extends True ? CheckSelect<T, Prisma__BotClient<Bot>, Prisma__BotClient<BotGetPayload<T>>> : CheckSelect<T, Prisma__BotClient<Bot | null >, Prisma__BotClient<BotGetPayload<T> | null >>

    /**
     * Find zero or more Bots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bots
     * const bots = await prisma.bot.findMany()
     * 
     * // Get first 10 Bots
     * const bots = await prisma.bot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const botWithIdOnly = await prisma.bot.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BotFindManyArgs>(
      args?: SelectSubset<T, BotFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Bot>>, PrismaPromise<Array<BotGetPayload<T>>>>

    /**
     * Create a Bot.
     * @param {BotCreateArgs} args - Arguments to create a Bot.
     * @example
     * // Create one Bot
     * const Bot = await prisma.bot.create({
     *   data: {
     *     // ... data to create a Bot
     *   }
     * })
     * 
    **/
    create<T extends BotCreateArgs>(
      args: SelectSubset<T, BotCreateArgs>
    ): CheckSelect<T, Prisma__BotClient<Bot>, Prisma__BotClient<BotGetPayload<T>>>

    /**
     * Create many Bots.
     *     @param {BotCreateManyArgs} args - Arguments to create many Bots.
     *     @example
     *     // Create many Bots
     *     const bot = await prisma.bot.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BotCreateManyArgs>(
      args?: SelectSubset<T, BotCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Bot.
     * @param {BotDeleteArgs} args - Arguments to delete one Bot.
     * @example
     * // Delete one Bot
     * const Bot = await prisma.bot.delete({
     *   where: {
     *     // ... filter to delete one Bot
     *   }
     * })
     * 
    **/
    delete<T extends BotDeleteArgs>(
      args: SelectSubset<T, BotDeleteArgs>
    ): CheckSelect<T, Prisma__BotClient<Bot>, Prisma__BotClient<BotGetPayload<T>>>

    /**
     * Update one Bot.
     * @param {BotUpdateArgs} args - Arguments to update one Bot.
     * @example
     * // Update one Bot
     * const bot = await prisma.bot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BotUpdateArgs>(
      args: SelectSubset<T, BotUpdateArgs>
    ): CheckSelect<T, Prisma__BotClient<Bot>, Prisma__BotClient<BotGetPayload<T>>>

    /**
     * Delete zero or more Bots.
     * @param {BotDeleteManyArgs} args - Arguments to filter Bots to delete.
     * @example
     * // Delete a few Bots
     * const { count } = await prisma.bot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BotDeleteManyArgs>(
      args?: SelectSubset<T, BotDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bots
     * const bot = await prisma.bot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BotUpdateManyArgs>(
      args: SelectSubset<T, BotUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Bot.
     * @param {BotUpsertArgs} args - Arguments to update or create a Bot.
     * @example
     * // Update or create a Bot
     * const bot = await prisma.bot.upsert({
     *   create: {
     *     // ... data to create a Bot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bot we want to update
     *   }
     * })
    **/
    upsert<T extends BotUpsertArgs>(
      args: SelectSubset<T, BotUpsertArgs>
    ): CheckSelect<T, Prisma__BotClient<Bot>, Prisma__BotClient<BotGetPayload<T>>>

    /**
     * Count the number of Bots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotCountArgs} args - Arguments to filter Bots to count.
     * @example
     * // Count the number of Bots
     * const count = await prisma.bot.count({
     *   where: {
     *     // ... the filter for the Bots we want to count
     *   }
     * })
    **/
    count<T extends BotCountArgs>(
      args?: Subset<T, BotCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BotAggregateArgs>(args: Subset<T, BotAggregateArgs>): PrismaPromise<GetBotAggregateType<T>>

    /**
     * Group by Bot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BotGroupByArgs['orderBy'] }
        : { orderBy?: BotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBotGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BotClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    conversations<T extends ConversationFindManyArgs = {}>(args?: Subset<T, ConversationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Conversation>>, PrismaPromise<Array<ConversationGetPayload<T>>>>;

    userBots<T extends UserBotsFindManyArgs = {}>(args?: Subset<T, UserBotsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserBots>>, PrismaPromise<Array<UserBotsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Bot findUnique
   */
  export type BotFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Bot
     * 
    **/
    select?: BotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BotInclude | null
    /**
     * Throw an Error if a Bot can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Bot to fetch.
     * 
    **/
    where: BotWhereUniqueInput
  }


  /**
   * Bot findFirst
   */
  export type BotFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Bot
     * 
    **/
    select?: BotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BotInclude | null
    /**
     * Throw an Error if a Bot can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Bot to fetch.
     * 
    **/
    where?: BotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bots to fetch.
     * 
    **/
    orderBy?: Enumerable<BotOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bots.
     * 
    **/
    cursor?: BotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bots from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bots.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bots.
     * 
    **/
    distinct?: Enumerable<BotScalarFieldEnum>
  }


  /**
   * Bot findMany
   */
  export type BotFindManyArgs = {
    /**
     * Select specific fields to fetch from the Bot
     * 
    **/
    select?: BotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BotInclude | null
    /**
     * Filter, which Bots to fetch.
     * 
    **/
    where?: BotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bots to fetch.
     * 
    **/
    orderBy?: Enumerable<BotOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bots.
     * 
    **/
    cursor?: BotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bots from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bots.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BotScalarFieldEnum>
  }


  /**
   * Bot create
   */
  export type BotCreateArgs = {
    /**
     * Select specific fields to fetch from the Bot
     * 
    **/
    select?: BotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BotInclude | null
    /**
     * The data needed to create a Bot.
     * 
    **/
    data: XOR<BotCreateInput, BotUncheckedCreateInput>
  }


  /**
   * Bot createMany
   */
  export type BotCreateManyArgs = {
    data: Enumerable<BotCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Bot update
   */
  export type BotUpdateArgs = {
    /**
     * Select specific fields to fetch from the Bot
     * 
    **/
    select?: BotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BotInclude | null
    /**
     * The data needed to update a Bot.
     * 
    **/
    data: XOR<BotUpdateInput, BotUncheckedUpdateInput>
    /**
     * Choose, which Bot to update.
     * 
    **/
    where: BotWhereUniqueInput
  }


  /**
   * Bot updateMany
   */
  export type BotUpdateManyArgs = {
    data: XOR<BotUpdateManyMutationInput, BotUncheckedUpdateManyInput>
    where?: BotWhereInput
  }


  /**
   * Bot upsert
   */
  export type BotUpsertArgs = {
    /**
     * Select specific fields to fetch from the Bot
     * 
    **/
    select?: BotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BotInclude | null
    /**
     * The filter to search for the Bot to update in case it exists.
     * 
    **/
    where: BotWhereUniqueInput
    /**
     * In case the Bot found by the `where` argument doesn't exist, create a new Bot with this data.
     * 
    **/
    create: XOR<BotCreateInput, BotUncheckedCreateInput>
    /**
     * In case the Bot was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<BotUpdateInput, BotUncheckedUpdateInput>
  }


  /**
   * Bot delete
   */
  export type BotDeleteArgs = {
    /**
     * Select specific fields to fetch from the Bot
     * 
    **/
    select?: BotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BotInclude | null
    /**
     * Filter which Bot to delete.
     * 
    **/
    where: BotWhereUniqueInput
  }


  /**
   * Bot deleteMany
   */
  export type BotDeleteManyArgs = {
    where?: BotWhereInput
  }


  /**
   * Bot without action
   */
  export type BotArgs = {
    /**
     * Select specific fields to fetch from the Bot
     * 
    **/
    select?: BotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BotInclude | null
  }



  /**
   * Model UserBots
   */


  export type AggregateUserBots = {
    _count: UserBotsCountAggregateOutputType | null
    _min: UserBotsMinAggregateOutputType | null
    _max: UserBotsMaxAggregateOutputType | null
  }

  export type UserBotsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    botId: string | null
    botSeedData: string | null
    nextMessageHour: string | null
    isFinished: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserBotsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    botId: string | null
    botSeedData: string | null
    nextMessageHour: string | null
    isFinished: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserBotsCountAggregateOutputType = {
    id: number
    userId: number
    botId: number
    botSeedData: number
    nextMessageHour: number
    isFinished: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserBotsMinAggregateInputType = {
    id?: true
    userId?: true
    botId?: true
    botSeedData?: true
    nextMessageHour?: true
    isFinished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserBotsMaxAggregateInputType = {
    id?: true
    userId?: true
    botId?: true
    botSeedData?: true
    nextMessageHour?: true
    isFinished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserBotsCountAggregateInputType = {
    id?: true
    userId?: true
    botId?: true
    botSeedData?: true
    nextMessageHour?: true
    isFinished?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserBotsAggregateArgs = {
    /**
     * Filter which UserBots to aggregate.
     * 
    **/
    where?: UserBotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBots to fetch.
     * 
    **/
    orderBy?: Enumerable<UserBotsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserBotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBots from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBots.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBots
    **/
    _count?: true | UserBotsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBotsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBotsMaxAggregateInputType
  }

  export type GetUserBotsAggregateType<T extends UserBotsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBots]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBots[P]>
      : GetScalarType<T[P], AggregateUserBots[P]>
  }




  export type UserBotsGroupByArgs = {
    where?: UserBotsWhereInput
    orderBy?: Enumerable<UserBotsOrderByWithAggregationInput>
    by: Array<UserBotsScalarFieldEnum>
    having?: UserBotsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBotsCountAggregateInputType | true
    _min?: UserBotsMinAggregateInputType
    _max?: UserBotsMaxAggregateInputType
  }


  export type UserBotsGroupByOutputType = {
    id: string
    userId: string
    botId: string
    botSeedData: string | null
    nextMessageHour: string | null
    isFinished: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserBotsCountAggregateOutputType | null
    _min: UserBotsMinAggregateOutputType | null
    _max: UserBotsMaxAggregateOutputType | null
  }

  type GetUserBotsGroupByPayload<T extends UserBotsGroupByArgs> = Promise<
    Array<
      PickArray<UserBotsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBotsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBotsGroupByOutputType[P]>
            : GetScalarType<T[P], UserBotsGroupByOutputType[P]>
        }
      >
    >


  export type UserBotsSelect = {
    id?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    bot?: boolean | BotArgs
    botId?: boolean
    botSeedData?: boolean
    nextMessageHour?: boolean
    isFinished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserBotsInclude = {
    user?: boolean | UserArgs
    bot?: boolean | BotArgs
  }

  export type UserBotsGetPayload<
    S extends boolean | null | undefined | UserBotsArgs,
    U = keyof S
      > = S extends true
        ? UserBots
    : S extends undefined
    ? never
    : S extends UserBotsArgs | UserBotsFindManyArgs
    ?'include' extends U
    ? UserBots  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'bot'
        ? BotGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserBots ?UserBots [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'bot'
        ? BotGetPayload<S['select'][P]> : never
  } 
    : UserBots
  : UserBots


  type UserBotsCountArgs = Merge<
    Omit<UserBotsFindManyArgs, 'select' | 'include'> & {
      select?: UserBotsCountAggregateInputType | true
    }
  >

  export interface UserBotsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserBots that matches the filter.
     * @param {UserBotsFindUniqueArgs} args - Arguments to find a UserBots
     * @example
     * // Get one UserBots
     * const userBots = await prisma.userBots.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserBotsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserBotsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserBots'> extends True ? CheckSelect<T, Prisma__UserBotsClient<UserBots>, Prisma__UserBotsClient<UserBotsGetPayload<T>>> : CheckSelect<T, Prisma__UserBotsClient<UserBots | null >, Prisma__UserBotsClient<UserBotsGetPayload<T> | null >>

    /**
     * Find the first UserBots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBotsFindFirstArgs} args - Arguments to find a UserBots
     * @example
     * // Get one UserBots
     * const userBots = await prisma.userBots.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserBotsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserBotsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserBots'> extends True ? CheckSelect<T, Prisma__UserBotsClient<UserBots>, Prisma__UserBotsClient<UserBotsGetPayload<T>>> : CheckSelect<T, Prisma__UserBotsClient<UserBots | null >, Prisma__UserBotsClient<UserBotsGetPayload<T> | null >>

    /**
     * Find zero or more UserBots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBotsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBots
     * const userBots = await prisma.userBots.findMany()
     * 
     * // Get first 10 UserBots
     * const userBots = await prisma.userBots.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBotsWithIdOnly = await prisma.userBots.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserBotsFindManyArgs>(
      args?: SelectSubset<T, UserBotsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserBots>>, PrismaPromise<Array<UserBotsGetPayload<T>>>>

    /**
     * Create a UserBots.
     * @param {UserBotsCreateArgs} args - Arguments to create a UserBots.
     * @example
     * // Create one UserBots
     * const UserBots = await prisma.userBots.create({
     *   data: {
     *     // ... data to create a UserBots
     *   }
     * })
     * 
    **/
    create<T extends UserBotsCreateArgs>(
      args: SelectSubset<T, UserBotsCreateArgs>
    ): CheckSelect<T, Prisma__UserBotsClient<UserBots>, Prisma__UserBotsClient<UserBotsGetPayload<T>>>

    /**
     * Create many UserBots.
     *     @param {UserBotsCreateManyArgs} args - Arguments to create many UserBots.
     *     @example
     *     // Create many UserBots
     *     const userBots = await prisma.userBots.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserBotsCreateManyArgs>(
      args?: SelectSubset<T, UserBotsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserBots.
     * @param {UserBotsDeleteArgs} args - Arguments to delete one UserBots.
     * @example
     * // Delete one UserBots
     * const UserBots = await prisma.userBots.delete({
     *   where: {
     *     // ... filter to delete one UserBots
     *   }
     * })
     * 
    **/
    delete<T extends UserBotsDeleteArgs>(
      args: SelectSubset<T, UserBotsDeleteArgs>
    ): CheckSelect<T, Prisma__UserBotsClient<UserBots>, Prisma__UserBotsClient<UserBotsGetPayload<T>>>

    /**
     * Update one UserBots.
     * @param {UserBotsUpdateArgs} args - Arguments to update one UserBots.
     * @example
     * // Update one UserBots
     * const userBots = await prisma.userBots.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserBotsUpdateArgs>(
      args: SelectSubset<T, UserBotsUpdateArgs>
    ): CheckSelect<T, Prisma__UserBotsClient<UserBots>, Prisma__UserBotsClient<UserBotsGetPayload<T>>>

    /**
     * Delete zero or more UserBots.
     * @param {UserBotsDeleteManyArgs} args - Arguments to filter UserBots to delete.
     * @example
     * // Delete a few UserBots
     * const { count } = await prisma.userBots.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserBotsDeleteManyArgs>(
      args?: SelectSubset<T, UserBotsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBotsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBots
     * const userBots = await prisma.userBots.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserBotsUpdateManyArgs>(
      args: SelectSubset<T, UserBotsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserBots.
     * @param {UserBotsUpsertArgs} args - Arguments to update or create a UserBots.
     * @example
     * // Update or create a UserBots
     * const userBots = await prisma.userBots.upsert({
     *   create: {
     *     // ... data to create a UserBots
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBots we want to update
     *   }
     * })
    **/
    upsert<T extends UserBotsUpsertArgs>(
      args: SelectSubset<T, UserBotsUpsertArgs>
    ): CheckSelect<T, Prisma__UserBotsClient<UserBots>, Prisma__UserBotsClient<UserBotsGetPayload<T>>>

    /**
     * Count the number of UserBots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBotsCountArgs} args - Arguments to filter UserBots to count.
     * @example
     * // Count the number of UserBots
     * const count = await prisma.userBots.count({
     *   where: {
     *     // ... the filter for the UserBots we want to count
     *   }
     * })
    **/
    count<T extends UserBotsCountArgs>(
      args?: Subset<T, UserBotsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBotsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBotsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBotsAggregateArgs>(args: Subset<T, UserBotsAggregateArgs>): PrismaPromise<GetUserBotsAggregateType<T>>

    /**
     * Group by UserBots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBotsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBotsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBotsGroupByArgs['orderBy'] }
        : { orderBy?: UserBotsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBotsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBotsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBots.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserBotsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    bot<T extends BotArgs = {}>(args?: Subset<T, BotArgs>): CheckSelect<T, Prisma__BotClient<Bot | null >, Prisma__BotClient<BotGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserBots findUnique
   */
  export type UserBotsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserBots
     * 
    **/
    select?: UserBotsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserBotsInclude | null
    /**
     * Throw an Error if a UserBots can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserBots to fetch.
     * 
    **/
    where: UserBotsWhereUniqueInput
  }


  /**
   * UserBots findFirst
   */
  export type UserBotsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserBots
     * 
    **/
    select?: UserBotsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserBotsInclude | null
    /**
     * Throw an Error if a UserBots can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserBots to fetch.
     * 
    **/
    where?: UserBotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBots to fetch.
     * 
    **/
    orderBy?: Enumerable<UserBotsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBots.
     * 
    **/
    cursor?: UserBotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBots from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBots.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBots.
     * 
    **/
    distinct?: Enumerable<UserBotsScalarFieldEnum>
  }


  /**
   * UserBots findMany
   */
  export type UserBotsFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserBots
     * 
    **/
    select?: UserBotsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserBotsInclude | null
    /**
     * Filter, which UserBots to fetch.
     * 
    **/
    where?: UserBotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBots to fetch.
     * 
    **/
    orderBy?: Enumerable<UserBotsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBots.
     * 
    **/
    cursor?: UserBotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBots from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBots.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserBotsScalarFieldEnum>
  }


  /**
   * UserBots create
   */
  export type UserBotsCreateArgs = {
    /**
     * Select specific fields to fetch from the UserBots
     * 
    **/
    select?: UserBotsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserBotsInclude | null
    /**
     * The data needed to create a UserBots.
     * 
    **/
    data: XOR<UserBotsCreateInput, UserBotsUncheckedCreateInput>
  }


  /**
   * UserBots createMany
   */
  export type UserBotsCreateManyArgs = {
    data: Enumerable<UserBotsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserBots update
   */
  export type UserBotsUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserBots
     * 
    **/
    select?: UserBotsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserBotsInclude | null
    /**
     * The data needed to update a UserBots.
     * 
    **/
    data: XOR<UserBotsUpdateInput, UserBotsUncheckedUpdateInput>
    /**
     * Choose, which UserBots to update.
     * 
    **/
    where: UserBotsWhereUniqueInput
  }


  /**
   * UserBots updateMany
   */
  export type UserBotsUpdateManyArgs = {
    data: XOR<UserBotsUpdateManyMutationInput, UserBotsUncheckedUpdateManyInput>
    where?: UserBotsWhereInput
  }


  /**
   * UserBots upsert
   */
  export type UserBotsUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserBots
     * 
    **/
    select?: UserBotsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserBotsInclude | null
    /**
     * The filter to search for the UserBots to update in case it exists.
     * 
    **/
    where: UserBotsWhereUniqueInput
    /**
     * In case the UserBots found by the `where` argument doesn't exist, create a new UserBots with this data.
     * 
    **/
    create: XOR<UserBotsCreateInput, UserBotsUncheckedCreateInput>
    /**
     * In case the UserBots was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserBotsUpdateInput, UserBotsUncheckedUpdateInput>
  }


  /**
   * UserBots delete
   */
  export type UserBotsDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserBots
     * 
    **/
    select?: UserBotsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserBotsInclude | null
    /**
     * Filter which UserBots to delete.
     * 
    **/
    where: UserBotsWhereUniqueInput
  }


  /**
   * UserBots deleteMany
   */
  export type UserBotsDeleteManyArgs = {
    where?: UserBotsWhereInput
  }


  /**
   * UserBots without action
   */
  export type UserBotsArgs = {
    /**
     * Select specific fields to fetch from the UserBots
     * 
    **/
    select?: UserBotsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserBotsInclude | null
  }



  /**
   * Model Tag
   */


  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs = {
    /**
     * Filter which Tag to aggregate.
     * 
    **/
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     * 
    **/
    orderBy?: Enumerable<TagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs = {
    where?: TagWhereInput
    orderBy?: Enumerable<TagOrderByWithAggregationInput>
    by: Array<TagScalarFieldEnum>
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }


  export type TagGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Promise<
    Array<
      PickArray<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagGetPayload<
    S extends boolean | null | undefined | TagArgs,
    U = keyof S
      > = S extends true
        ? Tag
    : S extends undefined
    ? never
    : S extends TagArgs | TagFindManyArgs
    ?'include' extends U
    ? Tag 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Tag ?Tag [P]
  : 
     never
  } 
    : Tag
  : Tag


  type TagCountArgs = Merge<
    Omit<TagFindManyArgs, 'select' | 'include'> & {
      select?: TagCountAggregateInputType | true
    }
  >

  export interface TagDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Tag'> extends True ? CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>> : CheckSelect<T, Prisma__TagClient<Tag | null >, Prisma__TagClient<TagGetPayload<T> | null >>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Tag'> extends True ? CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>> : CheckSelect<T, Prisma__TagClient<Tag | null >, Prisma__TagClient<TagGetPayload<T> | null >>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TagFindManyArgs>(
      args?: SelectSubset<T, TagFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Tag>>, PrismaPromise<Array<TagGetPayload<T>>>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
    **/
    create<T extends TagCreateArgs>(
      args: SelectSubset<T, TagCreateArgs>
    ): CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>>

    /**
     * Create many Tags.
     *     @param {TagCreateManyArgs} args - Arguments to create many Tags.
     *     @example
     *     // Create many Tags
     *     const tag = await prisma.tag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TagCreateManyArgs>(
      args?: SelectSubset<T, TagCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
    **/
    delete<T extends TagDeleteArgs>(
      args: SelectSubset<T, TagDeleteArgs>
    ): CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TagUpdateArgs>(
      args: SelectSubset<T, TagUpdateArgs>
    ): CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TagDeleteManyArgs>(
      args?: SelectSubset<T, TagDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TagUpdateManyArgs>(
      args: SelectSubset<T, TagUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
    **/
    upsert<T extends TagUpsertArgs>(
      args: SelectSubset<T, TagUpsertArgs>
    ): CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>>

    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TagClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Throw an Error if a Tag can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Tag to fetch.
     * 
    **/
    where: TagWhereUniqueInput
  }


  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Throw an Error if a Tag can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Tag to fetch.
     * 
    **/
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     * 
    **/
    orderBy?: Enumerable<TagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     * 
    **/
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     * 
    **/
    distinct?: Enumerable<TagScalarFieldEnum>
  }


  /**
   * Tag findMany
   */
  export type TagFindManyArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Filter, which Tags to fetch.
     * 
    **/
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     * 
    **/
    orderBy?: Enumerable<TagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     * 
    **/
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TagScalarFieldEnum>
  }


  /**
   * Tag create
   */
  export type TagCreateArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * The data needed to create a Tag.
     * 
    **/
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }


  /**
   * Tag createMany
   */
  export type TagCreateManyArgs = {
    data: Enumerable<TagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Tag update
   */
  export type TagUpdateArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * The data needed to update a Tag.
     * 
    **/
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     * 
    **/
    where: TagWhereUniqueInput
  }


  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs = {
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    where?: TagWhereInput
  }


  /**
   * Tag upsert
   */
  export type TagUpsertArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * The filter to search for the Tag to update in case it exists.
     * 
    **/
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     * 
    **/
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }


  /**
   * Tag delete
   */
  export type TagDeleteArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Filter which Tag to delete.
     * 
    **/
    where: TagWhereUniqueInput
  }


  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs = {
    where?: TagWhereInput
  }


  /**
   * Tag without action
   */
  export type TagArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
  }



  /**
   * Model Payer
   */


  export type AggregatePayer = {
    _count: PayerCountAggregateOutputType | null
    _min: PayerMinAggregateOutputType | null
    _max: PayerMaxAggregateOutputType | null
  }

  export type PayerMinAggregateOutputType = {
    id: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    stripePriceId: string | null
    stripeCurrentPeriodEnd: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayerMaxAggregateOutputType = {
    id: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    stripePriceId: string | null
    stripeCurrentPeriodEnd: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayerCountAggregateOutputType = {
    id: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    stripePriceId: number
    stripeCurrentPeriodEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PayerMinAggregateInputType = {
    id?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    stripePriceId?: true
    stripeCurrentPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayerMaxAggregateInputType = {
    id?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    stripePriceId?: true
    stripeCurrentPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayerCountAggregateInputType = {
    id?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    stripePriceId?: true
    stripeCurrentPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PayerAggregateArgs = {
    /**
     * Filter which Payer to aggregate.
     * 
    **/
    where?: PayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payers to fetch.
     * 
    **/
    orderBy?: Enumerable<PayerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payers
    **/
    _count?: true | PayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayerMaxAggregateInputType
  }

  export type GetPayerAggregateType<T extends PayerAggregateArgs> = {
        [P in keyof T & keyof AggregatePayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayer[P]>
      : GetScalarType<T[P], AggregatePayer[P]>
  }




  export type PayerGroupByArgs = {
    where?: PayerWhereInput
    orderBy?: Enumerable<PayerOrderByWithAggregationInput>
    by: Array<PayerScalarFieldEnum>
    having?: PayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayerCountAggregateInputType | true
    _min?: PayerMinAggregateInputType
    _max?: PayerMaxAggregateInputType
  }


  export type PayerGroupByOutputType = {
    id: string
    stripeCustomerId: string
    stripeSubscriptionId: string
    stripePriceId: string
    stripeCurrentPeriodEnd: string
    createdAt: Date
    updatedAt: Date
    _count: PayerCountAggregateOutputType | null
    _min: PayerMinAggregateOutputType | null
    _max: PayerMaxAggregateOutputType | null
  }

  type GetPayerGroupByPayload<T extends PayerGroupByArgs> = Promise<
    Array<
      PickArray<PayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayerGroupByOutputType[P]>
            : GetScalarType<T[P], PayerGroupByOutputType[P]>
        }
      >
    >


  export type PayerSelect = {
    id?: boolean
    users?: boolean | UserFindManyArgs
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripePriceId?: boolean
    stripeCurrentPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | PayerCountOutputTypeArgs
  }

  export type PayerInclude = {
    users?: boolean | UserFindManyArgs
    _count?: boolean | PayerCountOutputTypeArgs
  }

  export type PayerGetPayload<
    S extends boolean | null | undefined | PayerArgs,
    U = keyof S
      > = S extends true
        ? Payer
    : S extends undefined
    ? never
    : S extends PayerArgs | PayerFindManyArgs
    ?'include' extends U
    ? Payer  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'users'
        ? Array < UserGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? PayerCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Payer ?Payer [P]
  : 
          P extends 'users'
        ? Array < UserGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? PayerCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Payer
  : Payer


  type PayerCountArgs = Merge<
    Omit<PayerFindManyArgs, 'select' | 'include'> & {
      select?: PayerCountAggregateInputType | true
    }
  >

  export interface PayerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Payer that matches the filter.
     * @param {PayerFindUniqueArgs} args - Arguments to find a Payer
     * @example
     * // Get one Payer
     * const payer = await prisma.payer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PayerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PayerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Payer'> extends True ? CheckSelect<T, Prisma__PayerClient<Payer>, Prisma__PayerClient<PayerGetPayload<T>>> : CheckSelect<T, Prisma__PayerClient<Payer | null >, Prisma__PayerClient<PayerGetPayload<T> | null >>

    /**
     * Find the first Payer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayerFindFirstArgs} args - Arguments to find a Payer
     * @example
     * // Get one Payer
     * const payer = await prisma.payer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PayerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PayerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Payer'> extends True ? CheckSelect<T, Prisma__PayerClient<Payer>, Prisma__PayerClient<PayerGetPayload<T>>> : CheckSelect<T, Prisma__PayerClient<Payer | null >, Prisma__PayerClient<PayerGetPayload<T> | null >>

    /**
     * Find zero or more Payers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payers
     * const payers = await prisma.payer.findMany()
     * 
     * // Get first 10 Payers
     * const payers = await prisma.payer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payerWithIdOnly = await prisma.payer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PayerFindManyArgs>(
      args?: SelectSubset<T, PayerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Payer>>, PrismaPromise<Array<PayerGetPayload<T>>>>

    /**
     * Create a Payer.
     * @param {PayerCreateArgs} args - Arguments to create a Payer.
     * @example
     * // Create one Payer
     * const Payer = await prisma.payer.create({
     *   data: {
     *     // ... data to create a Payer
     *   }
     * })
     * 
    **/
    create<T extends PayerCreateArgs>(
      args: SelectSubset<T, PayerCreateArgs>
    ): CheckSelect<T, Prisma__PayerClient<Payer>, Prisma__PayerClient<PayerGetPayload<T>>>

    /**
     * Create many Payers.
     *     @param {PayerCreateManyArgs} args - Arguments to create many Payers.
     *     @example
     *     // Create many Payers
     *     const payer = await prisma.payer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PayerCreateManyArgs>(
      args?: SelectSubset<T, PayerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Payer.
     * @param {PayerDeleteArgs} args - Arguments to delete one Payer.
     * @example
     * // Delete one Payer
     * const Payer = await prisma.payer.delete({
     *   where: {
     *     // ... filter to delete one Payer
     *   }
     * })
     * 
    **/
    delete<T extends PayerDeleteArgs>(
      args: SelectSubset<T, PayerDeleteArgs>
    ): CheckSelect<T, Prisma__PayerClient<Payer>, Prisma__PayerClient<PayerGetPayload<T>>>

    /**
     * Update one Payer.
     * @param {PayerUpdateArgs} args - Arguments to update one Payer.
     * @example
     * // Update one Payer
     * const payer = await prisma.payer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PayerUpdateArgs>(
      args: SelectSubset<T, PayerUpdateArgs>
    ): CheckSelect<T, Prisma__PayerClient<Payer>, Prisma__PayerClient<PayerGetPayload<T>>>

    /**
     * Delete zero or more Payers.
     * @param {PayerDeleteManyArgs} args - Arguments to filter Payers to delete.
     * @example
     * // Delete a few Payers
     * const { count } = await prisma.payer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PayerDeleteManyArgs>(
      args?: SelectSubset<T, PayerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payers
     * const payer = await prisma.payer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PayerUpdateManyArgs>(
      args: SelectSubset<T, PayerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Payer.
     * @param {PayerUpsertArgs} args - Arguments to update or create a Payer.
     * @example
     * // Update or create a Payer
     * const payer = await prisma.payer.upsert({
     *   create: {
     *     // ... data to create a Payer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payer we want to update
     *   }
     * })
    **/
    upsert<T extends PayerUpsertArgs>(
      args: SelectSubset<T, PayerUpsertArgs>
    ): CheckSelect<T, Prisma__PayerClient<Payer>, Prisma__PayerClient<PayerGetPayload<T>>>

    /**
     * Count the number of Payers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayerCountArgs} args - Arguments to filter Payers to count.
     * @example
     * // Count the number of Payers
     * const count = await prisma.payer.count({
     *   where: {
     *     // ... the filter for the Payers we want to count
     *   }
     * })
    **/
    count<T extends PayerCountArgs>(
      args?: Subset<T, PayerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayerAggregateArgs>(args: Subset<T, PayerAggregateArgs>): PrismaPromise<GetPayerAggregateType<T>>

    /**
     * Group by Payer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayerGroupByArgs['orderBy'] }
        : { orderBy?: PayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayerGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PayerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Payer findUnique
   */
  export type PayerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Payer
     * 
    **/
    select?: PayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PayerInclude | null
    /**
     * Throw an Error if a Payer can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Payer to fetch.
     * 
    **/
    where: PayerWhereUniqueInput
  }


  /**
   * Payer findFirst
   */
  export type PayerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Payer
     * 
    **/
    select?: PayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PayerInclude | null
    /**
     * Throw an Error if a Payer can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Payer to fetch.
     * 
    **/
    where?: PayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payers to fetch.
     * 
    **/
    orderBy?: Enumerable<PayerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payers.
     * 
    **/
    cursor?: PayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payers.
     * 
    **/
    distinct?: Enumerable<PayerScalarFieldEnum>
  }


  /**
   * Payer findMany
   */
  export type PayerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Payer
     * 
    **/
    select?: PayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PayerInclude | null
    /**
     * Filter, which Payers to fetch.
     * 
    **/
    where?: PayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payers to fetch.
     * 
    **/
    orderBy?: Enumerable<PayerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payers.
     * 
    **/
    cursor?: PayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PayerScalarFieldEnum>
  }


  /**
   * Payer create
   */
  export type PayerCreateArgs = {
    /**
     * Select specific fields to fetch from the Payer
     * 
    **/
    select?: PayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PayerInclude | null
    /**
     * The data needed to create a Payer.
     * 
    **/
    data: XOR<PayerCreateInput, PayerUncheckedCreateInput>
  }


  /**
   * Payer createMany
   */
  export type PayerCreateManyArgs = {
    data: Enumerable<PayerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Payer update
   */
  export type PayerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Payer
     * 
    **/
    select?: PayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PayerInclude | null
    /**
     * The data needed to update a Payer.
     * 
    **/
    data: XOR<PayerUpdateInput, PayerUncheckedUpdateInput>
    /**
     * Choose, which Payer to update.
     * 
    **/
    where: PayerWhereUniqueInput
  }


  /**
   * Payer updateMany
   */
  export type PayerUpdateManyArgs = {
    data: XOR<PayerUpdateManyMutationInput, PayerUncheckedUpdateManyInput>
    where?: PayerWhereInput
  }


  /**
   * Payer upsert
   */
  export type PayerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Payer
     * 
    **/
    select?: PayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PayerInclude | null
    /**
     * The filter to search for the Payer to update in case it exists.
     * 
    **/
    where: PayerWhereUniqueInput
    /**
     * In case the Payer found by the `where` argument doesn't exist, create a new Payer with this data.
     * 
    **/
    create: XOR<PayerCreateInput, PayerUncheckedCreateInput>
    /**
     * In case the Payer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PayerUpdateInput, PayerUncheckedUpdateInput>
  }


  /**
   * Payer delete
   */
  export type PayerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Payer
     * 
    **/
    select?: PayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PayerInclude | null
    /**
     * Filter which Payer to delete.
     * 
    **/
    where: PayerWhereUniqueInput
  }


  /**
   * Payer deleteMany
   */
  export type PayerDeleteManyArgs = {
    where?: PayerWhereInput
  }


  /**
   * Payer without action
   */
  export type PayerArgs = {
    /**
     * Select specific fields to fetch from the Payer
     * 
    **/
    select?: PayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PayerInclude | null
  }



  /**
   * Model Product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    active: boolean | null
    name: string | null
    description: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    active: boolean | null
    name: string | null
    description: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    active: number
    name: number
    description: number
    image: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductMinAggregateInputType = {
    id?: true
    active?: true
    name?: true
    description?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    active?: true
    name?: true
    description?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    active?: true
    name?: true
    description?: true
    image?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs = {
    /**
     * Filter which Product to aggregate.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs = {
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithAggregationInput>
    by: Array<ProductScalarFieldEnum>
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: string
    active: boolean
    name: string
    description: string | null
    image: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Promise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect = {
    id?: boolean
    active?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    metadata?: boolean
    prices?: boolean | PriceFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | ProductCountOutputTypeArgs
  }

  export type ProductInclude = {
    prices?: boolean | PriceFindManyArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }

  export type ProductGetPayload<
    S extends boolean | null | undefined | ProductArgs,
    U = keyof S
      > = S extends true
        ? Product
    : S extends undefined
    ? never
    : S extends ProductArgs | ProductFindManyArgs
    ?'include' extends U
    ? Product  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'prices'
        ? Array < PriceGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? ProductCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Product ?Product [P]
  : 
          P extends 'prices'
        ? Array < PriceGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? ProductCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Product
  : Product


  type ProductCountArgs = Merge<
    Omit<ProductFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }
  >

  export interface ProductDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs>(
      args?: SelectSubset<T, ProductFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs>(
      args: SelectSubset<T, ProductCreateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs>(
      args?: SelectSubset<T, ProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs>(
      args: SelectSubset<T, ProductDeleteArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs>(
      args: SelectSubset<T, ProductUpdateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs>(
      args?: SelectSubset<T, ProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs>(
      args: SelectSubset<T, ProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs>(
      args: SelectSubset<T, ProductUpsertArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    prices<T extends PriceFindManyArgs = {}>(args?: Subset<T, PriceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Price>>, PrismaPromise<Array<PriceGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Throw an Error if a Product can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Throw an Error if a Product can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     * 
    **/
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Products to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product create
   */
  export type ProductCreateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to create a Product.
     * 
    **/
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs = {
    data: Enumerable<ProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to update a Product.
     * 
    **/
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs = {
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The filter to search for the Product to update in case it exists.
     * 
    **/
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     * 
    **/
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter which Product to delete.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs = {
    where?: ProductWhereInput
  }


  /**
   * Product without action
   */
  export type ProductArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
  }



  /**
   * Model Price
   */


  export type AggregatePrice = {
    _count: PriceCountAggregateOutputType | null
    _avg: PriceAvgAggregateOutputType | null
    _sum: PriceSumAggregateOutputType | null
    _min: PriceMinAggregateOutputType | null
    _max: PriceMaxAggregateOutputType | null
  }

  export type PriceAvgAggregateOutputType = {
    unitAmount: Decimal | null
    intervalCount: number | null
    trialPeriodDays: number | null
  }

  export type PriceSumAggregateOutputType = {
    unitAmount: Decimal | null
    intervalCount: number | null
    trialPeriodDays: number | null
  }

  export type PriceMinAggregateOutputType = {
    id: string | null
    productId: string | null
    active: boolean | null
    currency: string | null
    interval: PriceInterval | null
    unitAmount: Decimal | null
    intervalCount: number | null
    trialPeriodDays: number | null
    type: PriceType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PriceMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    active: boolean | null
    currency: string | null
    interval: PriceInterval | null
    unitAmount: Decimal | null
    intervalCount: number | null
    trialPeriodDays: number | null
    type: PriceType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PriceCountAggregateOutputType = {
    id: number
    productId: number
    active: number
    currency: number
    interval: number
    unitAmount: number
    intervalCount: number
    trialPeriodDays: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PriceAvgAggregateInputType = {
    unitAmount?: true
    intervalCount?: true
    trialPeriodDays?: true
  }

  export type PriceSumAggregateInputType = {
    unitAmount?: true
    intervalCount?: true
    trialPeriodDays?: true
  }

  export type PriceMinAggregateInputType = {
    id?: true
    productId?: true
    active?: true
    currency?: true
    interval?: true
    unitAmount?: true
    intervalCount?: true
    trialPeriodDays?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PriceMaxAggregateInputType = {
    id?: true
    productId?: true
    active?: true
    currency?: true
    interval?: true
    unitAmount?: true
    intervalCount?: true
    trialPeriodDays?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PriceCountAggregateInputType = {
    id?: true
    productId?: true
    active?: true
    currency?: true
    interval?: true
    unitAmount?: true
    intervalCount?: true
    trialPeriodDays?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PriceAggregateArgs = {
    /**
     * Filter which Price to aggregate.
     * 
    **/
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     * 
    **/
    orderBy?: Enumerable<PriceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prices
    **/
    _count?: true | PriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceMaxAggregateInputType
  }

  export type GetPriceAggregateType<T extends PriceAggregateArgs> = {
        [P in keyof T & keyof AggregatePrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrice[P]>
      : GetScalarType<T[P], AggregatePrice[P]>
  }




  export type PriceGroupByArgs = {
    where?: PriceWhereInput
    orderBy?: Enumerable<PriceOrderByWithAggregationInput>
    by: Array<PriceScalarFieldEnum>
    having?: PriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceCountAggregateInputType | true
    _avg?: PriceAvgAggregateInputType
    _sum?: PriceSumAggregateInputType
    _min?: PriceMinAggregateInputType
    _max?: PriceMaxAggregateInputType
  }


  export type PriceGroupByOutputType = {
    id: string
    productId: string
    active: boolean
    currency: string
    interval: PriceInterval | null
    unitAmount: Decimal | null
    intervalCount: number | null
    trialPeriodDays: number | null
    type: PriceType | null
    createdAt: Date
    updatedAt: Date
    _count: PriceCountAggregateOutputType | null
    _avg: PriceAvgAggregateOutputType | null
    _sum: PriceSumAggregateOutputType | null
    _min: PriceMinAggregateOutputType | null
    _max: PriceMaxAggregateOutputType | null
  }

  type GetPriceGroupByPayload<T extends PriceGroupByArgs> = Promise<
    Array<
      PickArray<PriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceGroupByOutputType[P]>
            : GetScalarType<T[P], PriceGroupByOutputType[P]>
        }
      >
    >


  export type PriceSelect = {
    id?: boolean
    product?: boolean | ProductArgs
    productId?: boolean
    active?: boolean
    currency?: boolean
    interval?: boolean
    unitAmount?: boolean
    intervalCount?: boolean
    trialPeriodDays?: boolean
    type?: boolean
    subscriptions?: boolean | SubscriptionFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | PriceCountOutputTypeArgs
  }

  export type PriceInclude = {
    product?: boolean | ProductArgs
    subscriptions?: boolean | SubscriptionFindManyArgs
    _count?: boolean | PriceCountOutputTypeArgs
  }

  export type PriceGetPayload<
    S extends boolean | null | undefined | PriceArgs,
    U = keyof S
      > = S extends true
        ? Price
    : S extends undefined
    ? never
    : S extends PriceArgs | PriceFindManyArgs
    ?'include' extends U
    ? Price  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'product'
        ? ProductGetPayload<S['include'][P]> :
        P extends 'subscriptions'
        ? Array < SubscriptionGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? PriceCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Price ?Price [P]
  : 
          P extends 'product'
        ? ProductGetPayload<S['select'][P]> :
        P extends 'subscriptions'
        ? Array < SubscriptionGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? PriceCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Price
  : Price


  type PriceCountArgs = Merge<
    Omit<PriceFindManyArgs, 'select' | 'include'> & {
      select?: PriceCountAggregateInputType | true
    }
  >

  export interface PriceDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Price that matches the filter.
     * @param {PriceFindUniqueArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PriceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PriceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Price'> extends True ? CheckSelect<T, Prisma__PriceClient<Price>, Prisma__PriceClient<PriceGetPayload<T>>> : CheckSelect<T, Prisma__PriceClient<Price | null >, Prisma__PriceClient<PriceGetPayload<T> | null >>

    /**
     * Find the first Price that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceFindFirstArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PriceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PriceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Price'> extends True ? CheckSelect<T, Prisma__PriceClient<Price>, Prisma__PriceClient<PriceGetPayload<T>>> : CheckSelect<T, Prisma__PriceClient<Price | null >, Prisma__PriceClient<PriceGetPayload<T> | null >>

    /**
     * Find zero or more Prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prices
     * const prices = await prisma.price.findMany()
     * 
     * // Get first 10 Prices
     * const prices = await prisma.price.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceWithIdOnly = await prisma.price.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PriceFindManyArgs>(
      args?: SelectSubset<T, PriceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Price>>, PrismaPromise<Array<PriceGetPayload<T>>>>

    /**
     * Create a Price.
     * @param {PriceCreateArgs} args - Arguments to create a Price.
     * @example
     * // Create one Price
     * const Price = await prisma.price.create({
     *   data: {
     *     // ... data to create a Price
     *   }
     * })
     * 
    **/
    create<T extends PriceCreateArgs>(
      args: SelectSubset<T, PriceCreateArgs>
    ): CheckSelect<T, Prisma__PriceClient<Price>, Prisma__PriceClient<PriceGetPayload<T>>>

    /**
     * Create many Prices.
     *     @param {PriceCreateManyArgs} args - Arguments to create many Prices.
     *     @example
     *     // Create many Prices
     *     const price = await prisma.price.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PriceCreateManyArgs>(
      args?: SelectSubset<T, PriceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Price.
     * @param {PriceDeleteArgs} args - Arguments to delete one Price.
     * @example
     * // Delete one Price
     * const Price = await prisma.price.delete({
     *   where: {
     *     // ... filter to delete one Price
     *   }
     * })
     * 
    **/
    delete<T extends PriceDeleteArgs>(
      args: SelectSubset<T, PriceDeleteArgs>
    ): CheckSelect<T, Prisma__PriceClient<Price>, Prisma__PriceClient<PriceGetPayload<T>>>

    /**
     * Update one Price.
     * @param {PriceUpdateArgs} args - Arguments to update one Price.
     * @example
     * // Update one Price
     * const price = await prisma.price.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PriceUpdateArgs>(
      args: SelectSubset<T, PriceUpdateArgs>
    ): CheckSelect<T, Prisma__PriceClient<Price>, Prisma__PriceClient<PriceGetPayload<T>>>

    /**
     * Delete zero or more Prices.
     * @param {PriceDeleteManyArgs} args - Arguments to filter Prices to delete.
     * @example
     * // Delete a few Prices
     * const { count } = await prisma.price.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PriceDeleteManyArgs>(
      args?: SelectSubset<T, PriceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prices
     * const price = await prisma.price.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PriceUpdateManyArgs>(
      args: SelectSubset<T, PriceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Price.
     * @param {PriceUpsertArgs} args - Arguments to update or create a Price.
     * @example
     * // Update or create a Price
     * const price = await prisma.price.upsert({
     *   create: {
     *     // ... data to create a Price
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Price we want to update
     *   }
     * })
    **/
    upsert<T extends PriceUpsertArgs>(
      args: SelectSubset<T, PriceUpsertArgs>
    ): CheckSelect<T, Prisma__PriceClient<Price>, Prisma__PriceClient<PriceGetPayload<T>>>

    /**
     * Count the number of Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceCountArgs} args - Arguments to filter Prices to count.
     * @example
     * // Count the number of Prices
     * const count = await prisma.price.count({
     *   where: {
     *     // ... the filter for the Prices we want to count
     *   }
     * })
    **/
    count<T extends PriceCountArgs>(
      args?: Subset<T, PriceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Price.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceAggregateArgs>(args: Subset<T, PriceAggregateArgs>): PrismaPromise<GetPriceAggregateType<T>>

    /**
     * Group by Price.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceGroupByArgs['orderBy'] }
        : { orderBy?: PriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Price.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PriceClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    subscriptions<T extends SubscriptionFindManyArgs = {}>(args?: Subset<T, SubscriptionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Subscription>>, PrismaPromise<Array<SubscriptionGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Price findUnique
   */
  export type PriceFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Price
     * 
    **/
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceInclude | null
    /**
     * Throw an Error if a Price can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Price to fetch.
     * 
    **/
    where: PriceWhereUniqueInput
  }


  /**
   * Price findFirst
   */
  export type PriceFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Price
     * 
    **/
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceInclude | null
    /**
     * Throw an Error if a Price can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Price to fetch.
     * 
    **/
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     * 
    **/
    orderBy?: Enumerable<PriceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prices.
     * 
    **/
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prices.
     * 
    **/
    distinct?: Enumerable<PriceScalarFieldEnum>
  }


  /**
   * Price findMany
   */
  export type PriceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Price
     * 
    **/
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceInclude | null
    /**
     * Filter, which Prices to fetch.
     * 
    **/
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     * 
    **/
    orderBy?: Enumerable<PriceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prices.
     * 
    **/
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PriceScalarFieldEnum>
  }


  /**
   * Price create
   */
  export type PriceCreateArgs = {
    /**
     * Select specific fields to fetch from the Price
     * 
    **/
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceInclude | null
    /**
     * The data needed to create a Price.
     * 
    **/
    data: XOR<PriceCreateInput, PriceUncheckedCreateInput>
  }


  /**
   * Price createMany
   */
  export type PriceCreateManyArgs = {
    data: Enumerable<PriceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Price update
   */
  export type PriceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Price
     * 
    **/
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceInclude | null
    /**
     * The data needed to update a Price.
     * 
    **/
    data: XOR<PriceUpdateInput, PriceUncheckedUpdateInput>
    /**
     * Choose, which Price to update.
     * 
    **/
    where: PriceWhereUniqueInput
  }


  /**
   * Price updateMany
   */
  export type PriceUpdateManyArgs = {
    data: XOR<PriceUpdateManyMutationInput, PriceUncheckedUpdateManyInput>
    where?: PriceWhereInput
  }


  /**
   * Price upsert
   */
  export type PriceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Price
     * 
    **/
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceInclude | null
    /**
     * The filter to search for the Price to update in case it exists.
     * 
    **/
    where: PriceWhereUniqueInput
    /**
     * In case the Price found by the `where` argument doesn't exist, create a new Price with this data.
     * 
    **/
    create: XOR<PriceCreateInput, PriceUncheckedCreateInput>
    /**
     * In case the Price was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PriceUpdateInput, PriceUncheckedUpdateInput>
  }


  /**
   * Price delete
   */
  export type PriceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Price
     * 
    **/
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceInclude | null
    /**
     * Filter which Price to delete.
     * 
    **/
    where: PriceWhereUniqueInput
  }


  /**
   * Price deleteMany
   */
  export type PriceDeleteManyArgs = {
    where?: PriceWhereInput
  }


  /**
   * Price without action
   */
  export type PriceArgs = {
    /**
     * Select specific fields to fetch from the Price
     * 
    **/
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceInclude | null
  }



  /**
   * Model Subscription
   */


  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    priceId: string | null
    status: SubscriptionStatus | null
    startDate: Date | null
    endedAt: Date | null
    trialEnd: Date | null
    trialStart: Date | null
    cancelAt: Date | null
    cancelAtPeriodEnd: boolean | null
    canceledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    priceId: string | null
    status: SubscriptionStatus | null
    startDate: Date | null
    endedAt: Date | null
    trialEnd: Date | null
    trialStart: Date | null
    cancelAt: Date | null
    cancelAtPeriodEnd: boolean | null
    canceledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    priceId: number
    status: number
    startDate: number
    endedAt: number
    trialEnd: number
    trialStart: number
    cancelAt: number
    cancelAtPeriodEnd: number
    canceledAt: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    priceId?: true
    status?: true
    startDate?: true
    endedAt?: true
    trialEnd?: true
    trialStart?: true
    cancelAt?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    priceId?: true
    status?: true
    startDate?: true
    endedAt?: true
    trialEnd?: true
    trialStart?: true
    cancelAt?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    priceId?: true
    status?: true
    startDate?: true
    endedAt?: true
    trialEnd?: true
    trialStart?: true
    cancelAt?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs = {
    /**
     * Filter which Subscription to aggregate.
     * 
    **/
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     * 
    **/
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs = {
    where?: SubscriptionWhereInput
    orderBy?: Enumerable<SubscriptionOrderByWithAggregationInput>
    by: Array<SubscriptionScalarFieldEnum>
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }


  export type SubscriptionGroupByOutputType = {
    id: string
    userId: string
    priceId: string | null
    status: SubscriptionStatus
    startDate: Date | null
    endedAt: Date | null
    trialEnd: Date | null
    trialStart: Date | null
    cancelAt: Date | null
    cancelAtPeriodEnd: boolean | null
    canceledAt: Date | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Promise<
    Array<
      PickArray<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect = {
    id?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    price?: boolean | PriceArgs
    priceId?: boolean
    status?: boolean
    startDate?: boolean
    endedAt?: boolean
    trialEnd?: boolean
    trialStart?: boolean
    cancelAt?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionInclude = {
    user?: boolean | UserArgs
    price?: boolean | PriceArgs
  }

  export type SubscriptionGetPayload<
    S extends boolean | null | undefined | SubscriptionArgs,
    U = keyof S
      > = S extends true
        ? Subscription
    : S extends undefined
    ? never
    : S extends SubscriptionArgs | SubscriptionFindManyArgs
    ?'include' extends U
    ? Subscription  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'price'
        ? PriceGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Subscription ?Subscription [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'price'
        ? PriceGetPayload<S['select'][P]> | null : never
  } 
    : Subscription
  : Subscription


  type SubscriptionCountArgs = Merge<
    Omit<SubscriptionFindManyArgs, 'select' | 'include'> & {
      select?: SubscriptionCountAggregateInputType | true
    }
  >

  export interface SubscriptionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubscriptionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubscriptionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Subscription'> extends True ? CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>> : CheckSelect<T, Prisma__SubscriptionClient<Subscription | null >, Prisma__SubscriptionClient<SubscriptionGetPayload<T> | null >>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubscriptionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubscriptionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Subscription'> extends True ? CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>> : CheckSelect<T, Prisma__SubscriptionClient<Subscription | null >, Prisma__SubscriptionClient<SubscriptionGetPayload<T> | null >>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubscriptionFindManyArgs>(
      args?: SelectSubset<T, SubscriptionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Subscription>>, PrismaPromise<Array<SubscriptionGetPayload<T>>>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
    **/
    create<T extends SubscriptionCreateArgs>(
      args: SelectSubset<T, SubscriptionCreateArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>

    /**
     * Create many Subscriptions.
     *     @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     *     @example
     *     // Create many Subscriptions
     *     const subscription = await prisma.subscription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubscriptionCreateManyArgs>(
      args?: SelectSubset<T, SubscriptionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
    **/
    delete<T extends SubscriptionDeleteArgs>(
      args: SelectSubset<T, SubscriptionDeleteArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubscriptionUpdateArgs>(
      args: SelectSubset<T, SubscriptionUpdateArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubscriptionDeleteManyArgs>(
      args?: SelectSubset<T, SubscriptionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubscriptionUpdateManyArgs>(
      args: SelectSubset<T, SubscriptionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
    **/
    upsert<T extends SubscriptionUpsertArgs>(
      args: SelectSubset<T, SubscriptionUpsertArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>

    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubscriptionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    price<T extends PriceArgs = {}>(args?: Subset<T, PriceArgs>): CheckSelect<T, Prisma__PriceClient<Price | null >, Prisma__PriceClient<PriceGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
    /**
     * Throw an Error if a Subscription can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Subscription to fetch.
     * 
    **/
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
    /**
     * Throw an Error if a Subscription can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Subscription to fetch.
     * 
    **/
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     * 
    **/
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     * 
    **/
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     * 
    **/
    distinct?: Enumerable<SubscriptionScalarFieldEnum>
  }


  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
    /**
     * Filter, which Subscriptions to fetch.
     * 
    **/
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     * 
    **/
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     * 
    **/
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubscriptionScalarFieldEnum>
  }


  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
    /**
     * The data needed to create a Subscription.
     * 
    **/
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }


  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs = {
    data: Enumerable<SubscriptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
    /**
     * The data needed to update a Subscription.
     * 
    **/
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     * 
    **/
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs = {
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    where?: SubscriptionWhereInput
  }


  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     * 
    **/
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     * 
    **/
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }


  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
    /**
     * Filter which Subscription to delete.
     * 
    **/
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs = {
    where?: SubscriptionWhereInput
  }


  /**
   * Subscription without action
   */
  export type SubscriptionArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
  }



  /**
   * Model AppIntegration
   */


  export type AggregateAppIntegration = {
    _count: AppIntegrationCountAggregateOutputType | null
    _min: AppIntegrationMinAggregateOutputType | null
    _max: AppIntegrationMaxAggregateOutputType | null
  }

  export type AppIntegrationMinAggregateOutputType = {
    id: string | null
    name: string | null
    clientId: string | null
    clientKey: string | null
    isEnable: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppIntegrationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    clientId: string | null
    clientKey: string | null
    isEnable: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppIntegrationCountAggregateOutputType = {
    id: number
    name: number
    clientId: number
    clientKey: number
    isEnable: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AppIntegrationMinAggregateInputType = {
    id?: true
    name?: true
    clientId?: true
    clientKey?: true
    isEnable?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppIntegrationMaxAggregateInputType = {
    id?: true
    name?: true
    clientId?: true
    clientKey?: true
    isEnable?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppIntegrationCountAggregateInputType = {
    id?: true
    name?: true
    clientId?: true
    clientKey?: true
    isEnable?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AppIntegrationAggregateArgs = {
    /**
     * Filter which AppIntegration to aggregate.
     * 
    **/
    where?: AppIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppIntegrations to fetch.
     * 
    **/
    orderBy?: Enumerable<AppIntegrationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AppIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppIntegrations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppIntegrations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppIntegrations
    **/
    _count?: true | AppIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppIntegrationMaxAggregateInputType
  }

  export type GetAppIntegrationAggregateType<T extends AppIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateAppIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppIntegration[P]>
      : GetScalarType<T[P], AggregateAppIntegration[P]>
  }




  export type AppIntegrationGroupByArgs = {
    where?: AppIntegrationWhereInput
    orderBy?: Enumerable<AppIntegrationOrderByWithAggregationInput>
    by: Array<AppIntegrationScalarFieldEnum>
    having?: AppIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppIntegrationCountAggregateInputType | true
    _min?: AppIntegrationMinAggregateInputType
    _max?: AppIntegrationMaxAggregateInputType
  }


  export type AppIntegrationGroupByOutputType = {
    id: string
    name: string
    clientId: string
    clientKey: string
    isEnable: boolean
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: AppIntegrationCountAggregateOutputType | null
    _min: AppIntegrationMinAggregateOutputType | null
    _max: AppIntegrationMaxAggregateOutputType | null
  }

  type GetAppIntegrationGroupByPayload<T extends AppIntegrationGroupByArgs> = Promise<
    Array<
      PickArray<AppIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], AppIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type AppIntegrationSelect = {
    id?: boolean
    name?: boolean
    clientId?: boolean
    clientKey?: boolean
    isEnable?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AppIntegrationGetPayload<
    S extends boolean | null | undefined | AppIntegrationArgs,
    U = keyof S
      > = S extends true
        ? AppIntegration
    : S extends undefined
    ? never
    : S extends AppIntegrationArgs | AppIntegrationFindManyArgs
    ?'include' extends U
    ? AppIntegration 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AppIntegration ?AppIntegration [P]
  : 
     never
  } 
    : AppIntegration
  : AppIntegration


  type AppIntegrationCountArgs = Merge<
    Omit<AppIntegrationFindManyArgs, 'select' | 'include'> & {
      select?: AppIntegrationCountAggregateInputType | true
    }
  >

  export interface AppIntegrationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AppIntegration that matches the filter.
     * @param {AppIntegrationFindUniqueArgs} args - Arguments to find a AppIntegration
     * @example
     * // Get one AppIntegration
     * const appIntegration = await prisma.appIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AppIntegrationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AppIntegrationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AppIntegration'> extends True ? CheckSelect<T, Prisma__AppIntegrationClient<AppIntegration>, Prisma__AppIntegrationClient<AppIntegrationGetPayload<T>>> : CheckSelect<T, Prisma__AppIntegrationClient<AppIntegration | null >, Prisma__AppIntegrationClient<AppIntegrationGetPayload<T> | null >>

    /**
     * Find the first AppIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIntegrationFindFirstArgs} args - Arguments to find a AppIntegration
     * @example
     * // Get one AppIntegration
     * const appIntegration = await prisma.appIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AppIntegrationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AppIntegrationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AppIntegration'> extends True ? CheckSelect<T, Prisma__AppIntegrationClient<AppIntegration>, Prisma__AppIntegrationClient<AppIntegrationGetPayload<T>>> : CheckSelect<T, Prisma__AppIntegrationClient<AppIntegration | null >, Prisma__AppIntegrationClient<AppIntegrationGetPayload<T> | null >>

    /**
     * Find zero or more AppIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIntegrationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppIntegrations
     * const appIntegrations = await prisma.appIntegration.findMany()
     * 
     * // Get first 10 AppIntegrations
     * const appIntegrations = await prisma.appIntegration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appIntegrationWithIdOnly = await prisma.appIntegration.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AppIntegrationFindManyArgs>(
      args?: SelectSubset<T, AppIntegrationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AppIntegration>>, PrismaPromise<Array<AppIntegrationGetPayload<T>>>>

    /**
     * Create a AppIntegration.
     * @param {AppIntegrationCreateArgs} args - Arguments to create a AppIntegration.
     * @example
     * // Create one AppIntegration
     * const AppIntegration = await prisma.appIntegration.create({
     *   data: {
     *     // ... data to create a AppIntegration
     *   }
     * })
     * 
    **/
    create<T extends AppIntegrationCreateArgs>(
      args: SelectSubset<T, AppIntegrationCreateArgs>
    ): CheckSelect<T, Prisma__AppIntegrationClient<AppIntegration>, Prisma__AppIntegrationClient<AppIntegrationGetPayload<T>>>

    /**
     * Create many AppIntegrations.
     *     @param {AppIntegrationCreateManyArgs} args - Arguments to create many AppIntegrations.
     *     @example
     *     // Create many AppIntegrations
     *     const appIntegration = await prisma.appIntegration.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AppIntegrationCreateManyArgs>(
      args?: SelectSubset<T, AppIntegrationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AppIntegration.
     * @param {AppIntegrationDeleteArgs} args - Arguments to delete one AppIntegration.
     * @example
     * // Delete one AppIntegration
     * const AppIntegration = await prisma.appIntegration.delete({
     *   where: {
     *     // ... filter to delete one AppIntegration
     *   }
     * })
     * 
    **/
    delete<T extends AppIntegrationDeleteArgs>(
      args: SelectSubset<T, AppIntegrationDeleteArgs>
    ): CheckSelect<T, Prisma__AppIntegrationClient<AppIntegration>, Prisma__AppIntegrationClient<AppIntegrationGetPayload<T>>>

    /**
     * Update one AppIntegration.
     * @param {AppIntegrationUpdateArgs} args - Arguments to update one AppIntegration.
     * @example
     * // Update one AppIntegration
     * const appIntegration = await prisma.appIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AppIntegrationUpdateArgs>(
      args: SelectSubset<T, AppIntegrationUpdateArgs>
    ): CheckSelect<T, Prisma__AppIntegrationClient<AppIntegration>, Prisma__AppIntegrationClient<AppIntegrationGetPayload<T>>>

    /**
     * Delete zero or more AppIntegrations.
     * @param {AppIntegrationDeleteManyArgs} args - Arguments to filter AppIntegrations to delete.
     * @example
     * // Delete a few AppIntegrations
     * const { count } = await prisma.appIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AppIntegrationDeleteManyArgs>(
      args?: SelectSubset<T, AppIntegrationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppIntegrations
     * const appIntegration = await prisma.appIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AppIntegrationUpdateManyArgs>(
      args: SelectSubset<T, AppIntegrationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AppIntegration.
     * @param {AppIntegrationUpsertArgs} args - Arguments to update or create a AppIntegration.
     * @example
     * // Update or create a AppIntegration
     * const appIntegration = await prisma.appIntegration.upsert({
     *   create: {
     *     // ... data to create a AppIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppIntegration we want to update
     *   }
     * })
    **/
    upsert<T extends AppIntegrationUpsertArgs>(
      args: SelectSubset<T, AppIntegrationUpsertArgs>
    ): CheckSelect<T, Prisma__AppIntegrationClient<AppIntegration>, Prisma__AppIntegrationClient<AppIntegrationGetPayload<T>>>

    /**
     * Count the number of AppIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIntegrationCountArgs} args - Arguments to filter AppIntegrations to count.
     * @example
     * // Count the number of AppIntegrations
     * const count = await prisma.appIntegration.count({
     *   where: {
     *     // ... the filter for the AppIntegrations we want to count
     *   }
     * })
    **/
    count<T extends AppIntegrationCountArgs>(
      args?: Subset<T, AppIntegrationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppIntegrationAggregateArgs>(args: Subset<T, AppIntegrationAggregateArgs>): PrismaPromise<GetAppIntegrationAggregateType<T>>

    /**
     * Group by AppIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: AppIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppIntegrationGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AppIntegrationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AppIntegration findUnique
   */
  export type AppIntegrationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AppIntegration
     * 
    **/
    select?: AppIntegrationSelect | null
    /**
     * Throw an Error if a AppIntegration can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AppIntegration to fetch.
     * 
    **/
    where: AppIntegrationWhereUniqueInput
  }


  /**
   * AppIntegration findFirst
   */
  export type AppIntegrationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AppIntegration
     * 
    **/
    select?: AppIntegrationSelect | null
    /**
     * Throw an Error if a AppIntegration can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AppIntegration to fetch.
     * 
    **/
    where?: AppIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppIntegrations to fetch.
     * 
    **/
    orderBy?: Enumerable<AppIntegrationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppIntegrations.
     * 
    **/
    cursor?: AppIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppIntegrations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppIntegrations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppIntegrations.
     * 
    **/
    distinct?: Enumerable<AppIntegrationScalarFieldEnum>
  }


  /**
   * AppIntegration findMany
   */
  export type AppIntegrationFindManyArgs = {
    /**
     * Select specific fields to fetch from the AppIntegration
     * 
    **/
    select?: AppIntegrationSelect | null
    /**
     * Filter, which AppIntegrations to fetch.
     * 
    **/
    where?: AppIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppIntegrations to fetch.
     * 
    **/
    orderBy?: Enumerable<AppIntegrationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppIntegrations.
     * 
    **/
    cursor?: AppIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppIntegrations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppIntegrations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AppIntegrationScalarFieldEnum>
  }


  /**
   * AppIntegration create
   */
  export type AppIntegrationCreateArgs = {
    /**
     * Select specific fields to fetch from the AppIntegration
     * 
    **/
    select?: AppIntegrationSelect | null
    /**
     * The data needed to create a AppIntegration.
     * 
    **/
    data: XOR<AppIntegrationCreateInput, AppIntegrationUncheckedCreateInput>
  }


  /**
   * AppIntegration createMany
   */
  export type AppIntegrationCreateManyArgs = {
    data: Enumerable<AppIntegrationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AppIntegration update
   */
  export type AppIntegrationUpdateArgs = {
    /**
     * Select specific fields to fetch from the AppIntegration
     * 
    **/
    select?: AppIntegrationSelect | null
    /**
     * The data needed to update a AppIntegration.
     * 
    **/
    data: XOR<AppIntegrationUpdateInput, AppIntegrationUncheckedUpdateInput>
    /**
     * Choose, which AppIntegration to update.
     * 
    **/
    where: AppIntegrationWhereUniqueInput
  }


  /**
   * AppIntegration updateMany
   */
  export type AppIntegrationUpdateManyArgs = {
    data: XOR<AppIntegrationUpdateManyMutationInput, AppIntegrationUncheckedUpdateManyInput>
    where?: AppIntegrationWhereInput
  }


  /**
   * AppIntegration upsert
   */
  export type AppIntegrationUpsertArgs = {
    /**
     * Select specific fields to fetch from the AppIntegration
     * 
    **/
    select?: AppIntegrationSelect | null
    /**
     * The filter to search for the AppIntegration to update in case it exists.
     * 
    **/
    where: AppIntegrationWhereUniqueInput
    /**
     * In case the AppIntegration found by the `where` argument doesn't exist, create a new AppIntegration with this data.
     * 
    **/
    create: XOR<AppIntegrationCreateInput, AppIntegrationUncheckedCreateInput>
    /**
     * In case the AppIntegration was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AppIntegrationUpdateInput, AppIntegrationUncheckedUpdateInput>
  }


  /**
   * AppIntegration delete
   */
  export type AppIntegrationDeleteArgs = {
    /**
     * Select specific fields to fetch from the AppIntegration
     * 
    **/
    select?: AppIntegrationSelect | null
    /**
     * Filter which AppIntegration to delete.
     * 
    **/
    where: AppIntegrationWhereUniqueInput
  }


  /**
   * AppIntegration deleteMany
   */
  export type AppIntegrationDeleteManyArgs = {
    where?: AppIntegrationWhereInput
  }


  /**
   * AppIntegration without action
   */
  export type AppIntegrationArgs = {
    /**
     * Select specific fields to fetch from the AppIntegration
     * 
    **/
    select?: AppIntegrationSelect | null
  }



  /**
   * Model AppConfiguration
   */


  export type AggregateAppConfiguration = {
    _count: AppConfigurationCountAggregateOutputType | null
    _min: AppConfigurationMinAggregateOutputType | null
    _max: AppConfigurationMaxAggregateOutputType | null
  }

  export type AppConfigurationMinAggregateOutputType = {
    id: string | null
    name: string | null
    value: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppConfigurationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    value: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppConfigurationCountAggregateOutputType = {
    id: number
    name: number
    value: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AppConfigurationMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppConfigurationMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppConfigurationCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AppConfigurationAggregateArgs = {
    /**
     * Filter which AppConfiguration to aggregate.
     * 
    **/
    where?: AppConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigurations to fetch.
     * 
    **/
    orderBy?: Enumerable<AppConfigurationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AppConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigurations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigurations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppConfigurations
    **/
    _count?: true | AppConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppConfigurationMaxAggregateInputType
  }

  export type GetAppConfigurationAggregateType<T extends AppConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateAppConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppConfiguration[P]>
      : GetScalarType<T[P], AggregateAppConfiguration[P]>
  }




  export type AppConfigurationGroupByArgs = {
    where?: AppConfigurationWhereInput
    orderBy?: Enumerable<AppConfigurationOrderByWithAggregationInput>
    by: Array<AppConfigurationScalarFieldEnum>
    having?: AppConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppConfigurationCountAggregateInputType | true
    _min?: AppConfigurationMinAggregateInputType
    _max?: AppConfigurationMaxAggregateInputType
  }


  export type AppConfigurationGroupByOutputType = {
    id: string
    name: string
    value: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AppConfigurationCountAggregateOutputType | null
    _min: AppConfigurationMinAggregateOutputType | null
    _max: AppConfigurationMaxAggregateOutputType | null
  }

  type GetAppConfigurationGroupByPayload<T extends AppConfigurationGroupByArgs> = Promise<
    Array<
      PickArray<AppConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], AppConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type AppConfigurationSelect = {
    id?: boolean
    name?: boolean
    value?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AppConfigurationGetPayload<
    S extends boolean | null | undefined | AppConfigurationArgs,
    U = keyof S
      > = S extends true
        ? AppConfiguration
    : S extends undefined
    ? never
    : S extends AppConfigurationArgs | AppConfigurationFindManyArgs
    ?'include' extends U
    ? AppConfiguration 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AppConfiguration ?AppConfiguration [P]
  : 
     never
  } 
    : AppConfiguration
  : AppConfiguration


  type AppConfigurationCountArgs = Merge<
    Omit<AppConfigurationFindManyArgs, 'select' | 'include'> & {
      select?: AppConfigurationCountAggregateInputType | true
    }
  >

  export interface AppConfigurationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AppConfiguration that matches the filter.
     * @param {AppConfigurationFindUniqueArgs} args - Arguments to find a AppConfiguration
     * @example
     * // Get one AppConfiguration
     * const appConfiguration = await prisma.appConfiguration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AppConfigurationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AppConfigurationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AppConfiguration'> extends True ? CheckSelect<T, Prisma__AppConfigurationClient<AppConfiguration>, Prisma__AppConfigurationClient<AppConfigurationGetPayload<T>>> : CheckSelect<T, Prisma__AppConfigurationClient<AppConfiguration | null >, Prisma__AppConfigurationClient<AppConfigurationGetPayload<T> | null >>

    /**
     * Find the first AppConfiguration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigurationFindFirstArgs} args - Arguments to find a AppConfiguration
     * @example
     * // Get one AppConfiguration
     * const appConfiguration = await prisma.appConfiguration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AppConfigurationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AppConfigurationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AppConfiguration'> extends True ? CheckSelect<T, Prisma__AppConfigurationClient<AppConfiguration>, Prisma__AppConfigurationClient<AppConfigurationGetPayload<T>>> : CheckSelect<T, Prisma__AppConfigurationClient<AppConfiguration | null >, Prisma__AppConfigurationClient<AppConfigurationGetPayload<T> | null >>

    /**
     * Find zero or more AppConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigurationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppConfigurations
     * const appConfigurations = await prisma.appConfiguration.findMany()
     * 
     * // Get first 10 AppConfigurations
     * const appConfigurations = await prisma.appConfiguration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appConfigurationWithIdOnly = await prisma.appConfiguration.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AppConfigurationFindManyArgs>(
      args?: SelectSubset<T, AppConfigurationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AppConfiguration>>, PrismaPromise<Array<AppConfigurationGetPayload<T>>>>

    /**
     * Create a AppConfiguration.
     * @param {AppConfigurationCreateArgs} args - Arguments to create a AppConfiguration.
     * @example
     * // Create one AppConfiguration
     * const AppConfiguration = await prisma.appConfiguration.create({
     *   data: {
     *     // ... data to create a AppConfiguration
     *   }
     * })
     * 
    **/
    create<T extends AppConfigurationCreateArgs>(
      args: SelectSubset<T, AppConfigurationCreateArgs>
    ): CheckSelect<T, Prisma__AppConfigurationClient<AppConfiguration>, Prisma__AppConfigurationClient<AppConfigurationGetPayload<T>>>

    /**
     * Create many AppConfigurations.
     *     @param {AppConfigurationCreateManyArgs} args - Arguments to create many AppConfigurations.
     *     @example
     *     // Create many AppConfigurations
     *     const appConfiguration = await prisma.appConfiguration.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AppConfigurationCreateManyArgs>(
      args?: SelectSubset<T, AppConfigurationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AppConfiguration.
     * @param {AppConfigurationDeleteArgs} args - Arguments to delete one AppConfiguration.
     * @example
     * // Delete one AppConfiguration
     * const AppConfiguration = await prisma.appConfiguration.delete({
     *   where: {
     *     // ... filter to delete one AppConfiguration
     *   }
     * })
     * 
    **/
    delete<T extends AppConfigurationDeleteArgs>(
      args: SelectSubset<T, AppConfigurationDeleteArgs>
    ): CheckSelect<T, Prisma__AppConfigurationClient<AppConfiguration>, Prisma__AppConfigurationClient<AppConfigurationGetPayload<T>>>

    /**
     * Update one AppConfiguration.
     * @param {AppConfigurationUpdateArgs} args - Arguments to update one AppConfiguration.
     * @example
     * // Update one AppConfiguration
     * const appConfiguration = await prisma.appConfiguration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AppConfigurationUpdateArgs>(
      args: SelectSubset<T, AppConfigurationUpdateArgs>
    ): CheckSelect<T, Prisma__AppConfigurationClient<AppConfiguration>, Prisma__AppConfigurationClient<AppConfigurationGetPayload<T>>>

    /**
     * Delete zero or more AppConfigurations.
     * @param {AppConfigurationDeleteManyArgs} args - Arguments to filter AppConfigurations to delete.
     * @example
     * // Delete a few AppConfigurations
     * const { count } = await prisma.appConfiguration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AppConfigurationDeleteManyArgs>(
      args?: SelectSubset<T, AppConfigurationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppConfigurations
     * const appConfiguration = await prisma.appConfiguration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AppConfigurationUpdateManyArgs>(
      args: SelectSubset<T, AppConfigurationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AppConfiguration.
     * @param {AppConfigurationUpsertArgs} args - Arguments to update or create a AppConfiguration.
     * @example
     * // Update or create a AppConfiguration
     * const appConfiguration = await prisma.appConfiguration.upsert({
     *   create: {
     *     // ... data to create a AppConfiguration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppConfiguration we want to update
     *   }
     * })
    **/
    upsert<T extends AppConfigurationUpsertArgs>(
      args: SelectSubset<T, AppConfigurationUpsertArgs>
    ): CheckSelect<T, Prisma__AppConfigurationClient<AppConfiguration>, Prisma__AppConfigurationClient<AppConfigurationGetPayload<T>>>

    /**
     * Count the number of AppConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigurationCountArgs} args - Arguments to filter AppConfigurations to count.
     * @example
     * // Count the number of AppConfigurations
     * const count = await prisma.appConfiguration.count({
     *   where: {
     *     // ... the filter for the AppConfigurations we want to count
     *   }
     * })
    **/
    count<T extends AppConfigurationCountArgs>(
      args?: Subset<T, AppConfigurationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppConfigurationAggregateArgs>(args: Subset<T, AppConfigurationAggregateArgs>): PrismaPromise<GetAppConfigurationAggregateType<T>>

    /**
     * Group by AppConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: AppConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppConfigurationGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppConfiguration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AppConfigurationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AppConfiguration findUnique
   */
  export type AppConfigurationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AppConfiguration
     * 
    **/
    select?: AppConfigurationSelect | null
    /**
     * Throw an Error if a AppConfiguration can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AppConfiguration to fetch.
     * 
    **/
    where: AppConfigurationWhereUniqueInput
  }


  /**
   * AppConfiguration findFirst
   */
  export type AppConfigurationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AppConfiguration
     * 
    **/
    select?: AppConfigurationSelect | null
    /**
     * Throw an Error if a AppConfiguration can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AppConfiguration to fetch.
     * 
    **/
    where?: AppConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigurations to fetch.
     * 
    **/
    orderBy?: Enumerable<AppConfigurationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppConfigurations.
     * 
    **/
    cursor?: AppConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigurations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigurations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppConfigurations.
     * 
    **/
    distinct?: Enumerable<AppConfigurationScalarFieldEnum>
  }


  /**
   * AppConfiguration findMany
   */
  export type AppConfigurationFindManyArgs = {
    /**
     * Select specific fields to fetch from the AppConfiguration
     * 
    **/
    select?: AppConfigurationSelect | null
    /**
     * Filter, which AppConfigurations to fetch.
     * 
    **/
    where?: AppConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigurations to fetch.
     * 
    **/
    orderBy?: Enumerable<AppConfigurationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppConfigurations.
     * 
    **/
    cursor?: AppConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigurations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigurations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AppConfigurationScalarFieldEnum>
  }


  /**
   * AppConfiguration create
   */
  export type AppConfigurationCreateArgs = {
    /**
     * Select specific fields to fetch from the AppConfiguration
     * 
    **/
    select?: AppConfigurationSelect | null
    /**
     * The data needed to create a AppConfiguration.
     * 
    **/
    data: XOR<AppConfigurationCreateInput, AppConfigurationUncheckedCreateInput>
  }


  /**
   * AppConfiguration createMany
   */
  export type AppConfigurationCreateManyArgs = {
    data: Enumerable<AppConfigurationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AppConfiguration update
   */
  export type AppConfigurationUpdateArgs = {
    /**
     * Select specific fields to fetch from the AppConfiguration
     * 
    **/
    select?: AppConfigurationSelect | null
    /**
     * The data needed to update a AppConfiguration.
     * 
    **/
    data: XOR<AppConfigurationUpdateInput, AppConfigurationUncheckedUpdateInput>
    /**
     * Choose, which AppConfiguration to update.
     * 
    **/
    where: AppConfigurationWhereUniqueInput
  }


  /**
   * AppConfiguration updateMany
   */
  export type AppConfigurationUpdateManyArgs = {
    data: XOR<AppConfigurationUpdateManyMutationInput, AppConfigurationUncheckedUpdateManyInput>
    where?: AppConfigurationWhereInput
  }


  /**
   * AppConfiguration upsert
   */
  export type AppConfigurationUpsertArgs = {
    /**
     * Select specific fields to fetch from the AppConfiguration
     * 
    **/
    select?: AppConfigurationSelect | null
    /**
     * The filter to search for the AppConfiguration to update in case it exists.
     * 
    **/
    where: AppConfigurationWhereUniqueInput
    /**
     * In case the AppConfiguration found by the `where` argument doesn't exist, create a new AppConfiguration with this data.
     * 
    **/
    create: XOR<AppConfigurationCreateInput, AppConfigurationUncheckedCreateInput>
    /**
     * In case the AppConfiguration was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AppConfigurationUpdateInput, AppConfigurationUncheckedUpdateInput>
  }


  /**
   * AppConfiguration delete
   */
  export type AppConfigurationDeleteArgs = {
    /**
     * Select specific fields to fetch from the AppConfiguration
     * 
    **/
    select?: AppConfigurationSelect | null
    /**
     * Filter which AppConfiguration to delete.
     * 
    **/
    where: AppConfigurationWhereUniqueInput
  }


  /**
   * AppConfiguration deleteMany
   */
  export type AppConfigurationDeleteManyArgs = {
    where?: AppConfigurationWhereInput
  }


  /**
   * AppConfiguration without action
   */
  export type AppConfigurationArgs = {
    /**
     * Select specific fields to fetch from the AppConfiguration
     * 
    **/
    select?: AppConfigurationSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    emailVerified: 'emailVerified',
    passwordDigest: 'passwordDigest',
    phoneNumber: 'phoneNumber',
    phoneNumberVerified: 'phoneNumberVerified',
    timeZone: 'timeZone',
    role: 'role',
    bubbleId: 'bubbleId',
    bubbleRole: 'bubbleRole',
    slackPostId: 'slackPostId',
    autoReply: 'autoReply',
    isActive: 'isActive',
    disabledReason: 'disabledReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refreshToken: 'refreshToken',
    accessToken: 'accessToken',
    tokenType: 'tokenType',
    expiresAt: 'expiresAt',
    scope: 'scope',
    idToken: 'idToken',
    sessionState: 'sessionState',
    oauthTokenSecret: 'oauthTokenSecret',
    oauthToken: 'oauthToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    birthDate: 'birthDate',
    profileData: 'profileData',
    picture: 'picture',
    notifyEmail: 'notifyEmail',
    notifyPush: 'notifyPush',
    notifyBadge: 'notifyBadge',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sid: 'sid',
    data: 'data',
    expiresAt: 'expiresAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    botId: 'botId',
    userData: 'userData',
    prompt: 'prompt',
    userId: 'userId',
    isFlagged: 'isFlagged',
    isFinished: 'isFinished',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    input: 'input',
    prompt: 'prompt',
    gptResponse: 'gptResponse',
    isGptFlagged: 'isGptFlagged',
    gptModeration: 'gptModeration',
    isManualResonse: 'isManualResonse',
    userResponse: 'userResponse',
    userModeration: 'userModeration',
    userAllowedByDefense: 'userAllowedByDefense',
    isUserFlagged: 'isUserFlagged',
    userData: 'userData',
    isDeliveredToUser: 'isDeliveredToUser',
    smsSid: 'smsSid',
    shouldFinish: 'shouldFinish',
    tokenUsage: 'tokenUsage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const BotScalarFieldEnum: {
    id: 'id',
    name: 'name',
    model: 'model',
    initialPrompt: 'initialPrompt',
    summarizePrompt: 'summarizePrompt',
    finisherPrompt: 'finisherPrompt',
    temperature: 'temperature',
    max_tokens: 'max_tokens',
    top_p: 'top_p',
    frequency_penalty: 'frequency_penalty',
    presence_penalty: 'presence_penalty',
    best_of: 'best_of',
    stopSequences: 'stopSequences',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BotScalarFieldEnum = (typeof BotScalarFieldEnum)[keyof typeof BotScalarFieldEnum]


  export const UserBotsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    botId: 'botId',
    botSeedData: 'botSeedData',
    nextMessageHour: 'nextMessageHour',
    isFinished: 'isFinished',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserBotsScalarFieldEnum = (typeof UserBotsScalarFieldEnum)[keyof typeof UserBotsScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const PayerScalarFieldEnum: {
    id: 'id',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    stripePriceId: 'stripePriceId',
    stripeCurrentPeriodEnd: 'stripeCurrentPeriodEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PayerScalarFieldEnum = (typeof PayerScalarFieldEnum)[keyof typeof PayerScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    active: 'active',
    name: 'name',
    description: 'description',
    image: 'image',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const PriceScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    active: 'active',
    currency: 'currency',
    interval: 'interval',
    unitAmount: 'unitAmount',
    intervalCount: 'intervalCount',
    trialPeriodDays: 'trialPeriodDays',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PriceScalarFieldEnum = (typeof PriceScalarFieldEnum)[keyof typeof PriceScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    priceId: 'priceId',
    status: 'status',
    startDate: 'startDate',
    endedAt: 'endedAt',
    trialEnd: 'trialEnd',
    trialStart: 'trialStart',
    cancelAt: 'cancelAt',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    canceledAt: 'canceledAt',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const AppIntegrationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    clientId: 'clientId',
    clientKey: 'clientKey',
    isEnable: 'isEnable',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AppIntegrationScalarFieldEnum = (typeof AppIntegrationScalarFieldEnum)[keyof typeof AppIntegrationScalarFieldEnum]


  export const AppConfigurationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AppConfigurationScalarFieldEnum = (typeof AppConfigurationScalarFieldEnum)[keyof typeof AppConfigurationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: 'DbNull',
    JsonNull: 'JsonNull'
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: 'DbNull',
    JsonNull: 'JsonNull',
    AnyNull: 'AnyNull'
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    email?: StringFilter | string
    emailVerified?: DateTimeNullableFilter | Date | string | null
    passwordDigest?: StringNullableFilter | string | null
    phoneNumber?: StringFilter | string
    phoneNumberVerified?: DateTimeNullableFilter | Date | string | null
    timeZone?: StringNullableFilter | string | null
    accounts?: AccountListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    role?: EnumUserRoleFilter | UserRole
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput> | null
    payer?: PayerListRelationFilter
    userBots?: UserBotsListRelationFilter
    bubbleId?: StringNullableFilter | string | null
    bubbleRole?: StringNullableFilter | string | null
    slackPostId?: StringNullableFilter | string | null
    autoReply?: BoolNullableFilter | boolean | null
    isActive?: BoolNullableFilter | boolean | null
    disabledReason?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    conversation?: ConversationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    passwordDigest?: SortOrder
    phoneNumber?: SortOrder
    phoneNumberVerified?: SortOrder
    timeZone?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    role?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    payer?: PayerOrderByRelationAggregateInput
    userBots?: UserBotsOrderByRelationAggregateInput
    bubbleId?: SortOrder
    bubbleRole?: SortOrder
    slackPostId?: SortOrder
    autoReply?: SortOrder
    isActive?: SortOrder
    disabledReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversation?: ConversationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
    phoneNumber?: string
    bubbleId?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    passwordDigest?: SortOrder
    phoneNumber?: SortOrder
    phoneNumberVerified?: SortOrder
    timeZone?: SortOrder
    role?: SortOrder
    bubbleId?: SortOrder
    bubbleRole?: SortOrder
    slackPostId?: SortOrder
    autoReply?: SortOrder
    isActive?: SortOrder
    disabledReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    emailVerified?: DateTimeNullableWithAggregatesFilter | Date | string | null
    passwordDigest?: StringNullableWithAggregatesFilter | string | null
    phoneNumber?: StringWithAggregatesFilter | string
    phoneNumberVerified?: DateTimeNullableWithAggregatesFilter | Date | string | null
    timeZone?: StringNullableWithAggregatesFilter | string | null
    role?: EnumUserRoleWithAggregatesFilter | UserRole
    bubbleId?: StringNullableWithAggregatesFilter | string | null
    bubbleRole?: StringNullableWithAggregatesFilter | string | null
    slackPostId?: StringNullableWithAggregatesFilter | string | null
    autoReply?: BoolNullableWithAggregatesFilter | boolean | null
    isActive?: BoolNullableWithAggregatesFilter | boolean | null
    disabledReason?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AccountWhereInput = {
    AND?: Enumerable<AccountWhereInput>
    OR?: Enumerable<AccountWhereInput>
    NOT?: Enumerable<AccountWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    type?: StringFilter | string
    provider?: StringFilter | string
    providerAccountId?: StringFilter | string
    refreshToken?: StringNullableFilter | string | null
    accessToken?: StringNullableFilter | string | null
    tokenType?: StringNullableFilter | string | null
    expiresAt?: IntNullableFilter | number | null
    scope?: StringNullableFilter | string | null
    idToken?: StringNullableFilter | string | null
    sessionState?: StringNullableFilter | string | null
    oauthTokenSecret?: StringNullableFilter | string | null
    oauthToken?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    tokenType?: SortOrder
    expiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    sessionState?: SortOrder
    oauthTokenSecret?: SortOrder
    oauthToken?: SortOrder
    user?: UserOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountWhereUniqueInput = {
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
  }

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    tokenType?: SortOrder
    expiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    sessionState?: SortOrder
    oauthTokenSecret?: SortOrder
    oauthToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    provider?: StringWithAggregatesFilter | string
    providerAccountId?: StringWithAggregatesFilter | string
    refreshToken?: StringNullableWithAggregatesFilter | string | null
    accessToken?: StringNullableWithAggregatesFilter | string | null
    tokenType?: StringNullableWithAggregatesFilter | string | null
    expiresAt?: IntNullableWithAggregatesFilter | number | null
    scope?: StringNullableWithAggregatesFilter | string | null
    idToken?: StringNullableWithAggregatesFilter | string | null
    sessionState?: StringNullableWithAggregatesFilter | string | null
    oauthTokenSecret?: StringNullableWithAggregatesFilter | string | null
    oauthToken?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProfileWhereInput = {
    AND?: Enumerable<ProfileWhereInput>
    OR?: Enumerable<ProfileWhereInput>
    NOT?: Enumerable<ProfileWhereInput>
    id?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringNullableFilter | string | null
    birthDate?: DateTimeNullableFilter | Date | string | null
    profileData?: JsonNullableFilter
    picture?: StringFilter | string
    notifyEmail?: BoolFilter | boolean
    notifyPush?: BoolFilter | boolean
    notifyBadge?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    profileData?: SortOrder
    picture?: SortOrder
    notifyEmail?: SortOrder
    notifyPush?: SortOrder
    notifyBadge?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileWhereUniqueInput = {
    id?: string
    userId?: string
  }

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    profileData?: SortOrder
    picture?: SortOrder
    notifyEmail?: SortOrder
    notifyPush?: SortOrder
    notifyBadge?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProfileScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProfileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProfileScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringNullableWithAggregatesFilter | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    profileData?: JsonNullableWithAggregatesFilter
    picture?: StringWithAggregatesFilter | string
    notifyEmail?: BoolWithAggregatesFilter | boolean
    notifyPush?: BoolWithAggregatesFilter | boolean
    notifyBadge?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SessionWhereInput = {
    AND?: Enumerable<SessionWhereInput>
    OR?: Enumerable<SessionWhereInput>
    NOT?: Enumerable<SessionWhereInput>
    id?: StringFilter | string
    sid?: StringFilter | string
    data?: StringFilter | string
    expiresAt?: DateTimeFilter | Date | string
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sid?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
  }

  export type SessionWhereUniqueInput = {
    id?: string
    sid?: string
  }

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sid?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SessionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SessionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SessionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    sid?: StringWithAggregatesFilter | string
    data?: StringWithAggregatesFilter | string
    expiresAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ConversationWhereInput = {
    AND?: Enumerable<ConversationWhereInput>
    OR?: Enumerable<ConversationWhereInput>
    NOT?: Enumerable<ConversationWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    bot?: XOR<BotRelationFilter, BotWhereInput> | null
    botId?: StringNullableFilter | string | null
    messages?: MessageListRelationFilter
    userData?: JsonNullableFilter
    prompt?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    isFlagged?: BoolNullableFilter | boolean | null
    isFinished?: BoolNullableFilter | boolean | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    bot?: BotOrderByWithRelationInput
    botId?: SortOrder
    messages?: MessageOrderByRelationAggregateInput
    userData?: SortOrder
    prompt?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
    isFlagged?: SortOrder
    isFinished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationWhereUniqueInput = {
    id?: string
  }

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    botId?: SortOrder
    userData?: SortOrder
    prompt?: SortOrder
    userId?: SortOrder
    isFlagged?: SortOrder
    isFinished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ConversationScalarWhereWithAggregatesInput>
    OR?: Enumerable<ConversationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ConversationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    botId?: StringNullableWithAggregatesFilter | string | null
    userData?: JsonNullableWithAggregatesFilter
    prompt?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    isFlagged?: BoolNullableWithAggregatesFilter | boolean | null
    isFinished?: BoolNullableWithAggregatesFilter | boolean | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MessageWhereInput = {
    AND?: Enumerable<MessageWhereInput>
    OR?: Enumerable<MessageWhereInput>
    NOT?: Enumerable<MessageWhereInput>
    id?: StringFilter | string
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    conversationId?: StringFilter | string
    input?: StringNullableFilter | string | null
    prompt?: StringFilter | string
    gptResponse?: StringNullableFilter | string | null
    isGptFlagged?: BoolNullableFilter | boolean | null
    gptModeration?: StringNullableFilter | string | null
    isManualResonse?: BoolNullableFilter | boolean | null
    userResponse?: StringNullableFilter | string | null
    userModeration?: StringNullableFilter | string | null
    userAllowedByDefense?: BoolNullableFilter | boolean | null
    isUserFlagged?: BoolNullableFilter | boolean | null
    userData?: JsonNullableFilter
    isDeliveredToUser?: DateTimeNullableFilter | Date | string | null
    smsSid?: StringNullableFilter | string | null
    shouldFinish?: BoolNullableFilter | boolean | null
    tokenUsage?: JsonNullableFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    conversationId?: SortOrder
    input?: SortOrder
    prompt?: SortOrder
    gptResponse?: SortOrder
    isGptFlagged?: SortOrder
    gptModeration?: SortOrder
    isManualResonse?: SortOrder
    userResponse?: SortOrder
    userModeration?: SortOrder
    userAllowedByDefense?: SortOrder
    isUserFlagged?: SortOrder
    userData?: SortOrder
    isDeliveredToUser?: SortOrder
    smsSid?: SortOrder
    shouldFinish?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageWhereUniqueInput = {
    id?: string
  }

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    input?: SortOrder
    prompt?: SortOrder
    gptResponse?: SortOrder
    isGptFlagged?: SortOrder
    gptModeration?: SortOrder
    isManualResonse?: SortOrder
    userResponse?: SortOrder
    userModeration?: SortOrder
    userAllowedByDefense?: SortOrder
    isUserFlagged?: SortOrder
    userData?: SortOrder
    isDeliveredToUser?: SortOrder
    smsSid?: SortOrder
    shouldFinish?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<MessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MessageScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    conversationId?: StringWithAggregatesFilter | string
    input?: StringNullableWithAggregatesFilter | string | null
    prompt?: StringWithAggregatesFilter | string
    gptResponse?: StringNullableWithAggregatesFilter | string | null
    isGptFlagged?: BoolNullableWithAggregatesFilter | boolean | null
    gptModeration?: StringNullableWithAggregatesFilter | string | null
    isManualResonse?: BoolNullableWithAggregatesFilter | boolean | null
    userResponse?: StringNullableWithAggregatesFilter | string | null
    userModeration?: StringNullableWithAggregatesFilter | string | null
    userAllowedByDefense?: BoolNullableWithAggregatesFilter | boolean | null
    isUserFlagged?: BoolNullableWithAggregatesFilter | boolean | null
    userData?: JsonNullableWithAggregatesFilter
    isDeliveredToUser?: DateTimeNullableWithAggregatesFilter | Date | string | null
    smsSid?: StringNullableWithAggregatesFilter | string | null
    shouldFinish?: BoolNullableWithAggregatesFilter | boolean | null
    tokenUsage?: JsonNullableWithAggregatesFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BotWhereInput = {
    AND?: Enumerable<BotWhereInput>
    OR?: Enumerable<BotWhereInput>
    NOT?: Enumerable<BotWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    model?: StringFilter | string
    initialPrompt?: StringFilter | string
    summarizePrompt?: StringNullableFilter | string | null
    finisherPrompt?: StringNullableFilter | string | null
    temperature?: DecimalFilter | Decimal | number | string
    max_tokens?: DecimalFilter | Decimal | number | string
    top_p?: DecimalFilter | Decimal | number | string
    frequency_penalty?: DecimalFilter | Decimal | number | string
    presence_penalty?: DecimalFilter | Decimal | number | string
    best_of?: DecimalNullableFilter | Decimal | number | string | null
    stopSequences?: StringNullableListFilter
    conversations?: ConversationListRelationFilter
    userBots?: UserBotsListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BotOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    model?: SortOrder
    initialPrompt?: SortOrder
    summarizePrompt?: SortOrder
    finisherPrompt?: SortOrder
    temperature?: SortOrder
    max_tokens?: SortOrder
    top_p?: SortOrder
    frequency_penalty?: SortOrder
    presence_penalty?: SortOrder
    best_of?: SortOrder
    stopSequences?: SortOrder
    conversations?: ConversationOrderByRelationAggregateInput
    userBots?: UserBotsOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BotWhereUniqueInput = {
    id?: string
  }

  export type BotOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    model?: SortOrder
    initialPrompt?: SortOrder
    summarizePrompt?: SortOrder
    finisherPrompt?: SortOrder
    temperature?: SortOrder
    max_tokens?: SortOrder
    top_p?: SortOrder
    frequency_penalty?: SortOrder
    presence_penalty?: SortOrder
    best_of?: SortOrder
    stopSequences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BotCountOrderByAggregateInput
    _avg?: BotAvgOrderByAggregateInput
    _max?: BotMaxOrderByAggregateInput
    _min?: BotMinOrderByAggregateInput
    _sum?: BotSumOrderByAggregateInput
  }

  export type BotScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BotScalarWhereWithAggregatesInput>
    OR?: Enumerable<BotScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BotScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    model?: StringWithAggregatesFilter | string
    initialPrompt?: StringWithAggregatesFilter | string
    summarizePrompt?: StringNullableWithAggregatesFilter | string | null
    finisherPrompt?: StringNullableWithAggregatesFilter | string | null
    temperature?: DecimalWithAggregatesFilter | Decimal | number | string
    max_tokens?: DecimalWithAggregatesFilter | Decimal | number | string
    top_p?: DecimalWithAggregatesFilter | Decimal | number | string
    frequency_penalty?: DecimalWithAggregatesFilter | Decimal | number | string
    presence_penalty?: DecimalWithAggregatesFilter | Decimal | number | string
    best_of?: DecimalNullableWithAggregatesFilter | Decimal | number | string | null
    stopSequences?: StringNullableListFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserBotsWhereInput = {
    AND?: Enumerable<UserBotsWhereInput>
    OR?: Enumerable<UserBotsWhereInput>
    NOT?: Enumerable<UserBotsWhereInput>
    id?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    bot?: XOR<BotRelationFilter, BotWhereInput>
    botId?: StringFilter | string
    botSeedData?: StringNullableFilter | string | null
    nextMessageHour?: StringNullableFilter | string | null
    isFinished?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserBotsOrderByWithRelationInput = {
    id?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
    bot?: BotOrderByWithRelationInput
    botId?: SortOrder
    botSeedData?: SortOrder
    nextMessageHour?: SortOrder
    isFinished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBotsWhereUniqueInput = {
    id?: string
  }

  export type UserBotsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    botId?: SortOrder
    botSeedData?: SortOrder
    nextMessageHour?: SortOrder
    isFinished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserBotsCountOrderByAggregateInput
    _max?: UserBotsMaxOrderByAggregateInput
    _min?: UserBotsMinOrderByAggregateInput
  }

  export type UserBotsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserBotsScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserBotsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserBotsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    botId?: StringWithAggregatesFilter | string
    botSeedData?: StringNullableWithAggregatesFilter | string | null
    nextMessageHour?: StringNullableWithAggregatesFilter | string | null
    isFinished?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TagWhereInput = {
    AND?: Enumerable<TagWhereInput>
    OR?: Enumerable<TagWhereInput>
    NOT?: Enumerable<TagWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagWhereUniqueInput = {
    id?: string
  }

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TagScalarWhereWithAggregatesInput>
    OR?: Enumerable<TagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TagScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PayerWhereInput = {
    AND?: Enumerable<PayerWhereInput>
    OR?: Enumerable<PayerWhereInput>
    NOT?: Enumerable<PayerWhereInput>
    id?: StringFilter | string
    users?: UserListRelationFilter
    stripeCustomerId?: StringFilter | string
    stripeSubscriptionId?: StringFilter | string
    stripePriceId?: StringFilter | string
    stripeCurrentPeriodEnd?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PayerOrderByWithRelationInput = {
    id?: SortOrder
    users?: UserOrderByRelationAggregateInput
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripePriceId?: SortOrder
    stripeCurrentPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayerWhereUniqueInput = {
    id?: string
    stripeSubscriptionId?: string
  }

  export type PayerOrderByWithAggregationInput = {
    id?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripePriceId?: SortOrder
    stripeCurrentPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PayerCountOrderByAggregateInput
    _max?: PayerMaxOrderByAggregateInput
    _min?: PayerMinOrderByAggregateInput
  }

  export type PayerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PayerScalarWhereWithAggregatesInput>
    OR?: Enumerable<PayerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PayerScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    stripeCustomerId?: StringWithAggregatesFilter | string
    stripeSubscriptionId?: StringWithAggregatesFilter | string
    stripePriceId?: StringWithAggregatesFilter | string
    stripeCurrentPeriodEnd?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProductWhereInput = {
    AND?: Enumerable<ProductWhereInput>
    OR?: Enumerable<ProductWhereInput>
    NOT?: Enumerable<ProductWhereInput>
    id?: StringFilter | string
    active?: BoolFilter | boolean
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    image?: StringNullableFilter | string | null
    metadata?: JsonNullableFilter
    prices?: PriceListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    active?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    metadata?: SortOrder
    prices?: PriceOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductWhereUniqueInput = {
    id?: string
  }

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    active?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    active?: BoolWithAggregatesFilter | boolean
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    image?: StringNullableWithAggregatesFilter | string | null
    metadata?: JsonNullableWithAggregatesFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PriceWhereInput = {
    AND?: Enumerable<PriceWhereInput>
    OR?: Enumerable<PriceWhereInput>
    NOT?: Enumerable<PriceWhereInput>
    id?: StringFilter | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    productId?: StringFilter | string
    active?: BoolFilter | boolean
    currency?: StringFilter | string
    interval?: EnumPriceIntervalNullableFilter | PriceInterval | null
    unitAmount?: DecimalNullableFilter | Decimal | number | string | null
    intervalCount?: IntNullableFilter | number | null
    trialPeriodDays?: IntNullableFilter | number | null
    type?: EnumPriceTypeNullableFilter | PriceType | null
    subscriptions?: SubscriptionListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PriceOrderByWithRelationInput = {
    id?: SortOrder
    product?: ProductOrderByWithRelationInput
    productId?: SortOrder
    active?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    unitAmount?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
    type?: SortOrder
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceWhereUniqueInput = {
    id?: string
  }

  export type PriceOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    active?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    unitAmount?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PriceCountOrderByAggregateInput
    _avg?: PriceAvgOrderByAggregateInput
    _max?: PriceMaxOrderByAggregateInput
    _min?: PriceMinOrderByAggregateInput
    _sum?: PriceSumOrderByAggregateInput
  }

  export type PriceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PriceScalarWhereWithAggregatesInput>
    OR?: Enumerable<PriceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PriceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    productId?: StringWithAggregatesFilter | string
    active?: BoolWithAggregatesFilter | boolean
    currency?: StringWithAggregatesFilter | string
    interval?: EnumPriceIntervalNullableWithAggregatesFilter | PriceInterval | null
    unitAmount?: DecimalNullableWithAggregatesFilter | Decimal | number | string | null
    intervalCount?: IntNullableWithAggregatesFilter | number | null
    trialPeriodDays?: IntNullableWithAggregatesFilter | number | null
    type?: EnumPriceTypeNullableWithAggregatesFilter | PriceType | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: Enumerable<SubscriptionWhereInput>
    OR?: Enumerable<SubscriptionWhereInput>
    NOT?: Enumerable<SubscriptionWhereInput>
    id?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    price?: XOR<PriceRelationFilter, PriceWhereInput> | null
    priceId?: StringNullableFilter | string | null
    status?: EnumSubscriptionStatusFilter | SubscriptionStatus
    startDate?: DateTimeNullableFilter | Date | string | null
    endedAt?: DateTimeNullableFilter | Date | string | null
    trialEnd?: DateTimeNullableFilter | Date | string | null
    trialStart?: DateTimeNullableFilter | Date | string | null
    cancelAt?: DateTimeNullableFilter | Date | string | null
    cancelAtPeriodEnd?: BoolNullableFilter | boolean | null
    canceledAt?: DateTimeNullableFilter | Date | string | null
    metadata?: JsonNullableFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
    price?: PriceOrderByWithRelationInput
    priceId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endedAt?: SortOrder
    trialEnd?: SortOrder
    trialStart?: SortOrder
    cancelAt?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionWhereUniqueInput = {
    id?: string
    userId?: string
  }

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    priceId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endedAt?: SortOrder
    trialEnd?: SortOrder
    trialStart?: SortOrder
    cancelAt?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubscriptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubscriptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubscriptionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    priceId?: StringNullableWithAggregatesFilter | string | null
    status?: EnumSubscriptionStatusWithAggregatesFilter | SubscriptionStatus
    startDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    trialEnd?: DateTimeNullableWithAggregatesFilter | Date | string | null
    trialStart?: DateTimeNullableWithAggregatesFilter | Date | string | null
    cancelAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    cancelAtPeriodEnd?: BoolNullableWithAggregatesFilter | boolean | null
    canceledAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AppIntegrationWhereInput = {
    AND?: Enumerable<AppIntegrationWhereInput>
    OR?: Enumerable<AppIntegrationWhereInput>
    NOT?: Enumerable<AppIntegrationWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    clientId?: StringFilter | string
    clientKey?: StringFilter | string
    isEnable?: BoolFilter | boolean
    expiresAt?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AppIntegrationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    clientId?: SortOrder
    clientKey?: SortOrder
    isEnable?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppIntegrationWhereUniqueInput = {
    id?: string
  }

  export type AppIntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    clientId?: SortOrder
    clientKey?: SortOrder
    isEnable?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AppIntegrationCountOrderByAggregateInput
    _max?: AppIntegrationMaxOrderByAggregateInput
    _min?: AppIntegrationMinOrderByAggregateInput
  }

  export type AppIntegrationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AppIntegrationScalarWhereWithAggregatesInput>
    OR?: Enumerable<AppIntegrationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AppIntegrationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    clientId?: StringWithAggregatesFilter | string
    clientKey?: StringWithAggregatesFilter | string
    isEnable?: BoolWithAggregatesFilter | boolean
    expiresAt?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AppConfigurationWhereInput = {
    AND?: Enumerable<AppConfigurationWhereInput>
    OR?: Enumerable<AppConfigurationWhereInput>
    NOT?: Enumerable<AppConfigurationWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    value?: StringFilter | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AppConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppConfigurationWhereUniqueInput = {
    id?: string
  }

  export type AppConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AppConfigurationCountOrderByAggregateInput
    _max?: AppConfigurationMaxOrderByAggregateInput
    _min?: AppConfigurationMinOrderByAggregateInput
  }

  export type AppConfigurationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AppConfigurationScalarWhereWithAggregatesInput>
    OR?: Enumerable<AppConfigurationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AppConfigurationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    value?: StringWithAggregatesFilter | string
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    timeZone?: string | null
    role?: UserRole
    bubbleId?: string | null
    bubbleRole?: string | null
    slackPostId?: string | null
    autoReply?: boolean | null
    isActive?: boolean | null
    disabledReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    payer?: PayerCreateNestedManyWithoutUsersInput
    userBots?: UserBotsCreateNestedManyWithoutUserInput
    conversation?: ConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    timeZone?: string | null
    role?: UserRole
    bubbleId?: string | null
    bubbleRole?: string | null
    slackPostId?: string | null
    autoReply?: boolean | null
    isActive?: boolean | null
    disabledReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    userBots?: UserBotsUncheckedCreateNestedManyWithoutUserInput
    conversation?: ConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    bubbleId?: NullableStringFieldUpdateOperationsInput | string | null
    bubbleRole?: NullableStringFieldUpdateOperationsInput | string | null
    slackPostId?: NullableStringFieldUpdateOperationsInput | string | null
    autoReply?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disabledReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserInput
    subscriptions?: SubscriptionUpdateManyWithoutUserInput
    profile?: ProfileUpdateOneWithoutUserInput
    payer?: PayerUpdateManyWithoutUsersInput
    userBots?: UserBotsUpdateManyWithoutUserInput
    conversation?: ConversationUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    bubbleId?: NullableStringFieldUpdateOperationsInput | string | null
    bubbleRole?: NullableStringFieldUpdateOperationsInput | string | null
    slackPostId?: NullableStringFieldUpdateOperationsInput | string | null
    autoReply?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disabledReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserInput
    profile?: ProfileUncheckedUpdateOneWithoutUserInput
    userBots?: UserBotsUncheckedUpdateManyWithoutUserInput
    conversation?: ConversationUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    timeZone?: string | null
    role?: UserRole
    bubbleId?: string | null
    bubbleRole?: string | null
    slackPostId?: string | null
    autoReply?: boolean | null
    isActive?: boolean | null
    disabledReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    bubbleId?: NullableStringFieldUpdateOperationsInput | string | null
    bubbleRole?: NullableStringFieldUpdateOperationsInput | string | null
    slackPostId?: NullableStringFieldUpdateOperationsInput | string | null
    autoReply?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disabledReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    bubbleId?: NullableStringFieldUpdateOperationsInput | string | null
    bubbleRole?: NullableStringFieldUpdateOperationsInput | string | null
    slackPostId?: NullableStringFieldUpdateOperationsInput | string | null
    autoReply?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disabledReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    tokenType?: string | null
    expiresAt?: number | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
    oauthTokenSecret?: string | null
    oauthToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    tokenType?: string | null
    expiresAt?: number | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
    oauthTokenSecret?: string | null
    oauthToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    tokenType?: string | null
    expiresAt?: number | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
    oauthTokenSecret?: string | null
    oauthToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    id?: string
    firstName: string
    lastName?: string | null
    birthDate?: Date | string | null
    profileData?: NullableJsonNullValueInput | InputJsonValue
    picture?: string
    notifyEmail?: boolean
    notifyPush?: boolean
    notifyBadge?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    userId: string
    firstName: string
    lastName?: string | null
    birthDate?: Date | string | null
    profileData?: NullableJsonNullValueInput | InputJsonValue
    picture?: string
    notifyEmail?: boolean
    notifyPush?: boolean
    notifyBadge?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileData?: NullableJsonNullValueInput | InputJsonValue
    picture?: StringFieldUpdateOperationsInput | string
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    notifyBadge?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileData?: NullableJsonNullValueInput | InputJsonValue
    picture?: StringFieldUpdateOperationsInput | string
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    notifyBadge?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateManyInput = {
    id?: string
    userId: string
    firstName: string
    lastName?: string | null
    birthDate?: Date | string | null
    profileData?: NullableJsonNullValueInput | InputJsonValue
    picture?: string
    notifyEmail?: boolean
    notifyPush?: boolean
    notifyBadge?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileData?: NullableJsonNullValueInput | InputJsonValue
    picture?: StringFieldUpdateOperationsInput | string
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    notifyBadge?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileData?: NullableJsonNullValueInput | InputJsonValue
    picture?: StringFieldUpdateOperationsInput | string
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    notifyBadge?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id: string
    sid: string
    data: string
    expiresAt?: Date | string
  }

  export type SessionUncheckedCreateInput = {
    id: string
    sid: string
    data: string
    expiresAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id: string
    sid: string
    data: string
    expiresAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateInput = {
    id?: string
    name: string
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt: string
    isFlagged?: boolean | null
    isFinished?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bot?: BotCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    user: UserCreateNestedOneWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    name: string
    botId?: string | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt: string
    userId: string
    isFlagged?: boolean | null
    isFinished?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt?: StringFieldUpdateOperationsInput | string
    isFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFinished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: BotUpdateOneWithoutConversationsInput
    messages?: MessageUpdateManyWithoutConversationInput
    user?: UserUpdateOneRequiredWithoutConversationInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFinished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    name: string
    botId?: string | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt: string
    userId: string
    isFlagged?: boolean | null
    isFinished?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt?: StringFieldUpdateOperationsInput | string
    isFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFinished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFinished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    input?: string | null
    prompt: string
    gptResponse?: string | null
    isGptFlagged?: boolean | null
    gptModeration?: string | null
    isManualResonse?: boolean | null
    userResponse?: string | null
    userModeration?: string | null
    userAllowedByDefense?: boolean | null
    isUserFlagged?: boolean | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    isDeliveredToUser?: Date | string | null
    smsSid?: string | null
    shouldFinish?: boolean | null
    tokenUsage?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    input?: string | null
    prompt: string
    gptResponse?: string | null
    isGptFlagged?: boolean | null
    gptModeration?: string | null
    isManualResonse?: boolean | null
    userResponse?: string | null
    userModeration?: string | null
    userAllowedByDefense?: boolean | null
    isUserFlagged?: boolean | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    isDeliveredToUser?: Date | string | null
    smsSid?: string | null
    shouldFinish?: boolean | null
    tokenUsage?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    input?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    gptResponse?: NullableStringFieldUpdateOperationsInput | string | null
    isGptFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gptModeration?: NullableStringFieldUpdateOperationsInput | string | null
    isManualResonse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userResponse?: NullableStringFieldUpdateOperationsInput | string | null
    userModeration?: NullableStringFieldUpdateOperationsInput | string | null
    userAllowedByDefense?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUserFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    isDeliveredToUser?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    smsSid?: NullableStringFieldUpdateOperationsInput | string | null
    shouldFinish?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tokenUsage?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    input?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    gptResponse?: NullableStringFieldUpdateOperationsInput | string | null
    isGptFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gptModeration?: NullableStringFieldUpdateOperationsInput | string | null
    isManualResonse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userResponse?: NullableStringFieldUpdateOperationsInput | string | null
    userModeration?: NullableStringFieldUpdateOperationsInput | string | null
    userAllowedByDefense?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUserFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    isDeliveredToUser?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    smsSid?: NullableStringFieldUpdateOperationsInput | string | null
    shouldFinish?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tokenUsage?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    conversationId: string
    input?: string | null
    prompt: string
    gptResponse?: string | null
    isGptFlagged?: boolean | null
    gptModeration?: string | null
    isManualResonse?: boolean | null
    userResponse?: string | null
    userModeration?: string | null
    userAllowedByDefense?: boolean | null
    isUserFlagged?: boolean | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    isDeliveredToUser?: Date | string | null
    smsSid?: string | null
    shouldFinish?: boolean | null
    tokenUsage?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    input?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    gptResponse?: NullableStringFieldUpdateOperationsInput | string | null
    isGptFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gptModeration?: NullableStringFieldUpdateOperationsInput | string | null
    isManualResonse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userResponse?: NullableStringFieldUpdateOperationsInput | string | null
    userModeration?: NullableStringFieldUpdateOperationsInput | string | null
    userAllowedByDefense?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUserFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    isDeliveredToUser?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    smsSid?: NullableStringFieldUpdateOperationsInput | string | null
    shouldFinish?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tokenUsage?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    input?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    gptResponse?: NullableStringFieldUpdateOperationsInput | string | null
    isGptFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gptModeration?: NullableStringFieldUpdateOperationsInput | string | null
    isManualResonse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userResponse?: NullableStringFieldUpdateOperationsInput | string | null
    userModeration?: NullableStringFieldUpdateOperationsInput | string | null
    userAllowedByDefense?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUserFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    isDeliveredToUser?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    smsSid?: NullableStringFieldUpdateOperationsInput | string | null
    shouldFinish?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tokenUsage?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotCreateInput = {
    id?: string
    name: string
    model?: string
    initialPrompt: string
    summarizePrompt?: string | null
    finisherPrompt?: string | null
    temperature?: Decimal | number | string
    max_tokens?: Decimal | number | string
    top_p?: Decimal | number | string
    frequency_penalty?: Decimal | number | string
    presence_penalty?: Decimal | number | string
    best_of?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stopSequences?: BotCreatestopSequencesInput | Enumerable<string>
    conversations?: ConversationCreateNestedManyWithoutBotInput
    userBots?: UserBotsCreateNestedManyWithoutBotInput
  }

  export type BotUncheckedCreateInput = {
    id?: string
    name: string
    model?: string
    initialPrompt: string
    summarizePrompt?: string | null
    finisherPrompt?: string | null
    temperature?: Decimal | number | string
    max_tokens?: Decimal | number | string
    top_p?: Decimal | number | string
    frequency_penalty?: Decimal | number | string
    presence_penalty?: Decimal | number | string
    best_of?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stopSequences?: BotCreatestopSequencesInput | Enumerable<string>
    conversations?: ConversationUncheckedCreateNestedManyWithoutBotInput
    userBots?: UserBotsUncheckedCreateNestedManyWithoutBotInput
  }

  export type BotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    initialPrompt?: StringFieldUpdateOperationsInput | string
    summarizePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    finisherPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_tokens?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    top_p?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    frequency_penalty?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    presence_penalty?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    best_of?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stopSequences?: BotUpdatestopSequencesInput | Enumerable<string>
    conversations?: ConversationUpdateManyWithoutBotInput
    userBots?: UserBotsUpdateManyWithoutBotInput
  }

  export type BotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    initialPrompt?: StringFieldUpdateOperationsInput | string
    summarizePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    finisherPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_tokens?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    top_p?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    frequency_penalty?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    presence_penalty?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    best_of?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stopSequences?: BotUpdatestopSequencesInput | Enumerable<string>
    conversations?: ConversationUncheckedUpdateManyWithoutBotInput
    userBots?: UserBotsUncheckedUpdateManyWithoutBotInput
  }

  export type BotCreateManyInput = {
    id?: string
    name: string
    model?: string
    initialPrompt: string
    summarizePrompt?: string | null
    finisherPrompt?: string | null
    temperature?: Decimal | number | string
    max_tokens?: Decimal | number | string
    top_p?: Decimal | number | string
    frequency_penalty?: Decimal | number | string
    presence_penalty?: Decimal | number | string
    best_of?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stopSequences?: BotCreateManystopSequencesInput | Enumerable<string>
  }

  export type BotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    initialPrompt?: StringFieldUpdateOperationsInput | string
    summarizePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    finisherPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_tokens?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    top_p?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    frequency_penalty?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    presence_penalty?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    best_of?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stopSequences?: BotUpdatestopSequencesInput | Enumerable<string>
  }

  export type BotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    initialPrompt?: StringFieldUpdateOperationsInput | string
    summarizePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    finisherPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_tokens?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    top_p?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    frequency_penalty?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    presence_penalty?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    best_of?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stopSequences?: BotUpdatestopSequencesInput | Enumerable<string>
  }

  export type UserBotsCreateInput = {
    id?: string
    botSeedData?: string | null
    nextMessageHour?: string | null
    isFinished?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserBotsInput
    bot: BotCreateNestedOneWithoutUserBotsInput
  }

  export type UserBotsUncheckedCreateInput = {
    id?: string
    userId: string
    botId: string
    botSeedData?: string | null
    nextMessageHour?: string | null
    isFinished?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBotsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    botSeedData?: NullableStringFieldUpdateOperationsInput | string | null
    nextMessageHour?: NullableStringFieldUpdateOperationsInput | string | null
    isFinished?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserBotsInput
    bot?: BotUpdateOneRequiredWithoutUserBotsInput
  }

  export type UserBotsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    botSeedData?: NullableStringFieldUpdateOperationsInput | string | null
    nextMessageHour?: NullableStringFieldUpdateOperationsInput | string | null
    isFinished?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBotsCreateManyInput = {
    id?: string
    userId: string
    botId: string
    botSeedData?: string | null
    nextMessageHour?: string | null
    isFinished?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBotsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    botSeedData?: NullableStringFieldUpdateOperationsInput | string | null
    nextMessageHour?: NullableStringFieldUpdateOperationsInput | string | null
    isFinished?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBotsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    botSeedData?: NullableStringFieldUpdateOperationsInput | string | null
    nextMessageHour?: NullableStringFieldUpdateOperationsInput | string | null
    isFinished?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayerCreateInput = {
    id?: string
    stripeCustomerId: string
    stripeSubscriptionId: string
    stripePriceId: string
    stripeCurrentPeriodEnd: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutPayerInput
  }

  export type PayerUncheckedCreateInput = {
    id?: string
    stripeCustomerId: string
    stripeSubscriptionId: string
    stripePriceId: string
    stripeCurrentPeriodEnd: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    stripeCurrentPeriodEnd?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutPayerInput
  }

  export type PayerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    stripeCurrentPeriodEnd?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayerCreateManyInput = {
    id?: string
    stripeCustomerId: string
    stripeSubscriptionId: string
    stripePriceId: string
    stripeCurrentPeriodEnd: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    stripeCurrentPeriodEnd?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    stripeCurrentPeriodEnd?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    active?: boolean
    name: string
    description?: string | null
    image?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    prices?: PriceCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    active?: boolean
    name: string
    description?: string | null
    image?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    prices?: PriceUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: PriceUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prices?: PriceUncheckedUpdateManyWithoutProductInput
  }

  export type ProductCreateManyInput = {
    id?: string
    active?: boolean
    name: string
    description?: string | null
    image?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceCreateInput = {
    id?: string
    active?: boolean
    currency: string
    interval?: PriceInterval | null
    unitAmount?: Decimal | number | string | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    type?: PriceType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutPricesInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPriceInput
  }

  export type PriceUncheckedCreateInput = {
    id?: string
    productId: string
    active?: boolean
    currency: string
    interval?: PriceInterval | null
    unitAmount?: Decimal | number | string | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    type?: PriceType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPriceInput
  }

  export type PriceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    currency?: StringFieldUpdateOperationsInput | string
    interval?: NullableEnumPriceIntervalFieldUpdateOperationsInput | PriceInterval | null
    unitAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableEnumPriceTypeFieldUpdateOperationsInput | PriceType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutPricesInput
    subscriptions?: SubscriptionUpdateManyWithoutPriceInput
  }

  export type PriceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    currency?: StringFieldUpdateOperationsInput | string
    interval?: NullableEnumPriceIntervalFieldUpdateOperationsInput | PriceInterval | null
    unitAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableEnumPriceTypeFieldUpdateOperationsInput | PriceType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPriceInput
  }

  export type PriceCreateManyInput = {
    id?: string
    productId: string
    active?: boolean
    currency: string
    interval?: PriceInterval | null
    unitAmount?: Decimal | number | string | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    type?: PriceType | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    currency?: StringFieldUpdateOperationsInput | string
    interval?: NullableEnumPriceIntervalFieldUpdateOperationsInput | PriceInterval | null
    unitAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableEnumPriceTypeFieldUpdateOperationsInput | PriceType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    currency?: StringFieldUpdateOperationsInput | string
    interval?: NullableEnumPriceIntervalFieldUpdateOperationsInput | PriceInterval | null
    unitAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableEnumPriceTypeFieldUpdateOperationsInput | PriceType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    status: SubscriptionStatus
    startDate?: Date | string | null
    endedAt?: Date | string | null
    trialEnd?: Date | string | null
    trialStart?: Date | string | null
    cancelAt?: Date | string | null
    cancelAtPeriodEnd?: boolean | null
    canceledAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionsInput
    price?: PriceCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    priceId?: string | null
    status: SubscriptionStatus
    startDate?: Date | string | null
    endedAt?: Date | string | null
    trialEnd?: Date | string | null
    trialStart?: Date | string | null
    cancelAt?: Date | string | null
    cancelAtPeriodEnd?: boolean | null
    canceledAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: NullableBoolFieldUpdateOperationsInput | boolean | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionsInput
    price?: PriceUpdateOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: NullableBoolFieldUpdateOperationsInput | boolean | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    userId: string
    priceId?: string | null
    status: SubscriptionStatus
    startDate?: Date | string | null
    endedAt?: Date | string | null
    trialEnd?: Date | string | null
    trialStart?: Date | string | null
    cancelAt?: Date | string | null
    cancelAtPeriodEnd?: boolean | null
    canceledAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: NullableBoolFieldUpdateOperationsInput | boolean | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: NullableBoolFieldUpdateOperationsInput | boolean | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppIntegrationCreateInput = {
    id?: string
    name: string
    clientId: string
    clientKey: string
    isEnable?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppIntegrationUncheckedCreateInput = {
    id?: string
    name: string
    clientId: string
    clientKey: string
    isEnable?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppIntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientKey?: StringFieldUpdateOperationsInput | string
    isEnable?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppIntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientKey?: StringFieldUpdateOperationsInput | string
    isEnable?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppIntegrationCreateManyInput = {
    id?: string
    name: string
    clientId: string
    clientKey: string
    isEnable?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppIntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientKey?: StringFieldUpdateOperationsInput | string
    isEnable?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppIntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientKey?: StringFieldUpdateOperationsInput | string
    isEnable?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppConfigurationCreateInput = {
    id?: string
    name: string
    value: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppConfigurationUncheckedCreateInput = {
    id?: string
    name: string
    value: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppConfigurationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppConfigurationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppConfigurationCreateManyInput = {
    id?: string
    name: string
    value: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppConfigurationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppConfigurationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type EnumUserRoleFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleFilter | UserRole
  }

  export type ProfileRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type PayerListRelationFilter = {
    every?: PayerWhereInput
    some?: PayerWhereInput
    none?: PayerWhereInput
  }

  export type UserBotsListRelationFilter = {
    every?: UserBotsWhereInput
    some?: UserBotsWhereInput
    none?: UserBotsWhereInput
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBotsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    passwordDigest?: SortOrder
    phoneNumber?: SortOrder
    phoneNumberVerified?: SortOrder
    timeZone?: SortOrder
    role?: SortOrder
    bubbleId?: SortOrder
    bubbleRole?: SortOrder
    slackPostId?: SortOrder
    autoReply?: SortOrder
    isActive?: SortOrder
    disabledReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    passwordDigest?: SortOrder
    phoneNumber?: SortOrder
    phoneNumberVerified?: SortOrder
    timeZone?: SortOrder
    role?: SortOrder
    bubbleId?: SortOrder
    bubbleRole?: SortOrder
    slackPostId?: SortOrder
    autoReply?: SortOrder
    isActive?: SortOrder
    disabledReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    passwordDigest?: SortOrder
    phoneNumber?: SortOrder
    phoneNumberVerified?: SortOrder
    timeZone?: SortOrder
    role?: SortOrder
    bubbleId?: SortOrder
    bubbleRole?: SortOrder
    slackPostId?: SortOrder
    autoReply?: SortOrder
    isActive?: SortOrder
    disabledReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type EnumUserRoleWithAggregatesFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleWithAggregatesFilter | UserRole
    _count?: NestedIntFilter
    _min?: NestedEnumUserRoleFilter
    _max?: NestedEnumUserRoleFilter
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    tokenType?: SortOrder
    expiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    sessionState?: SortOrder
    oauthTokenSecret?: SortOrder
    oauthToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expiresAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    tokenType?: SortOrder
    expiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    sessionState?: SortOrder
    oauthTokenSecret?: SortOrder
    oauthToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    tokenType?: SortOrder
    expiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    sessionState?: SortOrder
    oauthTokenSecret?: SortOrder
    oauthToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expiresAt?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    profileData?: SortOrder
    picture?: SortOrder
    notifyEmail?: SortOrder
    notifyPush?: SortOrder
    notifyBadge?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    picture?: SortOrder
    notifyEmail?: SortOrder
    notifyPush?: SortOrder
    notifyBadge?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    picture?: SortOrder
    notifyEmail?: SortOrder
    notifyPush?: SortOrder
    notifyBadge?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sid?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sid?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sid?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
  }

  export type BotRelationFilter = {
    is?: BotWhereInput | null
    isNot?: BotWhereInput | null
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    botId?: SortOrder
    userData?: SortOrder
    prompt?: SortOrder
    userId?: SortOrder
    isFlagged?: SortOrder
    isFinished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    botId?: SortOrder
    prompt?: SortOrder
    userId?: SortOrder
    isFlagged?: SortOrder
    isFinished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    botId?: SortOrder
    prompt?: SortOrder
    userId?: SortOrder
    isFlagged?: SortOrder
    isFinished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    input?: SortOrder
    prompt?: SortOrder
    gptResponse?: SortOrder
    isGptFlagged?: SortOrder
    gptModeration?: SortOrder
    isManualResonse?: SortOrder
    userResponse?: SortOrder
    userModeration?: SortOrder
    userAllowedByDefense?: SortOrder
    isUserFlagged?: SortOrder
    userData?: SortOrder
    isDeliveredToUser?: SortOrder
    smsSid?: SortOrder
    shouldFinish?: SortOrder
    tokenUsage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    input?: SortOrder
    prompt?: SortOrder
    gptResponse?: SortOrder
    isGptFlagged?: SortOrder
    gptModeration?: SortOrder
    isManualResonse?: SortOrder
    userResponse?: SortOrder
    userModeration?: SortOrder
    userAllowedByDefense?: SortOrder
    isUserFlagged?: SortOrder
    isDeliveredToUser?: SortOrder
    smsSid?: SortOrder
    shouldFinish?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    input?: SortOrder
    prompt?: SortOrder
    gptResponse?: SortOrder
    isGptFlagged?: SortOrder
    gptModeration?: SortOrder
    isManualResonse?: SortOrder
    userResponse?: SortOrder
    userModeration?: SortOrder
    userAllowedByDefense?: SortOrder
    isUserFlagged?: SortOrder
    isDeliveredToUser?: SortOrder
    smsSid?: SortOrder
    shouldFinish?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DecimalFilter = {
    equals?: Decimal | number | string
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalFilter | Decimal | number | string
  }

  export type DecimalNullableFilter = {
    equals?: Decimal | number | string | null
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalNullableFilter | Decimal | number | string | null
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type BotCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    model?: SortOrder
    initialPrompt?: SortOrder
    summarizePrompt?: SortOrder
    finisherPrompt?: SortOrder
    temperature?: SortOrder
    max_tokens?: SortOrder
    top_p?: SortOrder
    frequency_penalty?: SortOrder
    presence_penalty?: SortOrder
    best_of?: SortOrder
    stopSequences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BotAvgOrderByAggregateInput = {
    temperature?: SortOrder
    max_tokens?: SortOrder
    top_p?: SortOrder
    frequency_penalty?: SortOrder
    presence_penalty?: SortOrder
    best_of?: SortOrder
  }

  export type BotMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    model?: SortOrder
    initialPrompt?: SortOrder
    summarizePrompt?: SortOrder
    finisherPrompt?: SortOrder
    temperature?: SortOrder
    max_tokens?: SortOrder
    top_p?: SortOrder
    frequency_penalty?: SortOrder
    presence_penalty?: SortOrder
    best_of?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BotMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    model?: SortOrder
    initialPrompt?: SortOrder
    summarizePrompt?: SortOrder
    finisherPrompt?: SortOrder
    temperature?: SortOrder
    max_tokens?: SortOrder
    top_p?: SortOrder
    frequency_penalty?: SortOrder
    presence_penalty?: SortOrder
    best_of?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BotSumOrderByAggregateInput = {
    temperature?: SortOrder
    max_tokens?: SortOrder
    top_p?: SortOrder
    frequency_penalty?: SortOrder
    presence_penalty?: SortOrder
    best_of?: SortOrder
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | number | string
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type DecimalNullableWithAggregatesFilter = {
    equals?: Decimal | number | string | null
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type UserBotsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    botId?: SortOrder
    botSeedData?: SortOrder
    nextMessageHour?: SortOrder
    isFinished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBotsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    botId?: SortOrder
    botSeedData?: SortOrder
    nextMessageHour?: SortOrder
    isFinished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBotsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    botId?: SortOrder
    botSeedData?: SortOrder
    nextMessageHour?: SortOrder
    isFinished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayerCountOrderByAggregateInput = {
    id?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripePriceId?: SortOrder
    stripeCurrentPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayerMaxOrderByAggregateInput = {
    id?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripePriceId?: SortOrder
    stripeCurrentPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayerMinOrderByAggregateInput = {
    id?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripePriceId?: SortOrder
    stripeCurrentPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceListRelationFilter = {
    every?: PriceWhereInput
    some?: PriceWhereInput
    none?: PriceWhereInput
  }

  export type PriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    active?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    active?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    active?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type EnumPriceIntervalNullableFilter = {
    equals?: PriceInterval | null
    in?: Enumerable<PriceInterval> | null
    notIn?: Enumerable<PriceInterval> | null
    not?: NestedEnumPriceIntervalNullableFilter | PriceInterval | null
  }

  export type EnumPriceTypeNullableFilter = {
    equals?: PriceType | null
    in?: Enumerable<PriceType> | null
    notIn?: Enumerable<PriceType> | null
    not?: NestedEnumPriceTypeNullableFilter | PriceType | null
  }

  export type PriceCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    active?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    unitAmount?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceAvgOrderByAggregateInput = {
    unitAmount?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
  }

  export type PriceMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    active?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    unitAmount?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    active?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    unitAmount?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceSumOrderByAggregateInput = {
    unitAmount?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
  }

  export type EnumPriceIntervalNullableWithAggregatesFilter = {
    equals?: PriceInterval | null
    in?: Enumerable<PriceInterval> | null
    notIn?: Enumerable<PriceInterval> | null
    not?: NestedEnumPriceIntervalNullableWithAggregatesFilter | PriceInterval | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumPriceIntervalNullableFilter
    _max?: NestedEnumPriceIntervalNullableFilter
  }

  export type EnumPriceTypeNullableWithAggregatesFilter = {
    equals?: PriceType | null
    in?: Enumerable<PriceType> | null
    notIn?: Enumerable<PriceType> | null
    not?: NestedEnumPriceTypeNullableWithAggregatesFilter | PriceType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumPriceTypeNullableFilter
    _max?: NestedEnumPriceTypeNullableFilter
  }

  export type PriceRelationFilter = {
    is?: PriceWhereInput | null
    isNot?: PriceWhereInput | null
  }

  export type EnumSubscriptionStatusFilter = {
    equals?: SubscriptionStatus
    in?: Enumerable<SubscriptionStatus>
    notIn?: Enumerable<SubscriptionStatus>
    not?: NestedEnumSubscriptionStatusFilter | SubscriptionStatus
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    priceId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endedAt?: SortOrder
    trialEnd?: SortOrder
    trialStart?: SortOrder
    cancelAt?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    priceId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endedAt?: SortOrder
    trialEnd?: SortOrder
    trialStart?: SortOrder
    cancelAt?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    priceId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endedAt?: SortOrder
    trialEnd?: SortOrder
    trialStart?: SortOrder
    cancelAt?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter = {
    equals?: SubscriptionStatus
    in?: Enumerable<SubscriptionStatus>
    notIn?: Enumerable<SubscriptionStatus>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter | SubscriptionStatus
    _count?: NestedIntFilter
    _min?: NestedEnumSubscriptionStatusFilter
    _max?: NestedEnumSubscriptionStatusFilter
  }

  export type AppIntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    clientId?: SortOrder
    clientKey?: SortOrder
    isEnable?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppIntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    clientId?: SortOrder
    clientKey?: SortOrder
    isEnable?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppIntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    clientId?: SortOrder
    clientKey?: SortOrder
    isEnable?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type SubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutUserInput>, Enumerable<SubscriptionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutUserInput>
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: Enumerable<SubscriptionWhereUniqueInput>
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type PayerCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<PayerCreateWithoutUsersInput>, Enumerable<PayerUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<PayerCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<PayerWhereUniqueInput>
  }

  export type UserBotsCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserBotsCreateWithoutUserInput>, Enumerable<UserBotsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserBotsCreateOrConnectWithoutUserInput>
    createMany?: UserBotsCreateManyUserInputEnvelope
    connect?: Enumerable<UserBotsWhereUniqueInput>
  }

  export type ConversationCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ConversationCreateWithoutUserInput>, Enumerable<ConversationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ConversationCreateOrConnectWithoutUserInput>
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: Enumerable<ConversationWhereUniqueInput>
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutUserInput>, Enumerable<SubscriptionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutUserInput>
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: Enumerable<SubscriptionWhereUniqueInput>
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type UserBotsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserBotsCreateWithoutUserInput>, Enumerable<UserBotsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserBotsCreateOrConnectWithoutUserInput>
    createMany?: UserBotsCreateManyUserInputEnvelope
    connect?: Enumerable<UserBotsWhereUniqueInput>
  }

  export type ConversationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ConversationCreateWithoutUserInput>, Enumerable<ConversationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ConversationCreateOrConnectWithoutUserInput>
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: Enumerable<ConversationWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: UserRole
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AccountUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type SubscriptionUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutUserInput>, Enumerable<SubscriptionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SubscriptionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: Enumerable<SubscriptionWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionWhereUniqueInput>
    delete?: Enumerable<SubscriptionWhereUniqueInput>
    connect?: Enumerable<SubscriptionWhereUniqueInput>
    update?: Enumerable<SubscriptionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SubscriptionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SubscriptionScalarWhereInput>
  }

  export type ProfileUpdateOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type PayerUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<PayerCreateWithoutUsersInput>, Enumerable<PayerUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<PayerCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<PayerUpsertWithWhereUniqueWithoutUsersInput>
    set?: Enumerable<PayerWhereUniqueInput>
    disconnect?: Enumerable<PayerWhereUniqueInput>
    delete?: Enumerable<PayerWhereUniqueInput>
    connect?: Enumerable<PayerWhereUniqueInput>
    update?: Enumerable<PayerUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<PayerUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<PayerScalarWhereInput>
  }

  export type UserBotsUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserBotsCreateWithoutUserInput>, Enumerable<UserBotsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserBotsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserBotsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserBotsCreateManyUserInputEnvelope
    set?: Enumerable<UserBotsWhereUniqueInput>
    disconnect?: Enumerable<UserBotsWhereUniqueInput>
    delete?: Enumerable<UserBotsWhereUniqueInput>
    connect?: Enumerable<UserBotsWhereUniqueInput>
    update?: Enumerable<UserBotsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserBotsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserBotsScalarWhereInput>
  }

  export type ConversationUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ConversationCreateWithoutUserInput>, Enumerable<ConversationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ConversationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ConversationUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: Enumerable<ConversationWhereUniqueInput>
    disconnect?: Enumerable<ConversationWhereUniqueInput>
    delete?: Enumerable<ConversationWhereUniqueInput>
    connect?: Enumerable<ConversationWhereUniqueInput>
    update?: Enumerable<ConversationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ConversationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ConversationScalarWhereInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutUserInput>, Enumerable<SubscriptionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SubscriptionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: Enumerable<SubscriptionWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionWhereUniqueInput>
    delete?: Enumerable<SubscriptionWhereUniqueInput>
    connect?: Enumerable<SubscriptionWhereUniqueInput>
    update?: Enumerable<SubscriptionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SubscriptionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SubscriptionScalarWhereInput>
  }

  export type ProfileUncheckedUpdateOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserBotsUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserBotsCreateWithoutUserInput>, Enumerable<UserBotsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserBotsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserBotsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserBotsCreateManyUserInputEnvelope
    set?: Enumerable<UserBotsWhereUniqueInput>
    disconnect?: Enumerable<UserBotsWhereUniqueInput>
    delete?: Enumerable<UserBotsWhereUniqueInput>
    connect?: Enumerable<UserBotsWhereUniqueInput>
    update?: Enumerable<UserBotsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserBotsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserBotsScalarWhereInput>
  }

  export type ConversationUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ConversationCreateWithoutUserInput>, Enumerable<ConversationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ConversationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ConversationUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: Enumerable<ConversationWhereUniqueInput>
    disconnect?: Enumerable<ConversationWhereUniqueInput>
    delete?: Enumerable<ConversationWhereUniqueInput>
    connect?: Enumerable<ConversationWhereUniqueInput>
    update?: Enumerable<ConversationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ConversationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ConversationScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type BotCreateNestedOneWithoutConversationsInput = {
    create?: XOR<BotCreateWithoutConversationsInput, BotUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: BotCreateOrConnectWithoutConversationsInput
    connect?: BotWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<Enumerable<MessageCreateWithoutConversationInput>, Enumerable<MessageUncheckedCreateWithoutConversationInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutConversationInput>
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutConversationInput = {
    create?: XOR<UserCreateWithoutConversationInput, UserUncheckedCreateWithoutConversationInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationInput
    connect?: UserWhereUniqueInput
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<Enumerable<MessageCreateWithoutConversationInput>, Enumerable<MessageUncheckedCreateWithoutConversationInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutConversationInput>
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type BotUpdateOneWithoutConversationsInput = {
    create?: XOR<BotCreateWithoutConversationsInput, BotUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: BotCreateOrConnectWithoutConversationsInput
    upsert?: BotUpsertWithoutConversationsInput
    disconnect?: boolean
    delete?: boolean
    connect?: BotWhereUniqueInput
    update?: XOR<BotUpdateWithoutConversationsInput, BotUncheckedUpdateWithoutConversationsInput>
  }

  export type MessageUpdateManyWithoutConversationInput = {
    create?: XOR<Enumerable<MessageCreateWithoutConversationInput>, Enumerable<MessageUncheckedCreateWithoutConversationInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutConversationInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutConversationInput>
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    connect?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutConversationInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutConversationInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type UserUpdateOneRequiredWithoutConversationInput = {
    create?: XOR<UserCreateWithoutConversationInput, UserUncheckedCreateWithoutConversationInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationInput
    upsert?: UserUpsertWithoutConversationInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutConversationInput, UserUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    create?: XOR<Enumerable<MessageCreateWithoutConversationInput>, Enumerable<MessageUncheckedCreateWithoutConversationInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutConversationInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutConversationInput>
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    connect?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutConversationInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutConversationInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type BotCreatestopSequencesInput = {
    set: Enumerable<string>
  }

  export type ConversationCreateNestedManyWithoutBotInput = {
    create?: XOR<Enumerable<ConversationCreateWithoutBotInput>, Enumerable<ConversationUncheckedCreateWithoutBotInput>>
    connectOrCreate?: Enumerable<ConversationCreateOrConnectWithoutBotInput>
    createMany?: ConversationCreateManyBotInputEnvelope
    connect?: Enumerable<ConversationWhereUniqueInput>
  }

  export type UserBotsCreateNestedManyWithoutBotInput = {
    create?: XOR<Enumerable<UserBotsCreateWithoutBotInput>, Enumerable<UserBotsUncheckedCreateWithoutBotInput>>
    connectOrCreate?: Enumerable<UserBotsCreateOrConnectWithoutBotInput>
    createMany?: UserBotsCreateManyBotInputEnvelope
    connect?: Enumerable<UserBotsWhereUniqueInput>
  }

  export type ConversationUncheckedCreateNestedManyWithoutBotInput = {
    create?: XOR<Enumerable<ConversationCreateWithoutBotInput>, Enumerable<ConversationUncheckedCreateWithoutBotInput>>
    connectOrCreate?: Enumerable<ConversationCreateOrConnectWithoutBotInput>
    createMany?: ConversationCreateManyBotInputEnvelope
    connect?: Enumerable<ConversationWhereUniqueInput>
  }

  export type UserBotsUncheckedCreateNestedManyWithoutBotInput = {
    create?: XOR<Enumerable<UserBotsCreateWithoutBotInput>, Enumerable<UserBotsUncheckedCreateWithoutBotInput>>
    connectOrCreate?: Enumerable<UserBotsCreateOrConnectWithoutBotInput>
    createMany?: UserBotsCreateManyBotInputEnvelope
    connect?: Enumerable<UserBotsWhereUniqueInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | number | string
    increment?: Decimal | number | string
    decrement?: Decimal | number | string
    multiply?: Decimal | number | string
    divide?: Decimal | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | number | string | null
    increment?: Decimal | number | string
    decrement?: Decimal | number | string
    multiply?: Decimal | number | string
    divide?: Decimal | number | string
  }

  export type BotUpdatestopSequencesInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ConversationUpdateManyWithoutBotInput = {
    create?: XOR<Enumerable<ConversationCreateWithoutBotInput>, Enumerable<ConversationUncheckedCreateWithoutBotInput>>
    connectOrCreate?: Enumerable<ConversationCreateOrConnectWithoutBotInput>
    upsert?: Enumerable<ConversationUpsertWithWhereUniqueWithoutBotInput>
    createMany?: ConversationCreateManyBotInputEnvelope
    set?: Enumerable<ConversationWhereUniqueInput>
    disconnect?: Enumerable<ConversationWhereUniqueInput>
    delete?: Enumerable<ConversationWhereUniqueInput>
    connect?: Enumerable<ConversationWhereUniqueInput>
    update?: Enumerable<ConversationUpdateWithWhereUniqueWithoutBotInput>
    updateMany?: Enumerable<ConversationUpdateManyWithWhereWithoutBotInput>
    deleteMany?: Enumerable<ConversationScalarWhereInput>
  }

  export type UserBotsUpdateManyWithoutBotInput = {
    create?: XOR<Enumerable<UserBotsCreateWithoutBotInput>, Enumerable<UserBotsUncheckedCreateWithoutBotInput>>
    connectOrCreate?: Enumerable<UserBotsCreateOrConnectWithoutBotInput>
    upsert?: Enumerable<UserBotsUpsertWithWhereUniqueWithoutBotInput>
    createMany?: UserBotsCreateManyBotInputEnvelope
    set?: Enumerable<UserBotsWhereUniqueInput>
    disconnect?: Enumerable<UserBotsWhereUniqueInput>
    delete?: Enumerable<UserBotsWhereUniqueInput>
    connect?: Enumerable<UserBotsWhereUniqueInput>
    update?: Enumerable<UserBotsUpdateWithWhereUniqueWithoutBotInput>
    updateMany?: Enumerable<UserBotsUpdateManyWithWhereWithoutBotInput>
    deleteMany?: Enumerable<UserBotsScalarWhereInput>
  }

  export type ConversationUncheckedUpdateManyWithoutBotInput = {
    create?: XOR<Enumerable<ConversationCreateWithoutBotInput>, Enumerable<ConversationUncheckedCreateWithoutBotInput>>
    connectOrCreate?: Enumerable<ConversationCreateOrConnectWithoutBotInput>
    upsert?: Enumerable<ConversationUpsertWithWhereUniqueWithoutBotInput>
    createMany?: ConversationCreateManyBotInputEnvelope
    set?: Enumerable<ConversationWhereUniqueInput>
    disconnect?: Enumerable<ConversationWhereUniqueInput>
    delete?: Enumerable<ConversationWhereUniqueInput>
    connect?: Enumerable<ConversationWhereUniqueInput>
    update?: Enumerable<ConversationUpdateWithWhereUniqueWithoutBotInput>
    updateMany?: Enumerable<ConversationUpdateManyWithWhereWithoutBotInput>
    deleteMany?: Enumerable<ConversationScalarWhereInput>
  }

  export type UserBotsUncheckedUpdateManyWithoutBotInput = {
    create?: XOR<Enumerable<UserBotsCreateWithoutBotInput>, Enumerable<UserBotsUncheckedCreateWithoutBotInput>>
    connectOrCreate?: Enumerable<UserBotsCreateOrConnectWithoutBotInput>
    upsert?: Enumerable<UserBotsUpsertWithWhereUniqueWithoutBotInput>
    createMany?: UserBotsCreateManyBotInputEnvelope
    set?: Enumerable<UserBotsWhereUniqueInput>
    disconnect?: Enumerable<UserBotsWhereUniqueInput>
    delete?: Enumerable<UserBotsWhereUniqueInput>
    connect?: Enumerable<UserBotsWhereUniqueInput>
    update?: Enumerable<UserBotsUpdateWithWhereUniqueWithoutBotInput>
    updateMany?: Enumerable<UserBotsUpdateManyWithWhereWithoutBotInput>
    deleteMany?: Enumerable<UserBotsScalarWhereInput>
  }

  export type BotCreateManystopSequencesInput = {
    set: Enumerable<string>
  }

  export type UserCreateNestedOneWithoutUserBotsInput = {
    create?: XOR<UserCreateWithoutUserBotsInput, UserUncheckedCreateWithoutUserBotsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserBotsInput
    connect?: UserWhereUniqueInput
  }

  export type BotCreateNestedOneWithoutUserBotsInput = {
    create?: XOR<BotCreateWithoutUserBotsInput, BotUncheckedCreateWithoutUserBotsInput>
    connectOrCreate?: BotCreateOrConnectWithoutUserBotsInput
    connect?: BotWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserBotsInput = {
    create?: XOR<UserCreateWithoutUserBotsInput, UserUncheckedCreateWithoutUserBotsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserBotsInput
    upsert?: UserUpsertWithoutUserBotsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserBotsInput, UserUncheckedUpdateWithoutUserBotsInput>
  }

  export type BotUpdateOneRequiredWithoutUserBotsInput = {
    create?: XOR<BotCreateWithoutUserBotsInput, BotUncheckedCreateWithoutUserBotsInput>
    connectOrCreate?: BotCreateOrConnectWithoutUserBotsInput
    upsert?: BotUpsertWithoutUserBotsInput
    connect?: BotWhereUniqueInput
    update?: XOR<BotUpdateWithoutUserBotsInput, BotUncheckedUpdateWithoutUserBotsInput>
  }

  export type UserCreateNestedManyWithoutPayerInput = {
    create?: XOR<Enumerable<UserCreateWithoutPayerInput>, Enumerable<UserUncheckedCreateWithoutPayerInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutPayerInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUpdateManyWithoutPayerInput = {
    create?: XOR<Enumerable<UserCreateWithoutPayerInput>, Enumerable<UserUncheckedCreateWithoutPayerInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutPayerInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutPayerInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutPayerInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutPayerInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type PriceCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<PriceCreateWithoutProductInput>, Enumerable<PriceUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PriceCreateOrConnectWithoutProductInput>
    createMany?: PriceCreateManyProductInputEnvelope
    connect?: Enumerable<PriceWhereUniqueInput>
  }

  export type PriceUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<PriceCreateWithoutProductInput>, Enumerable<PriceUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PriceCreateOrConnectWithoutProductInput>
    createMany?: PriceCreateManyProductInputEnvelope
    connect?: Enumerable<PriceWhereUniqueInput>
  }

  export type PriceUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<PriceCreateWithoutProductInput>, Enumerable<PriceUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PriceCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<PriceUpsertWithWhereUniqueWithoutProductInput>
    createMany?: PriceCreateManyProductInputEnvelope
    set?: Enumerable<PriceWhereUniqueInput>
    disconnect?: Enumerable<PriceWhereUniqueInput>
    delete?: Enumerable<PriceWhereUniqueInput>
    connect?: Enumerable<PriceWhereUniqueInput>
    update?: Enumerable<PriceUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<PriceUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<PriceScalarWhereInput>
  }

  export type PriceUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<PriceCreateWithoutProductInput>, Enumerable<PriceUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PriceCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<PriceUpsertWithWhereUniqueWithoutProductInput>
    createMany?: PriceCreateManyProductInputEnvelope
    set?: Enumerable<PriceWhereUniqueInput>
    disconnect?: Enumerable<PriceWhereUniqueInput>
    delete?: Enumerable<PriceWhereUniqueInput>
    connect?: Enumerable<PriceWhereUniqueInput>
    update?: Enumerable<PriceUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<PriceUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<PriceScalarWhereInput>
  }

  export type ProductCreateNestedOneWithoutPricesInput = {
    create?: XOR<ProductCreateWithoutPricesInput, ProductUncheckedCreateWithoutPricesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPricesInput
    connect?: ProductWhereUniqueInput
  }

  export type SubscriptionCreateNestedManyWithoutPriceInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutPriceInput>, Enumerable<SubscriptionUncheckedCreateWithoutPriceInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutPriceInput>
    createMany?: SubscriptionCreateManyPriceInputEnvelope
    connect?: Enumerable<SubscriptionWhereUniqueInput>
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutPriceInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutPriceInput>, Enumerable<SubscriptionUncheckedCreateWithoutPriceInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutPriceInput>
    createMany?: SubscriptionCreateManyPriceInputEnvelope
    connect?: Enumerable<SubscriptionWhereUniqueInput>
  }

  export type NullableEnumPriceIntervalFieldUpdateOperationsInput = {
    set?: PriceInterval | null
  }

  export type NullableEnumPriceTypeFieldUpdateOperationsInput = {
    set?: PriceType | null
  }

  export type ProductUpdateOneRequiredWithoutPricesInput = {
    create?: XOR<ProductCreateWithoutPricesInput, ProductUncheckedCreateWithoutPricesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPricesInput
    upsert?: ProductUpsertWithoutPricesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutPricesInput, ProductUncheckedUpdateWithoutPricesInput>
  }

  export type SubscriptionUpdateManyWithoutPriceInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutPriceInput>, Enumerable<SubscriptionUncheckedCreateWithoutPriceInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutPriceInput>
    upsert?: Enumerable<SubscriptionUpsertWithWhereUniqueWithoutPriceInput>
    createMany?: SubscriptionCreateManyPriceInputEnvelope
    set?: Enumerable<SubscriptionWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionWhereUniqueInput>
    delete?: Enumerable<SubscriptionWhereUniqueInput>
    connect?: Enumerable<SubscriptionWhereUniqueInput>
    update?: Enumerable<SubscriptionUpdateWithWhereUniqueWithoutPriceInput>
    updateMany?: Enumerable<SubscriptionUpdateManyWithWhereWithoutPriceInput>
    deleteMany?: Enumerable<SubscriptionScalarWhereInput>
  }

  export type SubscriptionUncheckedUpdateManyWithoutPriceInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutPriceInput>, Enumerable<SubscriptionUncheckedCreateWithoutPriceInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutPriceInput>
    upsert?: Enumerable<SubscriptionUpsertWithWhereUniqueWithoutPriceInput>
    createMany?: SubscriptionCreateManyPriceInputEnvelope
    set?: Enumerable<SubscriptionWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionWhereUniqueInput>
    delete?: Enumerable<SubscriptionWhereUniqueInput>
    connect?: Enumerable<SubscriptionWhereUniqueInput>
    update?: Enumerable<SubscriptionUpdateWithWhereUniqueWithoutPriceInput>
    updateMany?: Enumerable<SubscriptionUpdateManyWithWhereWithoutPriceInput>
    deleteMany?: Enumerable<SubscriptionScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type PriceCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<PriceCreateWithoutSubscriptionsInput, PriceUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PriceCreateOrConnectWithoutSubscriptionsInput
    connect?: PriceWhereUniqueInput
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: SubscriptionStatus
  }

  export type UserUpdateOneRequiredWithoutSubscriptionsInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    upsert?: UserUpsertWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PriceUpdateOneWithoutSubscriptionsInput = {
    create?: XOR<PriceCreateWithoutSubscriptionsInput, PriceUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PriceCreateOrConnectWithoutSubscriptionsInput
    upsert?: PriceUpsertWithoutSubscriptionsInput
    disconnect?: boolean
    delete?: boolean
    connect?: PriceWhereUniqueInput
    update?: XOR<PriceUpdateWithoutSubscriptionsInput, PriceUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedEnumUserRoleFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleFilter | UserRole
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedEnumUserRoleWithAggregatesFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleWithAggregatesFilter | UserRole
    _count?: NestedIntFilter
    _min?: NestedEnumUserRoleFilter
    _max?: NestedEnumUserRoleFilter
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | number | string
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalFilter | Decimal | number | string
  }

  export type NestedDecimalNullableFilter = {
    equals?: Decimal | number | string | null
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalNullableFilter | Decimal | number | string | null
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | number | string
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type NestedDecimalNullableWithAggregatesFilter = {
    equals?: Decimal | number | string | null
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type NestedEnumPriceIntervalNullableFilter = {
    equals?: PriceInterval | null
    in?: Enumerable<PriceInterval> | null
    notIn?: Enumerable<PriceInterval> | null
    not?: NestedEnumPriceIntervalNullableFilter | PriceInterval | null
  }

  export type NestedEnumPriceTypeNullableFilter = {
    equals?: PriceType | null
    in?: Enumerable<PriceType> | null
    notIn?: Enumerable<PriceType> | null
    not?: NestedEnumPriceTypeNullableFilter | PriceType | null
  }

  export type NestedEnumPriceIntervalNullableWithAggregatesFilter = {
    equals?: PriceInterval | null
    in?: Enumerable<PriceInterval> | null
    notIn?: Enumerable<PriceInterval> | null
    not?: NestedEnumPriceIntervalNullableWithAggregatesFilter | PriceInterval | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumPriceIntervalNullableFilter
    _max?: NestedEnumPriceIntervalNullableFilter
  }

  export type NestedEnumPriceTypeNullableWithAggregatesFilter = {
    equals?: PriceType | null
    in?: Enumerable<PriceType> | null
    notIn?: Enumerable<PriceType> | null
    not?: NestedEnumPriceTypeNullableWithAggregatesFilter | PriceType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumPriceTypeNullableFilter
    _max?: NestedEnumPriceTypeNullableFilter
  }

  export type NestedEnumSubscriptionStatusFilter = {
    equals?: SubscriptionStatus
    in?: Enumerable<SubscriptionStatus>
    notIn?: Enumerable<SubscriptionStatus>
    not?: NestedEnumSubscriptionStatusFilter | SubscriptionStatus
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter = {
    equals?: SubscriptionStatus
    in?: Enumerable<SubscriptionStatus>
    notIn?: Enumerable<SubscriptionStatus>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter | SubscriptionStatus
    _count?: NestedIntFilter
    _min?: NestedEnumSubscriptionStatusFilter
    _max?: NestedEnumSubscriptionStatusFilter
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    tokenType?: string | null
    expiresAt?: number | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
    oauthTokenSecret?: string | null
    oauthToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    tokenType?: string | null
    expiresAt?: number | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
    oauthTokenSecret?: string | null
    oauthToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: Enumerable<AccountCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutUserInput = {
    id?: string
    status: SubscriptionStatus
    startDate?: Date | string | null
    endedAt?: Date | string | null
    trialEnd?: Date | string | null
    trialStart?: Date | string | null
    cancelAt?: Date | string | null
    cancelAtPeriodEnd?: boolean | null
    canceledAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    price?: PriceCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    priceId?: string | null
    status: SubscriptionStatus
    startDate?: Date | string | null
    endedAt?: Date | string | null
    trialEnd?: Date | string | null
    trialStart?: Date | string | null
    cancelAt?: Date | string | null
    cancelAtPeriodEnd?: boolean | null
    canceledAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionCreateManyUserInputEnvelope = {
    data: Enumerable<SubscriptionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutUserInput = {
    id?: string
    firstName: string
    lastName?: string | null
    birthDate?: Date | string | null
    profileData?: NullableJsonNullValueInput | InputJsonValue
    picture?: string
    notifyEmail?: boolean
    notifyPush?: boolean
    notifyBadge?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: string
    firstName: string
    lastName?: string | null
    birthDate?: Date | string | null
    profileData?: NullableJsonNullValueInput | InputJsonValue
    picture?: string
    notifyEmail?: boolean
    notifyPush?: boolean
    notifyBadge?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type PayerCreateWithoutUsersInput = {
    id?: string
    stripeCustomerId: string
    stripeSubscriptionId: string
    stripePriceId: string
    stripeCurrentPeriodEnd: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayerUncheckedCreateWithoutUsersInput = {
    id?: string
    stripeCustomerId: string
    stripeSubscriptionId: string
    stripePriceId: string
    stripeCurrentPeriodEnd: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayerCreateOrConnectWithoutUsersInput = {
    where: PayerWhereUniqueInput
    create: XOR<PayerCreateWithoutUsersInput, PayerUncheckedCreateWithoutUsersInput>
  }

  export type UserBotsCreateWithoutUserInput = {
    id?: string
    botSeedData?: string | null
    nextMessageHour?: string | null
    isFinished?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bot: BotCreateNestedOneWithoutUserBotsInput
  }

  export type UserBotsUncheckedCreateWithoutUserInput = {
    id?: string
    botId: string
    botSeedData?: string | null
    nextMessageHour?: string | null
    isFinished?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBotsCreateOrConnectWithoutUserInput = {
    where: UserBotsWhereUniqueInput
    create: XOR<UserBotsCreateWithoutUserInput, UserBotsUncheckedCreateWithoutUserInput>
  }

  export type UserBotsCreateManyUserInputEnvelope = {
    data: Enumerable<UserBotsCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutUserInput = {
    id?: string
    name: string
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt: string
    isFlagged?: boolean | null
    isFinished?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bot?: BotCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    botId?: string | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt: string
    isFlagged?: boolean | null
    isFinished?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutUserInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationCreateManyUserInputEnvelope = {
    data: Enumerable<ConversationCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutAccountsInput>
  }

  export type AccountScalarWhereInput = {
    AND?: Enumerable<AccountScalarWhereInput>
    OR?: Enumerable<AccountScalarWhereInput>
    NOT?: Enumerable<AccountScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    type?: StringFilter | string
    provider?: StringFilter | string
    providerAccountId?: StringFilter | string
    refreshToken?: StringNullableFilter | string | null
    accessToken?: StringNullableFilter | string | null
    tokenType?: StringNullableFilter | string | null
    expiresAt?: IntNullableFilter | number | null
    scope?: StringNullableFilter | string | null
    idToken?: StringNullableFilter | string | null
    sessionState?: StringNullableFilter | string | null
    oauthTokenSecret?: StringNullableFilter | string | null
    oauthToken?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutSubscriptionsInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: Enumerable<SubscriptionScalarWhereInput>
    OR?: Enumerable<SubscriptionScalarWhereInput>
    NOT?: Enumerable<SubscriptionScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    priceId?: StringNullableFilter | string | null
    status?: EnumSubscriptionStatusFilter | SubscriptionStatus
    startDate?: DateTimeNullableFilter | Date | string | null
    endedAt?: DateTimeNullableFilter | Date | string | null
    trialEnd?: DateTimeNullableFilter | Date | string | null
    trialStart?: DateTimeNullableFilter | Date | string | null
    cancelAt?: DateTimeNullableFilter | Date | string | null
    cancelAtPeriodEnd?: BoolNullableFilter | boolean | null
    canceledAt?: DateTimeNullableFilter | Date | string | null
    metadata?: JsonNullableFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileData?: NullableJsonNullValueInput | InputJsonValue
    picture?: StringFieldUpdateOperationsInput | string
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    notifyBadge?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileData?: NullableJsonNullValueInput | InputJsonValue
    picture?: StringFieldUpdateOperationsInput | string
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    notifyBadge?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayerUpsertWithWhereUniqueWithoutUsersInput = {
    where: PayerWhereUniqueInput
    update: XOR<PayerUpdateWithoutUsersInput, PayerUncheckedUpdateWithoutUsersInput>
    create: XOR<PayerCreateWithoutUsersInput, PayerUncheckedCreateWithoutUsersInput>
  }

  export type PayerUpdateWithWhereUniqueWithoutUsersInput = {
    where: PayerWhereUniqueInput
    data: XOR<PayerUpdateWithoutUsersInput, PayerUncheckedUpdateWithoutUsersInput>
  }

  export type PayerUpdateManyWithWhereWithoutUsersInput = {
    where: PayerScalarWhereInput
    data: XOR<PayerUpdateManyMutationInput, PayerUncheckedUpdateManyWithoutPayerInput>
  }

  export type PayerScalarWhereInput = {
    AND?: Enumerable<PayerScalarWhereInput>
    OR?: Enumerable<PayerScalarWhereInput>
    NOT?: Enumerable<PayerScalarWhereInput>
    id?: StringFilter | string
    stripeCustomerId?: StringFilter | string
    stripeSubscriptionId?: StringFilter | string
    stripePriceId?: StringFilter | string
    stripeCurrentPeriodEnd?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserBotsUpsertWithWhereUniqueWithoutUserInput = {
    where: UserBotsWhereUniqueInput
    update: XOR<UserBotsUpdateWithoutUserInput, UserBotsUncheckedUpdateWithoutUserInput>
    create: XOR<UserBotsCreateWithoutUserInput, UserBotsUncheckedCreateWithoutUserInput>
  }

  export type UserBotsUpdateWithWhereUniqueWithoutUserInput = {
    where: UserBotsWhereUniqueInput
    data: XOR<UserBotsUpdateWithoutUserInput, UserBotsUncheckedUpdateWithoutUserInput>
  }

  export type UserBotsUpdateManyWithWhereWithoutUserInput = {
    where: UserBotsScalarWhereInput
    data: XOR<UserBotsUpdateManyMutationInput, UserBotsUncheckedUpdateManyWithoutUserBotsInput>
  }

  export type UserBotsScalarWhereInput = {
    AND?: Enumerable<UserBotsScalarWhereInput>
    OR?: Enumerable<UserBotsScalarWhereInput>
    NOT?: Enumerable<UserBotsScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    botId?: StringFilter | string
    botSeedData?: StringNullableFilter | string | null
    nextMessageHour?: StringNullableFilter | string | null
    isFinished?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
  }

  export type ConversationUpdateManyWithWhereWithoutUserInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: Enumerable<ConversationScalarWhereInput>
    OR?: Enumerable<ConversationScalarWhereInput>
    NOT?: Enumerable<ConversationScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    botId?: StringNullableFilter | string | null
    userData?: JsonNullableFilter
    prompt?: StringFilter | string
    userId?: StringFilter | string
    isFlagged?: BoolNullableFilter | boolean | null
    isFinished?: BoolNullableFilter | boolean | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    timeZone?: string | null
    role?: UserRole
    bubbleId?: string | null
    bubbleRole?: string | null
    slackPostId?: string | null
    autoReply?: boolean | null
    isActive?: boolean | null
    disabledReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    payer?: PayerCreateNestedManyWithoutUsersInput
    userBots?: UserBotsCreateNestedManyWithoutUserInput
    conversation?: ConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    timeZone?: string | null
    role?: UserRole
    bubbleId?: string | null
    bubbleRole?: string | null
    slackPostId?: string | null
    autoReply?: boolean | null
    isActive?: boolean | null
    disabledReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    userBots?: UserBotsUncheckedCreateNestedManyWithoutUserInput
    conversation?: ConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    bubbleId?: NullableStringFieldUpdateOperationsInput | string | null
    bubbleRole?: NullableStringFieldUpdateOperationsInput | string | null
    slackPostId?: NullableStringFieldUpdateOperationsInput | string | null
    autoReply?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disabledReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUpdateManyWithoutUserInput
    profile?: ProfileUpdateOneWithoutUserInput
    payer?: PayerUpdateManyWithoutUsersInput
    userBots?: UserBotsUpdateManyWithoutUserInput
    conversation?: ConversationUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    bubbleId?: NullableStringFieldUpdateOperationsInput | string | null
    bubbleRole?: NullableStringFieldUpdateOperationsInput | string | null
    slackPostId?: NullableStringFieldUpdateOperationsInput | string | null
    autoReply?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disabledReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserInput
    profile?: ProfileUncheckedUpdateOneWithoutUserInput
    userBots?: UserBotsUncheckedUpdateManyWithoutUserInput
    conversation?: ConversationUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    timeZone?: string | null
    role?: UserRole
    bubbleId?: string | null
    bubbleRole?: string | null
    slackPostId?: string | null
    autoReply?: boolean | null
    isActive?: boolean | null
    disabledReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    payer?: PayerCreateNestedManyWithoutUsersInput
    userBots?: UserBotsCreateNestedManyWithoutUserInput
    conversation?: ConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    timeZone?: string | null
    role?: UserRole
    bubbleId?: string | null
    bubbleRole?: string | null
    slackPostId?: string | null
    autoReply?: boolean | null
    isActive?: boolean | null
    disabledReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    userBots?: UserBotsUncheckedCreateNestedManyWithoutUserInput
    conversation?: ConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    bubbleId?: NullableStringFieldUpdateOperationsInput | string | null
    bubbleRole?: NullableStringFieldUpdateOperationsInput | string | null
    slackPostId?: NullableStringFieldUpdateOperationsInput | string | null
    autoReply?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disabledReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserInput
    subscriptions?: SubscriptionUpdateManyWithoutUserInput
    payer?: PayerUpdateManyWithoutUsersInput
    userBots?: UserBotsUpdateManyWithoutUserInput
    conversation?: ConversationUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    bubbleId?: NullableStringFieldUpdateOperationsInput | string | null
    bubbleRole?: NullableStringFieldUpdateOperationsInput | string | null
    slackPostId?: NullableStringFieldUpdateOperationsInput | string | null
    autoReply?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disabledReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserInput
    userBots?: UserBotsUncheckedUpdateManyWithoutUserInput
    conversation?: ConversationUncheckedUpdateManyWithoutUserInput
  }

  export type BotCreateWithoutConversationsInput = {
    id?: string
    name: string
    model?: string
    initialPrompt: string
    summarizePrompt?: string | null
    finisherPrompt?: string | null
    temperature?: Decimal | number | string
    max_tokens?: Decimal | number | string
    top_p?: Decimal | number | string
    frequency_penalty?: Decimal | number | string
    presence_penalty?: Decimal | number | string
    best_of?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stopSequences?: BotCreatestopSequencesInput | Enumerable<string>
    userBots?: UserBotsCreateNestedManyWithoutBotInput
  }

  export type BotUncheckedCreateWithoutConversationsInput = {
    id?: string
    name: string
    model?: string
    initialPrompt: string
    summarizePrompt?: string | null
    finisherPrompt?: string | null
    temperature?: Decimal | number | string
    max_tokens?: Decimal | number | string
    top_p?: Decimal | number | string
    frequency_penalty?: Decimal | number | string
    presence_penalty?: Decimal | number | string
    best_of?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stopSequences?: BotCreatestopSequencesInput | Enumerable<string>
    userBots?: UserBotsUncheckedCreateNestedManyWithoutBotInput
  }

  export type BotCreateOrConnectWithoutConversationsInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutConversationsInput, BotUncheckedCreateWithoutConversationsInput>
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    input?: string | null
    prompt: string
    gptResponse?: string | null
    isGptFlagged?: boolean | null
    gptModeration?: string | null
    isManualResonse?: boolean | null
    userResponse?: string | null
    userModeration?: string | null
    userAllowedByDefense?: boolean | null
    isUserFlagged?: boolean | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    isDeliveredToUser?: Date | string | null
    smsSid?: string | null
    shouldFinish?: boolean | null
    tokenUsage?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    input?: string | null
    prompt: string
    gptResponse?: string | null
    isGptFlagged?: boolean | null
    gptModeration?: string | null
    isManualResonse?: boolean | null
    userResponse?: string | null
    userModeration?: string | null
    userAllowedByDefense?: boolean | null
    isUserFlagged?: boolean | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    isDeliveredToUser?: Date | string | null
    smsSid?: string | null
    shouldFinish?: boolean | null
    tokenUsage?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: Enumerable<MessageCreateManyConversationInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutConversationInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    timeZone?: string | null
    role?: UserRole
    bubbleId?: string | null
    bubbleRole?: string | null
    slackPostId?: string | null
    autoReply?: boolean | null
    isActive?: boolean | null
    disabledReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    payer?: PayerCreateNestedManyWithoutUsersInput
    userBots?: UserBotsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConversationInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    timeZone?: string | null
    role?: UserRole
    bubbleId?: string | null
    bubbleRole?: string | null
    slackPostId?: string | null
    autoReply?: boolean | null
    isActive?: boolean | null
    disabledReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    userBots?: UserBotsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConversationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationInput, UserUncheckedCreateWithoutConversationInput>
  }

  export type BotUpsertWithoutConversationsInput = {
    update: XOR<BotUpdateWithoutConversationsInput, BotUncheckedUpdateWithoutConversationsInput>
    create: XOR<BotCreateWithoutConversationsInput, BotUncheckedCreateWithoutConversationsInput>
  }

  export type BotUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    initialPrompt?: StringFieldUpdateOperationsInput | string
    summarizePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    finisherPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_tokens?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    top_p?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    frequency_penalty?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    presence_penalty?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    best_of?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stopSequences?: BotUpdatestopSequencesInput | Enumerable<string>
    userBots?: UserBotsUpdateManyWithoutBotInput
  }

  export type BotUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    initialPrompt?: StringFieldUpdateOperationsInput | string
    summarizePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    finisherPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_tokens?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    top_p?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    frequency_penalty?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    presence_penalty?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    best_of?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stopSequences?: BotUpdatestopSequencesInput | Enumerable<string>
    userBots?: UserBotsUncheckedUpdateManyWithoutBotInput
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutMessagesInput>
  }

  export type MessageScalarWhereInput = {
    AND?: Enumerable<MessageScalarWhereInput>
    OR?: Enumerable<MessageScalarWhereInput>
    NOT?: Enumerable<MessageScalarWhereInput>
    id?: StringFilter | string
    conversationId?: StringFilter | string
    input?: StringNullableFilter | string | null
    prompt?: StringFilter | string
    gptResponse?: StringNullableFilter | string | null
    isGptFlagged?: BoolNullableFilter | boolean | null
    gptModeration?: StringNullableFilter | string | null
    isManualResonse?: BoolNullableFilter | boolean | null
    userResponse?: StringNullableFilter | string | null
    userModeration?: StringNullableFilter | string | null
    userAllowedByDefense?: BoolNullableFilter | boolean | null
    isUserFlagged?: BoolNullableFilter | boolean | null
    userData?: JsonNullableFilter
    isDeliveredToUser?: DateTimeNullableFilter | Date | string | null
    smsSid?: StringNullableFilter | string | null
    shouldFinish?: BoolNullableFilter | boolean | null
    tokenUsage?: JsonNullableFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserUpsertWithoutConversationInput = {
    update: XOR<UserUpdateWithoutConversationInput, UserUncheckedUpdateWithoutConversationInput>
    create: XOR<UserCreateWithoutConversationInput, UserUncheckedCreateWithoutConversationInput>
  }

  export type UserUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    bubbleId?: NullableStringFieldUpdateOperationsInput | string | null
    bubbleRole?: NullableStringFieldUpdateOperationsInput | string | null
    slackPostId?: NullableStringFieldUpdateOperationsInput | string | null
    autoReply?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disabledReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserInput
    subscriptions?: SubscriptionUpdateManyWithoutUserInput
    profile?: ProfileUpdateOneWithoutUserInput
    payer?: PayerUpdateManyWithoutUsersInput
    userBots?: UserBotsUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    bubbleId?: NullableStringFieldUpdateOperationsInput | string | null
    bubbleRole?: NullableStringFieldUpdateOperationsInput | string | null
    slackPostId?: NullableStringFieldUpdateOperationsInput | string | null
    autoReply?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disabledReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserInput
    profile?: ProfileUncheckedUpdateOneWithoutUserInput
    userBots?: UserBotsUncheckedUpdateManyWithoutUserInput
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    name: string
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt: string
    isFlagged?: boolean | null
    isFinished?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bot?: BotCreateNestedOneWithoutConversationsInput
    user: UserCreateNestedOneWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    botId?: string | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt: string
    userId: string
    isFlagged?: boolean | null
    isFinished?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt?: StringFieldUpdateOperationsInput | string
    isFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFinished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: BotUpdateOneWithoutConversationsInput
    user?: UserUpdateOneRequiredWithoutConversationInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFinished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateWithoutBotInput = {
    id?: string
    name: string
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt: string
    isFlagged?: boolean | null
    isFinished?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutConversationInput
    user: UserCreateNestedOneWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutBotInput = {
    id?: string
    name: string
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt: string
    userId: string
    isFlagged?: boolean | null
    isFinished?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutBotInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutBotInput, ConversationUncheckedCreateWithoutBotInput>
  }

  export type ConversationCreateManyBotInputEnvelope = {
    data: Enumerable<ConversationCreateManyBotInput>
    skipDuplicates?: boolean
  }

  export type UserBotsCreateWithoutBotInput = {
    id?: string
    botSeedData?: string | null
    nextMessageHour?: string | null
    isFinished?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserBotsInput
  }

  export type UserBotsUncheckedCreateWithoutBotInput = {
    id?: string
    userId: string
    botSeedData?: string | null
    nextMessageHour?: string | null
    isFinished?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBotsCreateOrConnectWithoutBotInput = {
    where: UserBotsWhereUniqueInput
    create: XOR<UserBotsCreateWithoutBotInput, UserBotsUncheckedCreateWithoutBotInput>
  }

  export type UserBotsCreateManyBotInputEnvelope = {
    data: Enumerable<UserBotsCreateManyBotInput>
    skipDuplicates?: boolean
  }

  export type ConversationUpsertWithWhereUniqueWithoutBotInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutBotInput, ConversationUncheckedUpdateWithoutBotInput>
    create: XOR<ConversationCreateWithoutBotInput, ConversationUncheckedCreateWithoutBotInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutBotInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutBotInput, ConversationUncheckedUpdateWithoutBotInput>
  }

  export type ConversationUpdateManyWithWhereWithoutBotInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutConversationsInput>
  }

  export type UserBotsUpsertWithWhereUniqueWithoutBotInput = {
    where: UserBotsWhereUniqueInput
    update: XOR<UserBotsUpdateWithoutBotInput, UserBotsUncheckedUpdateWithoutBotInput>
    create: XOR<UserBotsCreateWithoutBotInput, UserBotsUncheckedCreateWithoutBotInput>
  }

  export type UserBotsUpdateWithWhereUniqueWithoutBotInput = {
    where: UserBotsWhereUniqueInput
    data: XOR<UserBotsUpdateWithoutBotInput, UserBotsUncheckedUpdateWithoutBotInput>
  }

  export type UserBotsUpdateManyWithWhereWithoutBotInput = {
    where: UserBotsScalarWhereInput
    data: XOR<UserBotsUpdateManyMutationInput, UserBotsUncheckedUpdateManyWithoutUserBotsInput>
  }

  export type UserCreateWithoutUserBotsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    timeZone?: string | null
    role?: UserRole
    bubbleId?: string | null
    bubbleRole?: string | null
    slackPostId?: string | null
    autoReply?: boolean | null
    isActive?: boolean | null
    disabledReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    payer?: PayerCreateNestedManyWithoutUsersInput
    conversation?: ConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserBotsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    timeZone?: string | null
    role?: UserRole
    bubbleId?: string | null
    bubbleRole?: string | null
    slackPostId?: string | null
    autoReply?: boolean | null
    isActive?: boolean | null
    disabledReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    conversation?: ConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserBotsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserBotsInput, UserUncheckedCreateWithoutUserBotsInput>
  }

  export type BotCreateWithoutUserBotsInput = {
    id?: string
    name: string
    model?: string
    initialPrompt: string
    summarizePrompt?: string | null
    finisherPrompt?: string | null
    temperature?: Decimal | number | string
    max_tokens?: Decimal | number | string
    top_p?: Decimal | number | string
    frequency_penalty?: Decimal | number | string
    presence_penalty?: Decimal | number | string
    best_of?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stopSequences?: BotCreatestopSequencesInput | Enumerable<string>
    conversations?: ConversationCreateNestedManyWithoutBotInput
  }

  export type BotUncheckedCreateWithoutUserBotsInput = {
    id?: string
    name: string
    model?: string
    initialPrompt: string
    summarizePrompt?: string | null
    finisherPrompt?: string | null
    temperature?: Decimal | number | string
    max_tokens?: Decimal | number | string
    top_p?: Decimal | number | string
    frequency_penalty?: Decimal | number | string
    presence_penalty?: Decimal | number | string
    best_of?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stopSequences?: BotCreatestopSequencesInput | Enumerable<string>
    conversations?: ConversationUncheckedCreateNestedManyWithoutBotInput
  }

  export type BotCreateOrConnectWithoutUserBotsInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutUserBotsInput, BotUncheckedCreateWithoutUserBotsInput>
  }

  export type UserUpsertWithoutUserBotsInput = {
    update: XOR<UserUpdateWithoutUserBotsInput, UserUncheckedUpdateWithoutUserBotsInput>
    create: XOR<UserCreateWithoutUserBotsInput, UserUncheckedCreateWithoutUserBotsInput>
  }

  export type UserUpdateWithoutUserBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    bubbleId?: NullableStringFieldUpdateOperationsInput | string | null
    bubbleRole?: NullableStringFieldUpdateOperationsInput | string | null
    slackPostId?: NullableStringFieldUpdateOperationsInput | string | null
    autoReply?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disabledReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserInput
    subscriptions?: SubscriptionUpdateManyWithoutUserInput
    profile?: ProfileUpdateOneWithoutUserInput
    payer?: PayerUpdateManyWithoutUsersInput
    conversation?: ConversationUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUserBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    bubbleId?: NullableStringFieldUpdateOperationsInput | string | null
    bubbleRole?: NullableStringFieldUpdateOperationsInput | string | null
    slackPostId?: NullableStringFieldUpdateOperationsInput | string | null
    autoReply?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disabledReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserInput
    profile?: ProfileUncheckedUpdateOneWithoutUserInput
    conversation?: ConversationUncheckedUpdateManyWithoutUserInput
  }

  export type BotUpsertWithoutUserBotsInput = {
    update: XOR<BotUpdateWithoutUserBotsInput, BotUncheckedUpdateWithoutUserBotsInput>
    create: XOR<BotCreateWithoutUserBotsInput, BotUncheckedCreateWithoutUserBotsInput>
  }

  export type BotUpdateWithoutUserBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    initialPrompt?: StringFieldUpdateOperationsInput | string
    summarizePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    finisherPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_tokens?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    top_p?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    frequency_penalty?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    presence_penalty?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    best_of?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stopSequences?: BotUpdatestopSequencesInput | Enumerable<string>
    conversations?: ConversationUpdateManyWithoutBotInput
  }

  export type BotUncheckedUpdateWithoutUserBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    initialPrompt?: StringFieldUpdateOperationsInput | string
    summarizePrompt?: NullableStringFieldUpdateOperationsInput | string | null
    finisherPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_tokens?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    top_p?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    frequency_penalty?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    presence_penalty?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    best_of?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stopSequences?: BotUpdatestopSequencesInput | Enumerable<string>
    conversations?: ConversationUncheckedUpdateManyWithoutBotInput
  }

  export type UserCreateWithoutPayerInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    timeZone?: string | null
    role?: UserRole
    bubbleId?: string | null
    bubbleRole?: string | null
    slackPostId?: string | null
    autoReply?: boolean | null
    isActive?: boolean | null
    disabledReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    userBots?: UserBotsCreateNestedManyWithoutUserInput
    conversation?: ConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPayerInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    timeZone?: string | null
    role?: UserRole
    bubbleId?: string | null
    bubbleRole?: string | null
    slackPostId?: string | null
    autoReply?: boolean | null
    isActive?: boolean | null
    disabledReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    userBots?: UserBotsUncheckedCreateNestedManyWithoutUserInput
    conversation?: ConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPayerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPayerInput, UserUncheckedCreateWithoutPayerInput>
  }

  export type UserUpsertWithWhereUniqueWithoutPayerInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutPayerInput, UserUncheckedUpdateWithoutPayerInput>
    create: XOR<UserCreateWithoutPayerInput, UserUncheckedCreateWithoutPayerInput>
  }

  export type UserUpdateWithWhereUniqueWithoutPayerInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutPayerInput, UserUncheckedUpdateWithoutPayerInput>
  }

  export type UserUpdateManyWithWhereWithoutPayerInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: StringFilter | string
    email?: StringFilter | string
    emailVerified?: DateTimeNullableFilter | Date | string | null
    passwordDigest?: StringNullableFilter | string | null
    phoneNumber?: StringFilter | string
    phoneNumberVerified?: DateTimeNullableFilter | Date | string | null
    timeZone?: StringNullableFilter | string | null
    role?: EnumUserRoleFilter | UserRole
    bubbleId?: StringNullableFilter | string | null
    bubbleRole?: StringNullableFilter | string | null
    slackPostId?: StringNullableFilter | string | null
    autoReply?: BoolNullableFilter | boolean | null
    isActive?: BoolNullableFilter | boolean | null
    disabledReason?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PriceCreateWithoutProductInput = {
    id?: string
    active?: boolean
    currency: string
    interval?: PriceInterval | null
    unitAmount?: Decimal | number | string | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    type?: PriceType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionCreateNestedManyWithoutPriceInput
  }

  export type PriceUncheckedCreateWithoutProductInput = {
    id?: string
    active?: boolean
    currency: string
    interval?: PriceInterval | null
    unitAmount?: Decimal | number | string | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    type?: PriceType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPriceInput
  }

  export type PriceCreateOrConnectWithoutProductInput = {
    where: PriceWhereUniqueInput
    create: XOR<PriceCreateWithoutProductInput, PriceUncheckedCreateWithoutProductInput>
  }

  export type PriceCreateManyProductInputEnvelope = {
    data: Enumerable<PriceCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type PriceUpsertWithWhereUniqueWithoutProductInput = {
    where: PriceWhereUniqueInput
    update: XOR<PriceUpdateWithoutProductInput, PriceUncheckedUpdateWithoutProductInput>
    create: XOR<PriceCreateWithoutProductInput, PriceUncheckedCreateWithoutProductInput>
  }

  export type PriceUpdateWithWhereUniqueWithoutProductInput = {
    where: PriceWhereUniqueInput
    data: XOR<PriceUpdateWithoutProductInput, PriceUncheckedUpdateWithoutProductInput>
  }

  export type PriceUpdateManyWithWhereWithoutProductInput = {
    where: PriceScalarWhereInput
    data: XOR<PriceUpdateManyMutationInput, PriceUncheckedUpdateManyWithoutPricesInput>
  }

  export type PriceScalarWhereInput = {
    AND?: Enumerable<PriceScalarWhereInput>
    OR?: Enumerable<PriceScalarWhereInput>
    NOT?: Enumerable<PriceScalarWhereInput>
    id?: StringFilter | string
    productId?: StringFilter | string
    active?: BoolFilter | boolean
    currency?: StringFilter | string
    interval?: EnumPriceIntervalNullableFilter | PriceInterval | null
    unitAmount?: DecimalNullableFilter | Decimal | number | string | null
    intervalCount?: IntNullableFilter | number | null
    trialPeriodDays?: IntNullableFilter | number | null
    type?: EnumPriceTypeNullableFilter | PriceType | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProductCreateWithoutPricesInput = {
    id?: string
    active?: boolean
    name: string
    description?: string | null
    image?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUncheckedCreateWithoutPricesInput = {
    id?: string
    active?: boolean
    name: string
    description?: string | null
    image?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateOrConnectWithoutPricesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPricesInput, ProductUncheckedCreateWithoutPricesInput>
  }

  export type SubscriptionCreateWithoutPriceInput = {
    id?: string
    status: SubscriptionStatus
    startDate?: Date | string | null
    endedAt?: Date | string | null
    trialEnd?: Date | string | null
    trialStart?: Date | string | null
    cancelAt?: Date | string | null
    cancelAtPeriodEnd?: boolean | null
    canceledAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutPriceInput = {
    id?: string
    userId: string
    status: SubscriptionStatus
    startDate?: Date | string | null
    endedAt?: Date | string | null
    trialEnd?: Date | string | null
    trialStart?: Date | string | null
    cancelAt?: Date | string | null
    cancelAtPeriodEnd?: boolean | null
    canceledAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutPriceInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPriceInput, SubscriptionUncheckedCreateWithoutPriceInput>
  }

  export type SubscriptionCreateManyPriceInputEnvelope = {
    data: Enumerable<SubscriptionCreateManyPriceInput>
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutPricesInput = {
    update: XOR<ProductUpdateWithoutPricesInput, ProductUncheckedUpdateWithoutPricesInput>
    create: XOR<ProductCreateWithoutPricesInput, ProductUncheckedCreateWithoutPricesInput>
  }

  export type ProductUpdateWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutPriceInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutPriceInput, SubscriptionUncheckedUpdateWithoutPriceInput>
    create: XOR<SubscriptionCreateWithoutPriceInput, SubscriptionUncheckedCreateWithoutPriceInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutPriceInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutPriceInput, SubscriptionUncheckedUpdateWithoutPriceInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutPriceInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutSubscriptionsInput>
  }

  export type UserCreateWithoutSubscriptionsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    timeZone?: string | null
    role?: UserRole
    bubbleId?: string | null
    bubbleRole?: string | null
    slackPostId?: string | null
    autoReply?: boolean | null
    isActive?: boolean | null
    disabledReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    payer?: PayerCreateNestedManyWithoutUsersInput
    userBots?: UserBotsCreateNestedManyWithoutUserInput
    conversation?: ConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    passwordDigest?: string | null
    phoneNumber: string
    phoneNumberVerified?: Date | string | null
    timeZone?: string | null
    role?: UserRole
    bubbleId?: string | null
    bubbleRole?: string | null
    slackPostId?: string | null
    autoReply?: boolean | null
    isActive?: boolean | null
    disabledReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    userBots?: UserBotsUncheckedCreateNestedManyWithoutUserInput
    conversation?: ConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
  }

  export type PriceCreateWithoutSubscriptionsInput = {
    id?: string
    active?: boolean
    currency: string
    interval?: PriceInterval | null
    unitAmount?: Decimal | number | string | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    type?: PriceType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutPricesInput
  }

  export type PriceUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    productId: string
    active?: boolean
    currency: string
    interval?: PriceInterval | null
    unitAmount?: Decimal | number | string | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    type?: PriceType | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceCreateOrConnectWithoutSubscriptionsInput = {
    where: PriceWhereUniqueInput
    create: XOR<PriceCreateWithoutSubscriptionsInput, PriceUncheckedCreateWithoutSubscriptionsInput>
  }

  export type UserUpsertWithoutSubscriptionsInput = {
    update: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
  }

  export type UserUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    bubbleId?: NullableStringFieldUpdateOperationsInput | string | null
    bubbleRole?: NullableStringFieldUpdateOperationsInput | string | null
    slackPostId?: NullableStringFieldUpdateOperationsInput | string | null
    autoReply?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disabledReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserInput
    profile?: ProfileUpdateOneWithoutUserInput
    payer?: PayerUpdateManyWithoutUsersInput
    userBots?: UserBotsUpdateManyWithoutUserInput
    conversation?: ConversationUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    bubbleId?: NullableStringFieldUpdateOperationsInput | string | null
    bubbleRole?: NullableStringFieldUpdateOperationsInput | string | null
    slackPostId?: NullableStringFieldUpdateOperationsInput | string | null
    autoReply?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disabledReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserInput
    profile?: ProfileUncheckedUpdateOneWithoutUserInput
    userBots?: UserBotsUncheckedUpdateManyWithoutUserInput
    conversation?: ConversationUncheckedUpdateManyWithoutUserInput
  }

  export type PriceUpsertWithoutSubscriptionsInput = {
    update: XOR<PriceUpdateWithoutSubscriptionsInput, PriceUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<PriceCreateWithoutSubscriptionsInput, PriceUncheckedCreateWithoutSubscriptionsInput>
  }

  export type PriceUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    currency?: StringFieldUpdateOperationsInput | string
    interval?: NullableEnumPriceIntervalFieldUpdateOperationsInput | PriceInterval | null
    unitAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableEnumPriceTypeFieldUpdateOperationsInput | PriceType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutPricesInput
  }

  export type PriceUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    currency?: StringFieldUpdateOperationsInput | string
    interval?: NullableEnumPriceIntervalFieldUpdateOperationsInput | PriceInterval | null
    unitAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableEnumPriceTypeFieldUpdateOperationsInput | PriceType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    tokenType?: string | null
    expiresAt?: number | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
    oauthTokenSecret?: string | null
    oauthToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateManyUserInput = {
    id?: string
    priceId?: string | null
    status: SubscriptionStatus
    startDate?: Date | string | null
    endedAt?: Date | string | null
    trialEnd?: Date | string | null
    trialStart?: Date | string | null
    cancelAt?: Date | string | null
    cancelAtPeriodEnd?: boolean | null
    canceledAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBotsCreateManyUserInput = {
    id?: string
    botId: string
    botSeedData?: string | null
    nextMessageHour?: string | null
    isFinished?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateManyUserInput = {
    id?: string
    name: string
    botId?: string | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt: string
    isFlagged?: boolean | null
    isFinished?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
    oauthTokenSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: NullableBoolFieldUpdateOperationsInput | boolean | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: PriceUpdateOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: NullableBoolFieldUpdateOperationsInput | boolean | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: NullableBoolFieldUpdateOperationsInput | boolean | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayerUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    stripeCurrentPeriodEnd?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayerUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    stripeCurrentPeriodEnd?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayerUncheckedUpdateManyWithoutPayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    stripePriceId?: StringFieldUpdateOperationsInput | string
    stripeCurrentPeriodEnd?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBotsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    botSeedData?: NullableStringFieldUpdateOperationsInput | string | null
    nextMessageHour?: NullableStringFieldUpdateOperationsInput | string | null
    isFinished?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: BotUpdateOneRequiredWithoutUserBotsInput
  }

  export type UserBotsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    botSeedData?: NullableStringFieldUpdateOperationsInput | string | null
    nextMessageHour?: NullableStringFieldUpdateOperationsInput | string | null
    isFinished?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBotsUncheckedUpdateManyWithoutUserBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    botSeedData?: NullableStringFieldUpdateOperationsInput | string | null
    nextMessageHour?: NullableStringFieldUpdateOperationsInput | string | null
    isFinished?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt?: StringFieldUpdateOperationsInput | string
    isFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFinished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: BotUpdateOneWithoutConversationsInput
    messages?: MessageUpdateManyWithoutConversationInput
  }

  export type ConversationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt?: StringFieldUpdateOperationsInput | string
    isFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFinished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationInput
  }

  export type ConversationUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt?: StringFieldUpdateOperationsInput | string
    isFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFinished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    input?: string | null
    prompt: string
    gptResponse?: string | null
    isGptFlagged?: boolean | null
    gptModeration?: string | null
    isManualResonse?: boolean | null
    userResponse?: string | null
    userModeration?: string | null
    userAllowedByDefense?: boolean | null
    isUserFlagged?: boolean | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    isDeliveredToUser?: Date | string | null
    smsSid?: string | null
    shouldFinish?: boolean | null
    tokenUsage?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    input?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    gptResponse?: NullableStringFieldUpdateOperationsInput | string | null
    isGptFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gptModeration?: NullableStringFieldUpdateOperationsInput | string | null
    isManualResonse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userResponse?: NullableStringFieldUpdateOperationsInput | string | null
    userModeration?: NullableStringFieldUpdateOperationsInput | string | null
    userAllowedByDefense?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUserFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    isDeliveredToUser?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    smsSid?: NullableStringFieldUpdateOperationsInput | string | null
    shouldFinish?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tokenUsage?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    input?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    gptResponse?: NullableStringFieldUpdateOperationsInput | string | null
    isGptFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gptModeration?: NullableStringFieldUpdateOperationsInput | string | null
    isManualResonse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userResponse?: NullableStringFieldUpdateOperationsInput | string | null
    userModeration?: NullableStringFieldUpdateOperationsInput | string | null
    userAllowedByDefense?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUserFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    isDeliveredToUser?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    smsSid?: NullableStringFieldUpdateOperationsInput | string | null
    shouldFinish?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tokenUsage?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    input?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    gptResponse?: NullableStringFieldUpdateOperationsInput | string | null
    isGptFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gptModeration?: NullableStringFieldUpdateOperationsInput | string | null
    isManualResonse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userResponse?: NullableStringFieldUpdateOperationsInput | string | null
    userModeration?: NullableStringFieldUpdateOperationsInput | string | null
    userAllowedByDefense?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUserFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userData?: NullableJsonNullValueInput | InputJsonValue
    isDeliveredToUser?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    smsSid?: NullableStringFieldUpdateOperationsInput | string | null
    shouldFinish?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tokenUsage?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateManyBotInput = {
    id?: string
    name: string
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt: string
    userId: string
    isFlagged?: boolean | null
    isFinished?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBotsCreateManyBotInput = {
    id?: string
    userId: string
    botSeedData?: string | null
    nextMessageHour?: string | null
    isFinished?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt?: StringFieldUpdateOperationsInput | string
    isFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFinished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutConversationInput
    user?: UserUpdateOneRequiredWithoutConversationInput
  }

  export type ConversationUncheckedUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFinished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationInput
  }

  export type ConversationUncheckedUpdateManyWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userData?: NullableJsonNullValueInput | InputJsonValue
    prompt?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isFlagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFinished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBotsUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    botSeedData?: NullableStringFieldUpdateOperationsInput | string | null
    nextMessageHour?: NullableStringFieldUpdateOperationsInput | string | null
    isFinished?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserBotsInput
  }

  export type UserBotsUncheckedUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    botSeedData?: NullableStringFieldUpdateOperationsInput | string | null
    nextMessageHour?: NullableStringFieldUpdateOperationsInput | string | null
    isFinished?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutPayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    bubbleId?: NullableStringFieldUpdateOperationsInput | string | null
    bubbleRole?: NullableStringFieldUpdateOperationsInput | string | null
    slackPostId?: NullableStringFieldUpdateOperationsInput | string | null
    autoReply?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disabledReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserInput
    subscriptions?: SubscriptionUpdateManyWithoutUserInput
    profile?: ProfileUpdateOneWithoutUserInput
    userBots?: UserBotsUpdateManyWithoutUserInput
    conversation?: ConversationUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutPayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    bubbleId?: NullableStringFieldUpdateOperationsInput | string | null
    bubbleRole?: NullableStringFieldUpdateOperationsInput | string | null
    slackPostId?: NullableStringFieldUpdateOperationsInput | string | null
    autoReply?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disabledReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserInput
    profile?: ProfileUncheckedUpdateOneWithoutUserInput
    userBots?: UserBotsUncheckedUpdateManyWithoutUserInput
    conversation?: ConversationUncheckedUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordDigest?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneNumberVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    bubbleId?: NullableStringFieldUpdateOperationsInput | string | null
    bubbleRole?: NullableStringFieldUpdateOperationsInput | string | null
    slackPostId?: NullableStringFieldUpdateOperationsInput | string | null
    autoReply?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disabledReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceCreateManyProductInput = {
    id?: string
    active?: boolean
    currency: string
    interval?: PriceInterval | null
    unitAmount?: Decimal | number | string | null
    intervalCount?: number | null
    trialPeriodDays?: number | null
    type?: PriceType | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    currency?: StringFieldUpdateOperationsInput | string
    interval?: NullableEnumPriceIntervalFieldUpdateOperationsInput | PriceInterval | null
    unitAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableEnumPriceTypeFieldUpdateOperationsInput | PriceType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUpdateManyWithoutPriceInput
  }

  export type PriceUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    currency?: StringFieldUpdateOperationsInput | string
    interval?: NullableEnumPriceIntervalFieldUpdateOperationsInput | PriceInterval | null
    unitAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableEnumPriceTypeFieldUpdateOperationsInput | PriceType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPriceInput
  }

  export type PriceUncheckedUpdateManyWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    currency?: StringFieldUpdateOperationsInput | string
    interval?: NullableEnumPriceIntervalFieldUpdateOperationsInput | PriceInterval | null
    unitAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    intervalCount?: NullableIntFieldUpdateOperationsInput | number | null
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableEnumPriceTypeFieldUpdateOperationsInput | PriceType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyPriceInput = {
    id?: string
    userId: string
    status: SubscriptionStatus
    startDate?: Date | string | null
    endedAt?: Date | string | null
    trialEnd?: Date | string | null
    trialStart?: Date | string | null
    cancelAt?: Date | string | null
    cancelAtPeriodEnd?: boolean | null
    canceledAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: NullableBoolFieldUpdateOperationsInput | boolean | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedUpdateWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: NullableBoolFieldUpdateOperationsInput | boolean | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}